/**
 * A buffered sender can act as a middle piece between something that constantly wants
 * to send data of type {@param S} and a function that can send an array of {@param S}.
 *
 * The constructor takes a function `batchedSend` that can send multiple `S` elements at once.
 * The buffered sender waits for the last `batchedSend` to complete before it sends the next batch;
 * while it waits, it will buffer all elements passed with `send`.
 *
 * This is done in an "opaque" way for the client, in that the client can simply call {@link send} and await
 * the response.
 *
 * For simplicity, the return type of `send` and `batchedSend` is `string | undefined`, but this could be
 * extended to any type.
 *
 * If no new elements have been sent since the last batch has been sent out, the buffered sender will
 * wait for `timeout` milliseconds before checking if new elements should be sent out.
 *
 * Note that this class doesn't handle termination properly yet. If the class is dereferenced, the `batchSend`
 * will still try to send out events regularly. If `batchSend` throws an error, the main loop crashes,
 * without resolving open promises. This is a TODO.
 *
 */
export declare class BufferedSender<S> {
    #private;
    constructor(
    /** Send data in batches, return result data for each. This method is expected to never throw. */
    batchedSend: (data: S[]) => Promise<(string | undefined)[]>, timeout?: number);
    send(data: S): Promise<string | undefined>;
}
