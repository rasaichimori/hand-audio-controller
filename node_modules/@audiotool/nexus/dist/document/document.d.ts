import { Modification, Transaction } from '../gen/audiotool/document/v1/document_service_pb';
import { EntityTypes } from '../gen/audiotool/document/v1/utils/types';
import { Notifier } from '../utils/observable-notifier';
import { NexusGateway } from './backend/gateway';
import { NexusValidator } from './backend/validator';
import { EntityTypeKey } from './entity-utils';
import { NexusEventManager } from './event-manager';
import { EntityQuery } from './query/entity';
import { SafeTransactionBuilder, TransactionBuilder } from './transaction-builder/builder';

export type TransactionOptions = {
    /**
     * With this field we can capture what a user might intuitively call a single "action", for example:
     * * moving a knob over the span of a few seconds, then letting go, is a single "action"
     * * clicking a button is an "action"
     * * drawing multiple notes without letting the mouse go is a single "action"
     *
     * By passing the same `actionId` symbol to multiple transactions, all of these transactions are marked
     * to be part of the same action. `actionId` symbols can freely be created using the `Symbol()` function.
     *
     * The undo/redo history uses this information to undo all transactions part of the same action in one go.
     *
     * If no `actionId` is provided, the transaction will be its own action. To make an action
     * skip the edit history, use the {@link skipEditHistoryActionId} symbol.
     *
     * ## Example
     * ```
     * const actionId = Symbol()
     *
     * await nexus.modify(t => {
     *    t.update(device.fields.value1, 0.5)
     *    t.update(device.fields.value2, 0.6)
     * }, { actionId })
     *
     * await await nexus.modify(t => {
     *    t.update(device.fields.value3, 0.7)
     * }, { actionId })
     *
     * // calling "undo" here would undo the change to fields `value1`, `value2` and `value3`.
     * ```
     */
    actionId?: symbol;
};
/**
 * Manages all data related to an audiotool project, and contains mechanisms to sync that
 * data with other clients and the backend in a conflict-free manner.
 *
 * Also manages event callbacks for when the data structure changes; undo/redo history;
 * creation of new transactions on the document; and has some utilities to query data structure.
 */
export declare class NexusDocument {
    #private;
    /** Public field to query the entities in the document.
     *
     * ## Careful
     *
     * This method of querying the nexus document doesn't require a transaction lock. Any time a transaction
     * lock is taken, all previous query results should be considered out of date.
     *
     * ### Example incorrect usage
     *
     * The `await nexus.modify` awaits other transactions to finish before the callback is executed.
     * These transactions could be removing the output entity, and so by the type `t.update` is called,
     * the update transaction would be invalid, resulting in an exception:
     *
     * ```
     * const output = nexus.queryEntitiesWithoutLock.ofTypes("output").getOne() ?? ..
     * await nexus.modify(t => {
     *     // updating a field of an entity that was potentially removed during the await
     *     t.update(output.fields.name, "hello")
     * })
     * ```
     *
     * ### Example Correct usage
     *
     * It's better to use the `entities` field in the {@link TransactionBuilder} that is of the same type.
     * In the example above, better write
     *
     * ```
     * await nexus.modify(t => {
     *     const output = t.entities.ofTypes("output").getOne() ?? ..
     *     t.update(output.fields.name, "hello")
     * })
     * ```
     */
    readonly queryEntitiesWithoutLock: EntityQuery<EntityTypeKey>;
    /** Manages subscriptions to nexus events, such as entity update & creation */
    readonly events: NexusEventManager;
    /**
     * This is a notifier that notifies of all modifications applied on the nexus
     * document, locally created or incoming from the backend.
     *
     * If the transaction is incoming `local` is `false`.
     */
    readonly onModification: Notifier<{
        modification: Modification;
        local: boolean;
        /** The action this modification belongs to. Can be undefined e.g. if the modification
         * originates from the backend.
         */
        actionId?: symbol;
    }>;
    /** Public field to query the entities in the document.
     *
     * @deprecated Don't use this field, as it can cause race conditions on the nexus document.
     *
     * Instead, use
     * * for building a transaction: {@link TransactionBuilder.entities}
     * * for other purposes, being aware of caveats: {@link NexusDocument.queryEntitiesWithoutLock}
     *
     */
    readonly entities: EntityQuery<keyof EntityTypes>;
    /**
     * This flag is set to true if {@link takeTransactions} is called. Before that, no transactions
     * from the backend are processed, and no transactions are allowed to be created from the frontend.
     * Attempting to call {@link createTransaction} before this is set to true will throw an error.
     *
     * This is to make sure that all `onCreate` callbacks are attached before any entity is created.
     */
    get transactionsAllowed(): boolean;
    constructor(props?: {
        /** The delay between two gateway.synchronize() calls to sync with backend. */
        synchronizeEveryMs?: number;
        /**
         * Modifications in incoming transactions are batched into batches of this size.
         * After each batch, control is yielded to the scheduler to keep a good framerate.
         */
        incomingModificationsBatchSize?: number;
    });
    /**
     * Wait to acquire the document lock, then returns a {@link TransactionBuilder} that can be used to modify the nexus document
     * in a single transaction.
     *
     * To finish the transaction, call `send()`, which will release the lock, and send the modification to the backend. After this
     * method is called, no further methods can be called of the builder.
     *
     * The backend and other clients will only see changes after `send` is called, however locally, all changes are immediately applied.
     *
     * Note that every transaction by default is undoable, unless the flag in {@link TransactionOptions} is set to false.
     * @returns: {@link TransactionBuilder}
     */
    createTransaction(opts?: TransactionOptions): Promise<TransactionBuilder>;
    /**
     * A helper method for small transactions.
     *
     * Writing
     * ```ts
     * const foo = await nexus.modify(t => fn(t))
     * ```
     *
     * is shorthand for
     *
     * ```ts
     * const t = await this.createTransaction(opts)
     * const foo = await fn(t)
     * t.send()
     * ```
     *
     * Note that every transaction by default is undo-able, unless the flag in {@link TransactionOptions} is set to false.
     */
    modify<T>(fn: (m: SafeTransactionBuilder) => Promise<T> | T, opts?: TransactionOptions): Promise<T>;
    /**
     * This function connects the document with the backend and starts syncing its state.
     * The returned promise resolves once the document has synced up with the backend,
     * and allows creating local transaction using {@link createTransaction}.
     *
     * It should be called exactly once when all `onCreate` callbacks are registered.
     */
    takeTransactions(props?: {
        validator?: NexusValidator;
        gateway?: NexusGateway;
    }): Promise<void>;
    /** Apply a transaction that doesn't originate from this document. Yields to the browser
     * scheduler every few modifications applied to make sure we don't block the main thread
     * for too long for big transactions. Throws if the transaction lock isn't taken.
     */
    applyIncomingTransactions(ts: Transaction[]): Promise<void>;
    /** For debugging purposes */
    getStats(): {
        entities: number;
        references: number;
    };
}
