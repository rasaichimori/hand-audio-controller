import { NexusEntity, NexusEntityUnion } from './entity';
import { NexusLocation } from './location';
import { EntityTypes } from '../gen/audiotool/document/v1/utils/types';
import { Terminable } from '../utils/terminable';
import { NexusDocumentState } from './document-state/state';
import { PrimitiveField, PrimitiveType } from './fields';

/** Can be used to subscribe to changes in the document.
 *
 * Events for all existing entities are dispatched after {@link index.SyncedDocument.start} is called;
 * after this, they are dispatched either:
 * * as a result of remote changes, which happens while the transaction lock isn't taken by your code
 * * as a result of local changes made using a {@link document.TransactionBuilder}
 *
 * @example
 * ```ts
 * nexus.events.onCreate("tonematrix", (tm) => {
 *   console.debug("tonematrix created")
 *   return () => console.debug("tonematrix removed")
 * })
 * await nexus.modify(t => t.create("tonematrix", {}))
 * ```
 *
 *
 * When modifying the document using the {@link document.TransactionBuilder}, the event callbacks are
 * executed _immediately_ during the callback that creates the modification(s).
 *
 *
 * @example
 * ```ts
 * const tm = await nexus.modify((t) => t.create("tonematrix", {}))
 *
 * // attach onUpdate callback
 * nexus.events.onUpdate(tm.fields.isActive, (isActive) =>
 *   console.debug("(2) updating", isActive === tm.fields.isActive.value),
 * )
 *
 * await nexus.modify((t) => {
 *   console.debug("(1) will update")
 *   // update the field - callback above is executed before this method returns
 *   t.update(tm.fields.isActive, true)
 *  console.debug("(3) have updated")
 * })
 * ```
 *
 */
export declare class NexusEventManager {
    #private;
    /**
     * @internal
     * For debugging purposes, the first instance of the nexus event manager ever created. */
    static debugWindowInstance: NexusEventManager | undefined;
    constructor(documentState?: NexusDocumentState);
    /**
     * Subscribe to the event that an entity of a specific type is created.
     *
     * @returns A terminable that when terminated will stop dispatching new onCreate events. Cleanup functions that were returned
     * during entity creation will still be called on removal of the entity.
     */
    onCreate<T extends keyof EntityTypes | "*">(
    /**
     * The entity type to subscribe to, or `*` to subscribe to the creation of all entity types.
     */
    entityType: T, 
    /**
     * The callback called right after the entity is created.
     *
     * @example
     * ```ts
     * nexus.events.onCreate("tonematrix", (tm) => {
     *   console.debug("tonematrix", tm.id, "created")
     *   return () => console.debug("tonematrix", tm.id, "removed")
     * })
     * ```
     *
     * @returns Optionally a function that's called when the created entity is removed.
     */
    callback: (
    /** The entity that was just created. */
    entity: NexusEntityUnion<T extends "*" ? keyof EntityTypes : T>) => void | (() => void)): Terminable;
    /** @internal */
    _dispatchCreate(entity: NexusEntity): void;
    /**
     * Subscribe to updates of a mutable primitive field in the nexus document.
     *
     * @returns A terminable that when terminated will stop dispatching new onUpdate events.
     */
    onUpdate<P extends PrimitiveType>(
    /** primitive field whose updates are subscribed to */
    field: PrimitiveField<P, "mut">, 
    /**
     * The callback called right after the update.
     * */
    callback: (
    /** the new value the field receives, and will always match the current field value of the field listened on. */
    value: P) => void, 
    /** Whether the callback should be triggered immediately with the current value of the field */
    initialTrigger?: boolean): Terminable;
    /** @internal */
    _dispatchUpdate<P extends PrimitiveType>(location: NexusLocation, value: P): void;
    /**
     * Subscribe to an event where an entity is removed.
     *
     * @example
     * ```ts
     * const tm = await nexus.modify(t => t.create("tonematrix", {}))
     * nexus.events.onRemove(tm, (tm) => console.debug("tonematrix", tm.id, "removed"))
     * ```
     *
     *
     * @returns A terminable that when terminated will stop dispatching new onRemove events.
     */
    onRemove<F extends keyof EntityTypes>(
    /** The entity whose removal triggers the callback, or `*` to subscribe to the removal of all entities. */
    entity: NexusEntity<F> | "*", 
    /**
     * The callback called right after the entity is removed.
     */
    callback: (
    /** The entity that was just removed. */
    entity: NexusEntityUnion<F>) => void): Terminable;
    /** @internal */
    _dispatchRemove(entity: NexusEntity): void;
    /** Subscribe to the event that some pointer in the document starts pointing to a given location.
     *
     * @example
     * ```ts
     * const tm = await nexus.modify(t => t.create("tonematrix", {}))
     * nexus.events.onPointingTo(tm.fields.audioOutput, (from) =>
     *  console.debug(
     *    "pointing from field",
     *    from.toString(),
     *    "which is entity",
     *    nexus.queryEntities.getEntity(from.entityId)?.id
     * ))
     * ```
     *
     * If the pointer is the result of an entity being created, then `onCreate` is called before this callback.
     *
     * @returns A terminable that when terminated will stop dispatching new onPointingTo events.
     */
    onPointingTo(
    /** The location that is being pointed to */
    to: NexusLocation, 
    /** Called right after `from` starts pointing to `to`. */
    callback: (
    /** The location that points to `to`. `from` is always the location of a pointer field.*/
    from: NexusLocation) => void, 
    /**
     * Whether the callback should be executed immediately with all pointers pointing to `to`.
     */
    initialTrigger?: boolean): Terminable;
    /** @internal */
    _dispatchPointingTo(to: NexusLocation, from: NexusLocation): void;
    /** Subscribe to the event that some pointer in the document stops pointing to a given location.
     *
     * @example
     * ```ts
     * const tm = await nexus.modify(t => t.create("tonematrix", {}))
     * nexus.events.onStopPointingTo(tm.fields.audioOutput, (from) =>
     *  console.debug("pointing from field", from.toString(), "which is entity", nexus.queryEntities.getEntity(from.entityId)?.id
     * ))
     * ```
     *
     * If the pointer is the result of an entity being removed, then `onRemove` is called after this callback.
     *
     * @returns A terminable that when terminated will stop dispatching new onStopPointingTo events.
     */
    onStopPointingTo(
    /** The location that is being stopped pointing to. */
    to: NexusLocation, 
    /** Called right after `from` stops pointing to `to`. */
    callback: (
    /** The location that stops pointing to `to`. `from` is always the location of a pointer field. */
    from: NexusLocation) => void): Terminable;
    /** @internal */
    _dispatchStopPointingTo(to: NexusLocation, from: NexusLocation): void;
    /**
     * @internal
     * Some stats for debugging. Static for easy access. This method can get quite slow, 6.5ms measured
     * on large documents. Don't call too often. */
    getStats(): {
        numCreateListeners: number;
        numUpdateListeners: number;
        numRemoveListeners: number;
        numPointingToListeners: number;
        numStopPointingToListeners: number;
    };
}
