import { Modification } from '../../gen/audiotool/document/v1/document_service_pb';
import { EntityConstructorType, EntityTypeKey } from '../entity-utils';
import { NexusEntity } from '../entity';

type _EntityWithOverwrites<T extends EntityTypeKey> = {
    entity: NexusEntity<T>;
    overwrites?: EntityConstructorType<T>;
};
/**
 * Expands to
 *
 * ```ts
 * type _EntityWithArg<T> = {
 *  entity: NexusEntity<T>
 *  overwrites?: ConstructorTypes[T]
 * }
 * ```
 *
 * except for when except when `T`
 * is one of multiple options:
 *
 * If `T` is `"output" | "tonematrix"`, this type expands to
 * ```
 * _EntityWithArg<"output"> | _EntityWithArg<"tonematrix">
 * ```
 *
 * rather than
 * ```
 * _EntityWithArg<"output" | "tonematrix">
 * ```
 *
 * which causes typescript to make sure that the `entity` field matches
 * the type of the `overwrites` field, and doesn't just take the type
 * union for either of these fields.
 *
 */
export type EntityWithOverwrites<T extends EntityTypeKey = EntityTypeKey> = {
    [K in T]: _EntityWithOverwrites<K>;
}[T];
/**
 * /**
 * @internal
 *  Builds a list of modifications that clone a list of given entities.
 *
 * The entities are cloned such that pointers from and to the entities in the passed
 * list are updated to point to the new entities.
 *
 * Pointers from or to entities outside the list are left as-is.
 *
 * Returns the list of modifications creating the new entities, and a map
 * that maps the old entity ids to the new entity ids.
 *
 */
export declare const buildModificationsForCloneLinkedEntities: (...entities: (EntityWithOverwrites | NexusEntity)[]) => {
    modifications: Modification[];
    uuidMap: Map<string, string>;
};
export {};
