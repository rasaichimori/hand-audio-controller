import { NexusEntityUnion, NexusEntity } from '../entity';
import { EntityConstructorType, EntityTypeKey } from '../entity-utils';
import { Modification } from '../../gen/audiotool/document/v1/document_service_pb';
import { Preset } from '../../gen/audiotool/document/v1/preset/v1/preset_pb';
import { NexusPreset } from 'src/audiotool-client/api-utils/presets';
import { DeepPartial } from 'utility-types';
import { PrimitiveField, PrimitiveType } from '../fields';
import { EntityQuery } from '../query/entity';
import { EntityWithOverwrites } from './build-clone-linked-entities';
import { DevicePresetEntityType } from './prepare-preset';

/** A transaction builder can be used to modify the document. */
export type TransactionBuilder = {
    /** Create a new entity with default values */
    create<T extends EntityTypeKey>(name: T, args: EntityConstructorType<T>): NexusEntityUnion<T>;
    /** Update a primitive field value */
    update<P extends PrimitiveType>(field: PrimitiveField<P, "mut">, value: P): void;
    /** Try to update a primitive field. Don't throw if it fails; return a string explaining the error
     * instead. If this returns `undefined`, the update was applied. Useful when e.g. a user enters a value
     * and it's not possible to know if the value is valid or not.
     */
    tryUpdate<P extends PrimitiveType>(field: PrimitiveField<P, "mut">, value: P): string | undefined;
    /** Delete an entity with id `id` from the document  */
    remove(idOrEntity: string | NexusEntity): void;
    /** Delete an entity with `id`, after all entities with pointers to it, transitively,
     * are deleted. In other words, remove entity `id`, after all entities are deleted
     * that would result in dangling pointers if `id` was removed.
     *
     * # Example
     * Let's say we have entities `a`, `b`, `c`, `d`, `e`, with pointers between each
     * other like this:
     *
     * ```text
     *   a ─► b ─┐
     *   │       ├──► d ─► e
     *   │       │
     *   └──► c ─┘
     * ```
     *
     * Then calling `removeWithDependencies(d.id)` will remove all entities except `e`,
     * in an order that keeps all existing pointers valid after every modification.
     */
    removeWithDependencies(idOrEntity: string | NexusEntity): void;
    /** Clone an existing entity, optionally overwriting some fields.
     *
     * Note that ts by default doesn't correctly type the output. To get correctly
     * typed output, do:
     * ```
     * const tonematrix = t.create("tonematrix", {})
     * const tonematrix2 = t.clone<"tonematrix">(tonematrix)
     * ```
     */
    clone<T extends EntityTypeKey>(entity: NexusEntity<T>, args?: DeepPartial<EntityConstructorType<T>>): NexusEntityUnion<T>;
    /** Clone a list of entities, in such a way that pointers that
     * are both from to entities in this list are updated to point to
     * the cloned versions. The resulting `creates` command are ordered in such a way
     * that all pointers are always valid, and no transaction errors occur.
     *
     * Each element in the past list can either be an entity itself, or an object
     * ```
     * {
     *  entity: NexusEntity<T>,
     *  overwrites?: ConstructorTypes[T]
     * }
     * ```
     * where `overwrites` work the same as the second parameter of `t.clone()` or `t.create()`.
     *
     * Pointers from and to entities not in the list remain unchanged, unless overwritten.
     *
     * Returns the cloned version of the entities in order. Robust towards duplicates
     * in the passed entities list.
     *
     * # Example
     *
     * Let's say we have entities `a`, `b`, `c`, `d`, `e`, with pointers between each
     * other like this:
     *
     * ```text
     *
     *  a ──► b ──► c ──► d
     *              ▲
     *              │
     *              e
     * ```
     *
     * And we call `cloneLinked(b, c)`. Then:
     * * the relationship between `b` and `c` is updated to duplicates
     * * relationships from `b` or `c` to other entities remain untouched
     * * relationships from other entities to `b` or `c` remain untouched
     *
     * Leading to a graph like this:
     *
     * ```text
     *
     *        b'──► c' ───┐
     *                    ▼
     *  a ──► b ──► c ──► d
     *              ▲
     *              │
     *              e
     * ```
     *
     *
     * If overwrite arguments are given for a specific entity, they overwrite any value
     * _after_ the links have been adjusted.
     *
     */
    cloneLinked(...entities: (EntityWithOverwrites | NexusEntity)[]): NexusEntity[];
    /** Apply a preset to a given entity. The preset is a special transaction. */
    applyPresetTo(entity: NexusEntity<DevicePresetEntityType>, preset: NexusPreset): void;
    /** Create a preset of a given entity. This doesn't modify the nexus document.  */
    createPresetFor(entity: NexusEntity<DevicePresetEntityType>): Preset;
    /**
     * Release the transaction lock and send the modifications to the backend. After this method
     * is called, this `TransactionBuilder` can't be used anymore.
     */
    send(): void;
    /** Allows querying all entities of the document.  */
    entities: EntityQuery;
    /**
     * @internal
     * Add a generic modification message to this transaction. This is for internal use. */
    _addModification(modification: Modification): void;
};
/**
 * SafeTransactionBuilder type is used in places where we want to indicate that
 * 'send()' method of TransactionBuilder instance is already handled somewhere else
 * and shouldn't be called.
 */
export type SafeTransactionBuilder = Omit<TransactionBuilder, "send">;
/** Create a transaction builder. The transaction builder as an abstraction that allow easy
 * building of modifications. It's used in the `createTransaction` method of the `NexusDocument` class.
 */
export declare const transactionBuilder: (opts: {
    /** Query the current state of the document. For the nexus document to work as intended,
     * modifications applied using `applyModification` should immediately be reflected
     * in the query.
     */
    query: EntityQuery;
    /** Modifications created during this transaction. If `throwIfInvalid` is false, it should
     * return `string` in case an error occurs, otherwise it should throw an error or return undefined.
     *
     * The modifications must immediately be applied to `query`, otherwise the builder will throw.
     */
    applyModification: (mod: Modification, throwIfInvalid: boolean) => string | void;
    /** Called when `t.send()` is called, and the transaction becomes "invalid". */
    finish?: () => void;
}) => TransactionBuilder;
/** Thrown when a method of the builder is called after `send` has already been called. */
export declare class CallAfterSendError extends Error {
    constructor(methodName: string);
}
