import { EntityTypeKey } from '../entity-utils';
import { TargetType } from '../../gen/audiotool/document/v1/opt/opt_pb';
import { AsyncLock } from '../../utils/async-lock';
import { NexusDocumentState } from '../document-state/state';
import { NexusEntityUnion, NexusEntity } from '../entity';
import { NexusField } from '../fields';
import { NexusLocation } from '../location';
import { FieldQuery } from './field';

/**
 * @internal
 * Internal type alias of the type returned by `#getEntities()`, for brevity. */
type TypedEntityMap<T extends EntityTypeKey = EntityTypeKey> = ReadonlyMap<string, NexusEntityUnion<T>>;
/**
 *
 * Provides facilities to query the nexus document.
 *
 * Once the query is built, execute it by calling `get()`.
 *
 * There are two ways to get access to an entity query.
 * * by creating a transaction and accessing the field `{@link TransactionBuilder.entities}`
 * * by accessing the field `{@link NexusDocument.queryEntitiesWithoutLock}`
 *
 * Example usage:
 * ```
 * const nexus = new NexusDocument()
 * await nexus.modify(t => {
 *   // all entities of the nexus document
 *   const allEntities = t.entities.get()
 *
 *   // all connections pointing to a tb303
 *   const tb303Entity = ...
 *   const connections = t.entities
 *        .ofTypes("desktopAudioCable", "desktopNoteCable")
 *        .pointingToEntity(tbt303Entity.id)
 *        .get()
 * })
 *
 * // the returned values are typed; `connections` is of type
 * // NexusEntity<'desktopAudioCable' | 'desktopNoteCable'>[]
 * // so we can access shared fields of the entity:
 * const fromSocket = connections[0]?.fields.fromSocket
 * ```
 *
 * If the results of a query are used to create a transaction, the `entities` of the
 * `TransactionBuilder` should be used. Transactions are created asynchronously, so
 * the result of the query can become out of date once the transaction lock is acquired,
 * and transaction errors can occur.
 *
 * Entity queries can technically be "recycled", meaning that
 * you can type:
 * ```
 * const t = await nexus.createTransaction()
 * const query = t.entities.pointingTo.entities(bassline3)
 * const audioConnsToBassline3 = query.ofTypes("desktopAudioCable").get()
 * const noteConnsToBassline3 = query.ofTypes("desktopNoteCable").get()
 * t.send()
 * ```
 *
 * However, note that queries created this way will throw if they're used outside of a transaction.
 *
 * To query the document without awaiting the transaction lock, you can use
 * ```
 * nexus.queryEntitiesWithoutLock.ofTypes("desktopAudioCable").get()
 * ```
 *
 */
export declare class EntityQuery<T extends EntityTypeKey = EntityTypeKey> {
    #private;
    /** Don't construct this class, it is constructed by NexusDocument. */
    constructor(opts?: {
        documentState?: NexusDocumentState;
        filterEntities?: (entities: TypedEntityMap<EntityTypeKey>) => TypedEntityMap<T>;
        documentLock?: AsyncLock | undefined;
    });
    /** Returns all entities selected by this query, in undefined order.
     */
    get(): NexusEntityUnion<T>[];
    /** Returns the first entity returned by `get()`, if any.
     *
     *  Since the order of entities in `get()` is undefined, which of the selected
     * entity this method returns is also undefined. This method is intended to be used
     * if it's known that the query will return at most one entity.
     */
    getOne(): NexusEntityUnion<T> | undefined;
    /** Of all selected entities, return the one with id `id`, if it exists. */
    getEntity(uuid: string): NexusEntityUnion<T> | undefined;
    /**
     * Of all selected entities, return the one with id `id`. Throw if it doesn't
     * exist.
     */
    mustGetEntity(uuid: string): NexusEntityUnion<T>;
    /**
     * Get an entity as a specific type, if it exists and has the type matching one
     * of the provided types.
     */
    getEntityAs<E extends T>(uuid: string, ...types: E[]): NexusEntityUnion<E> | undefined;
    /**
     * Get an entity as a specific type, if it has the type matching one of the
     * provided types. Throw if it doesn't exist.
     */
    mustGetEntityAs<E extends T>(uuid: string, ...types: E[]): NexusEntityUnion<E>;
    /** Only keep entities whose id appears in `ids`. */
    withIds(...uuids: string[]): EntityQuery<T>;
    /** Return the `FieldQuery<NexusField>` that starts with all fields of all
     * currently selected entities.
     */
    fields(): FieldQuery<NexusField>;
    /** Only keep entities whose messages are marked with a target type appearing
     * in `targetTypes`. Target types of fields of entities are ignored.
     */
    ofTargetTypes(...targetTypes: (keyof typeof TargetType)[]): EntityQuery<T>;
    /** Check if a specific entity is contained in the current query. */
    has(uuidOrEntity: string | NexusEntity): boolean;
    /** Only keep entities whose type string appears in `types`. */
    ofTypes<Q extends EntityTypeKey[]>(...types: Q): EntityQuery<Q[number] & T>;
    /** Omit entities whose type string appears in `types`. */
    notOfTypes<Q extends EntityTypeKey[]>(...types: Q): EntityQuery<Exclude<T, Q[number]>>;
    /** Only keep entities that have some fields that point to:
     * * `entityOfType`: some field of entities of a set of types
     * * `locations`: specific locations
     * * `entities`: some field of specific entities
     *
     * Passing an empty list to any of these methods will result in an empty query result.
     *
     * Use e.g. like:
     * ```
     * nexus.entities.pointingTo.entitiesOfType("tb303").get()
     * ```
     */
    get pointingTo(): ReferenceQuery<T>;
    /** Only keep entities that are themselves, or have fields that are, pointed to by:
     * * `entityOfType`: some field of entities of a set of types
     * * `locations`: specific locations
     * * `entities`: some field of specific entities
     *
     * Passing an empty list to any of these methods will result in an empty query result.
     *
     * Use e.g. as:
     * ```
     * nexus.entities.pointedToBy.entitiesOfType("tb303").get()
     * ```
     */
    get pointedToBy(): ReferenceQuery<T>;
}
/** Internal type used for `pointingTo` and `pointedToBy`.
 *
 * Because we don't know which entities point to or are pointed to by which entities,
 * the return type doesn't change.
 *  */
export type ReferenceQuery<T extends EntityTypeKey> = {
    entityOfType<Q extends EntityTypeKey[]>(...types: Q): EntityQuery<T>;
    locations(...loc: NexusLocation[]): EntityQuery<T>;
    entities(...ids: string[]): EntityQuery<T>;
};
export {};
