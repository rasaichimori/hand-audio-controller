import { Any } from '@bufbuild/protobuf';
import { ConstructorTypes, EntityTypes, entityMessageTypes, entityUrlToTypeKey } from '../gen/audiotool/document/v1/utils/types';
import { DeepPartial } from 'utility-types';

/** The main EntityTypeKeys type that is a "shortcut" to describe an entity
 * type. For example:
 * ```ts
 * t.create("tonematrix" satisfies EntityTypeKeys, {})
 * ```
 */
export type EntityTypeKey = keyof EntityTypes;
/** The field type of entity.
 *
 * ```ts
 * const tm = t.create("tonematrix", {})
 *
 * tm.fields satisfies EntityType<"tonematrix">
 * ```
 */
export type EntityType<T extends EntityTypeKey = EntityTypeKey> = EntityTypes[T];
export type TypeKeyToType = EntityTypes;
/**
 * @internal
 * The constructor type of an entity. Example:
 * ```ts
 * t.create("tonematrix", {} satisfies EntityConstructorType<"tonematrix">)
 * ```
 */
export type EntityConstructorType<T extends EntityTypeKey = EntityTypeKey> = ConstructorTypes[T];
/** The type URL of an entity as it's in `proto.Any`. Example:
 *
 * ```
 * const any = Any.pack(new Rasselbock({ ... }))
 * // note: this fails bcs any can contain anything, so type casting will be required
 * any.typeUrl satisfies EntityTypeUrl
 * ```
 */
export type EntityTypeUrl = keyof typeof entityUrlToTypeKey;
/** Maps type urls to their type keys. */
export type EntityTypeUrlToKey<T extends EntityTypeUrl = EntityTypeUrl> = (typeof entityUrlToTypeKey)[T];
/** Maps the type key to an instance of the proto message. */
export type EntityMessage<T extends EntityTypeKey = EntityTypeKey> = InstanceType<EntityMessageClass<T>>;
export type EntityMessageClass<T extends EntityTypeKey> = (typeof entityMessageTypes)[T];
export declare const entityTypeKeyToUrl: (entityTypeKey: EntityTypeKey) => EntityTypeUrl;
/** From a proto.Any message, extract the EntityTypeKey. Throws if the Any message doesn't contain
 * an entity. Takes undefined for convenience. Returns undefined if undefined is passed, or the Any
 * message doesn't contain an entity.
 */
export declare const anyEntityToTypeKey: (entity: Any | undefined) => EntityTypeKey | undefined;
export declare const entityMessageToTypeKey: (msg: EntityMessage) => EntityTypeKey;
/** Convert an entity message to an any message. */
export declare const packEntity: (message: EntityMessage) => Any;
/** Convert an any message to an entity message. */
export declare const unpackEntity: (entity: Any | undefined) => EntityMessage | undefined;
/** Like unpackEntity, but if the any message passed is undefined, or the unpacking fails, it throws an error. */
export declare const mustUnpackEntity: (entity: Any | undefined) => EntityMessage;
export declare const mustUnpackEntityAs: <T extends EntityTypeKey>(type: T, entity: Any | undefined) => EntityMessage<T>;
/** Syntax sugar to create & pack an entity easily. Instead of `Any.pack(new Foo({...}))`, just type `packedEntity("foo", {...})`.*/
export declare const packedEntity: <T extends EntityTypeKey>(type: T, params: DeepPartial<EntityMessage<T>>) => Any;
export declare const getEntityTypeKeyFromProtoName: (name: string) => EntityTypeKey;
