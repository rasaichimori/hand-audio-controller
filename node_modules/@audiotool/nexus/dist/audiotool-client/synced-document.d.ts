import { NexusEventManager } from '../document/event-manager';
import { EntityQuery } from '../document/index';
import { SafeTransactionBuilder, TransactionBuilder } from '../document/transaction-builder';
import { ValueNotifier } from '../utils/observable-notifier-value';
import { AudiotoolAPI } from './api';

/**
 * An Audiotool project document that synchronizes in real-time with the backend.
 *
 * This is the main interface for interacting with Audiotool projects. It provides
 * methods for creating transactions, querying entities, and reacting to changes.
 *
 * @example
 * ```typescript
 * // Setup client and document
 * const client = await createAudiotoolClient();
 *
 * const document = await client.createSyncedDocument({
 *   mode: "online",
 *   project: "https://beta.audiotool.com/studio?project=abc123"
 * });
 *
 * // Listen for entity creation
 * document.events.onCreate("tonematrix", (tm) => {
 *   console.log("New tonematrix created");
 * });
 *
 * // Start syncing
 * await document.start();
 *
 * // Create entities in a transaction
 * const delay = await document.modify((t) => {
 *   return t.create("stompboxDelay", {
 *     delayTime: 0.5,
 *     feedback: 0.3
 *   });
 * });
 * ```
 *
 * @see {@link createAudiotoolClient} for creating client instances
 */
export type SyncedDocument = {
    /**
     * Start the synchronization process with the backend.
     *
     * Before this method is called:
     * * the document isn't in sync yet
     * * the document cannot be modified yet
     *
     * Which gives you time to setup all `onCreate` event listeners.
     *
     * While the returned promise resolves, the local state is synced up with the remote state,
     * and all entities currently in the document trigger `onCreate` callbacks. After the method resolves,
     * the document is in sync, and can be modified.
     *
     * @example
     * ```typescript
     * // Set up all event handlers first
     * nexus.events.onCreate("tonematrix", tm => {
     *   nexus.events.onUpdate(tm.fields.isActive, (a) => console.debug("tonematrix is" a ? "active" : "inactive"));
     * });
     *
     * // Then start syncing
     * await nexus.start();
     * ```
     *
     * @throws {Error} When connection to backend fails or authentication is invalid
     */
    start: () => Promise<void>;
    /** Acquire the transaction lock and receive a transaction builder to modify the document.
     *
     * While a transaction builder exists, no other can be created - subsequent calls will have to `await`.
     * Once the transaction is complete, call `.send()` on the builder to release the lock and let
     * the next transaction begin.
     *
     */
    createTransaction: () => Promise<TransactionBuilder>;
    /**
     * Execute a transaction with automatic cleanup.
     *
     * This is the most common way to modify the document. It handles transaction
     * creation, execution, and cleanup automatically.
     *
     * @example
     * ```typescript
     * // Create a tonematrix and place it on the desktop
     * const tonematrix = await nexus.modify((t) => {
     *   const tm = t.create("tonematrix", {});
     *   const placement = t.create("desktopPlacement", {
     *     entity: tm.location,
     *     x: 100,
     *     y: 200
     *   });
     *   return tm;
     * });
     *
     * // Update multiple fields in one transaction
     * await nexus.modify((t) => {
     *   t.update(delay.fields.delayTime, 0.75);
     *   t.update(delay.fields.feedback, 0.6);
     *   t.update(delay.fields.mixFactor, 0.4);
     * });
     * ```
     *
     * @param fn - Function that receives a transaction builder and performs modifications
     * @returns Promise resolving to the return value of the transaction function
     * @throws {Error} When transaction validation fails or connection is lost
     *
     * @see {@link createTransaction} for manual transaction management
     * @see {@link TransactionBuilder} for available transaction operations
     */
    modify<T>(fn: (m: SafeTransactionBuilder) => Promise<T> | T): Promise<T>;
    /** Query the current state of the document. Careful: Acquiring the transaction lock is an async process,
     * and has to be awaited; during that wait time, the document can change. It's thus recommended to use
     * {@link TransactionBuilder.entities} to query the document when building transactions, otherwise transaction errors can occur.
     */
    queryEntities: EntityQuery;
    /** Subscribe to changes in the document. */
    events: NexusEventManager;
    /** Whether the document is connected to the backend and should be modified. If this becomes
     * false, the user became offline or the backend server is down. Will usually recover on its own.
     *
     * While this is false, no syncing is happening, and all changes made since this became false will be lost on
     * reload; it's recommended to block the user from making changes until this becomes true again.
     */
    connected: ValueNotifier<boolean>;
};
/** Create an online document. */
export declare const createOnlineDocument: (api: AudiotoolAPI, projectName: string, getToken: () => Promise<string>) => Promise<SyncedDocument>;
export declare const createOfflineDocument: (validated: boolean) => Promise<SyncedDocument>;
