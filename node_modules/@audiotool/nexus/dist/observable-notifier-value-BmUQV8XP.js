var v = (r) => {
  throw TypeError(r);
};
var M = (r, e, t) => e.has(r) || v("Cannot " + t);
var s = (r, e, t) => (M(r, e, "read from private field"), t ? t.call(r) : e.get(r)), h = (r, e, t) => e.has(r) ? v("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), u = (r, e, t, i) => (M(r, e, "write to private field"), i ? i.call(r, t) : e.set(r, t), t);
const E = async (r, e) => {
  try {
    return await fetch(r, e);
  } catch (t) {
    return new Error("error during fetch", { cause: t });
  }
};
var l, m, f;
class T {
  /** if `warnAfterMs` is set, the lock will emit a warning if a call to `lock.aquire()
   * tok more than `warnAfterMs` milliseconds.
   */
  constructor(e) {
    h(this, l, !1);
    h(this, m, []);
    h(this, f);
    u(this, f, (e == null ? void 0 : e.warnAfterMs) ?? void 0);
  }
  /**
   * Wait until no other async thread holds a lock, then returns a lock.
   *
   * Once the lock is held, all other threads that call `acquire()` will have to wait until
   * the lock is released.
   *
   *
   * Release the lock with `lock.release()`.
   *
   * Example:
   * ```ts
   * const lock = new AsyncLock()
   * ...
   * const l = await lock.acquire()
   * // do stuff
   * l.release()
   * ```
   *
   */
  async acquire() {
    let e = () => {
    };
    s(this, f) !== void 0 && (e = k(
      s(this, f),
      `Waited for lock.aquire() for more than ${s(this, f)} ms, deadlock?`
    )), s(this, l) && await new Promise((i) => s(this, m).push(i)), e(), u(this, l, !0);
    let t = !1;
    return {
      release: () => {
        var i;
        if (t)
          throw new Error("Lock already released");
        t = !0, s(this, m).length > 0 ? (i = s(this, m).shift()) == null || i() : u(this, l, !1);
      }
    };
  }
  /**
   * Execute a function after acquiring a lock, and release the lock after the function is done.
   *
   * Example:
   * ```ts
   * const v = await lock.runAcquired(() => {
   *  // do something
   *  return 42
   * })
   * ```
   *
   * This function is **safe against exceptions**. If the function throws an exception, the lock
   * is released before the exception is thrown.
   *
   */
  async runAcquired(e) {
    const t = await this.acquire();
    let i;
    try {
      return i = await e(), t.release(), i;
    } catch (S) {
      throw t.release(), S;
    }
  }
  /** Weather the lock is currently taken. Because javascript is single-threaded, it is safe
   * to do e.g.:
   * ```ts
   * if (!lock.locked) {
   *   lock.acquire()
   *   // do something
   *   lock.release()
   * }
   *
   * ```
   *
   * without `await`ing the `lock.acquire()`.
   */
  get locked() {
    return s(this, l);
  }
}
l = new WeakMap(), m = new WeakMap(), f = new WeakMap();
const k = (r, e) => {
  const t = setTimeout(() => {
    console.warn(e), console.trace("Waited here:");
  }, r);
  return () => clearTimeout(t);
};
var d;
class A {
  constructor() {
    h(this, d, /* @__PURE__ */ new Set());
  }
  // A set allows us to remove while iterating
  subscribe(e) {
    return s(this, d).add(e), { terminate: () => s(this, d).delete(e) };
  }
  notify(e) {
    s(this, d).forEach((t) => t(e));
  }
  terminate() {
    s(this, d).clear();
  }
}
d = new WeakMap();
const w = Symbol();
var a;
class N {
  constructor() {
    /** Maps the hash of a key to both key and value */
    h(this, a, /* @__PURE__ */ new Map());
  }
  clear() {
    s(this, a).clear();
  }
  delete(e) {
    const t = e[w];
    return s(this, a).delete(t);
  }
  forEach(e, t) {
    s(this, a).forEach(([i, S]) => {
      e(S, i, this);
    }, t);
  }
  entries() {
    return s(this, a).entries().map(([e, [t, i]]) => [t, i]);
  }
  get(e) {
    var t;
    return (t = s(this, a).get(e[w])) == null ? void 0 : t[1];
  }
  has(e) {
    return s(this, a).has(e[w]);
  }
  keys() {
    return s(this, a).values().map(([e, t]) => e);
  }
  set(e, t) {
    const i = e[w];
    return s(this, a).set(i, [e, t]), this;
  }
  values() {
    return s(this, a).values().map(([e, t]) => t);
  }
  get size() {
    return s(this, a).size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "StringHashMap";
  }
}
a = new WeakMap();
var b, c, g;
class _ {
  constructor(e) {
    h(this, b, new A());
    h(this, c);
    h(this, g, V(s(this, b)));
    u(this, c, e);
  }
  getValue() {
    return s(this, g).call(this), s(this, c);
  }
  setValue(e) {
    s(this, c) !== e && (u(this, c, e), s(this, b).notify(e));
  }
  subscribe(e, t = !1) {
    return t && e(s(this, c)), s(this, b).subscribe(e);
  }
  terminate() {
    s(this, b).terminate();
  }
}
b = new WeakMap(), c = new WeakMap(), g = new WeakMap();
var o, y, n;
class p {
  constructor(e) {
    h(this, o, new A());
    h(this, y, V(s(this, o)));
    h(this, n);
    u(this, n, e ?? /* @__PURE__ */ new Map());
  }
  /** Subscribe to updates of the set */
  subscribe(e, t = !1) {
    return t && e(s(this, n)), s(this, o).subscribe(() => e(s(this, n)));
  }
  /** Get the underlying map. Readonly because changing it won't trigger updates. */
  getValue() {
    return s(this, y).call(this), s(this, n);
  }
  set(e, t) {
    return s(this, n).set(e, t), s(this, o).notify(), this;
  }
  delete(e) {
    const t = s(this, n).delete(e);
    return t && s(this, o).notify(), t;
  }
  clear() {
    const e = s(this, n).size > 0;
    s(this, n).clear(), e && s(this, o).notify();
  }
}
o = new WeakMap(), y = new WeakMap(), n = new WeakMap();
const V = (r) => () => {
};
export {
  T as A,
  N as H,
  p as M,
  A as N,
  _ as V,
  w as h,
  E as n
};
