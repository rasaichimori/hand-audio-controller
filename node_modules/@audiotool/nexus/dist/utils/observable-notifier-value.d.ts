import { Observable } from './observable-notifier';
import { Terminable } from './terminable';

/** A value who can be observed by attaching a callback that is called
 * whenever the value changes. Shouldn't be used for things that don't
 * have meaning outside of updates, look at `Observable` for that.
 */
export interface ObservableValue<T> extends Observable<T> {
    subscribe(callback: (v: T) => void, initialTrigger?: boolean): Terminable;
    getValue(): T;
}
/** A value to which observers can subscribe to, which will then
 * be notified whenever the value changes.
 * If relevant, the following pattern can be used to only expose the `subscribe` function:
 * ```
 * class Foo {
 *   #notifier: ValueNotifier<number> = new ValueNotifier(0)
 *    get notifier(): ObservableValue<number> {
 *        return this.#notifier
 *    }
 * }
 * ```
 *
 * or
 * ```
 * class Test {
 *    readonly #notifier: ValueNotifier<number> = new ValueNotifier(0)
 *    readonly observer = this.#notifier as ObservableValue<number>
 * }
 * ```
 */
export declare class ValueNotifier<T> implements ObservableValue<T> {
    #private;
    constructor(value: T);
    getValue(): T;
    setValue(value: T): void;
    subscribe(callback: (v: T) => void, initialTrigger?: boolean): Terminable;
    terminate(): void;
}
/** Composes multiple observable values into one, preserving their types. */
export declare function composeObservableValues<T extends unknown[]>(...observables: {
    [K in keyof T]: ObservableValue<T[K]>;
}): ObservableValue<T>;
/** Can be used as an ObservableValue<ReadonlySet<T>>, but unlike `new ValueNotifier<Set<T>>`,
 *  actually triggers the callback when the value is changed, and also has easier syntax.
 */
export declare class SetValueNotifier<T> implements ObservableValue<ReadonlySet<T>> {
    #private;
    constructor(init?: Set<T>);
    /** Get the underlying set. Readonly because changing it won't trigger updates. */
    getValue(): ReadonlySet<T>;
    /** Add a value to the set */
    add(value: T): void;
    /** Delete a value from the set */
    delete(value: T): boolean;
    /** Subscribe to updates of the set */
    subscribe(callback: (v: ReadonlySet<T>) => void, initialTrigger?: boolean): Terminable;
    clear(): void;
    terminate(): void;
}
/** Implements `ObservableValue<ReadonlyMap<K, V>>`, which is notified
 * whenever set(), delete() or clear() is called.
 */
export declare class MapValueNotifier<K, V> implements ObservableValue<ReadonlyMap<K, V>> {
    #private;
    constructor(init?: Map<K, V>);
    /** Subscribe to updates of the set */
    subscribe(callback: (v: ReadonlyMap<K, V>) => void, initialTrigger?: boolean): Terminable;
    /** Get the underlying map. Readonly because changing it won't trigger updates. */
    getValue(): ReadonlyMap<K, V>;
    set(key: K, value: V): this;
    delete(key: K): boolean;
    clear(): void;
}
