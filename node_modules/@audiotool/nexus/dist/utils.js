var A = (e) => {
  throw TypeError(e);
};
var E = (e, t, r) => t.has(e) || A("Cannot " + r);
var a = (e, t, r) => (E(e, t, "read from private field"), r ? r.call(e) : t.get(e)), y = (e, t, r) => t.has(e) ? A("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
import { N as R, n as U } from "./observable-notifier-value-BmUQV8XP.js";
import { A as B, H as G, M as J, V as W } from "./observable-notifier-value-BmUQV8XP.js";
import { t as Q } from "./lang-KJQpoj7q.js";
var l, n;
class H {
  constructor(t) {
    y(this, l, new R());
    y(this, n, /* @__PURE__ */ new Set());
    t.forEach((r) => a(this, n).add(r));
  }
  getValue() {
    return Array.from(a(this, n));
  }
  replace(t) {
    a(this, n).clear(), t.forEach((r) => a(this, n).add(r)), a(this, l).notify(this.getValue());
  }
  add(t) {
    a(this, n).has(t) || (a(this, n).add(t), a(this, l).notify(this.getValue()));
  }
  delete(t) {
    a(this, n).has(t) && (a(this, n).delete(t), a(this, l).notify(this.getValue()));
  }
  has(t) {
    return a(this, n).has(t);
  }
  clear() {
    a(this, n).clear(), a(this, l).notify(this.getValue());
  }
  subscribe(t, r = !1) {
    return r && t(this.getValue()), a(this, l).subscribe(t);
  }
  terminate() {
    a(this, l).terminate();
  }
}
l = new WeakMap(), n = new WeakMap();
const F = (e, t) => Array.from({ length: e }, (r, o) => t(o)), C = "https://oauth.audiotool.com/oauth2/auth", N = "https://oauth.audiotool.com/oauth2/token", L = "https://rpc.audiotool.com", M = async ({
  clientId: e,
  redirectUrl: t,
  scope: r
}) => {
  const o = {
    accessToken: `oidc_${e}_oidc_access_token`,
    refreshToken: `oidc_${e}_oidc_refresh_token`,
    expiresAt: `oidc_${e}_oidc_expires_at`,
    codeVerifier: `oidc_${e}_oidc_code_verifier`,
    userName: `oidc_${e}_oidc_user_name`,
    state: `oidc_${e}_oidc_state`
  }, s = () => $(o, e, r, t), i = new URLSearchParams(window.location.search), d = i.get("error"), g = i.get("error_description");
  if (d != null)
    return I(), v(o), {
      loggedIn: !1,
      error: T(d, g),
      login: s
    };
  const _ = i.get("code");
  if (_ != null) {
    const h = i.get("state"), c = localStorage.getItem(o.state);
    if (h == null || c == null || h !== c)
      return {
        loggedIn: !1,
        error: T(
          "Invalid state URL parameter.",
          "Clean the URL of stale query parameters and try again."
        ),
        login: s
      };
    const m = localStorage.getItem(o.codeVerifier);
    if (m == null)
      return {
        loggedIn: !1,
        error: T("Code verifier not found. Restart the auth flow."),
        login: s
      };
    const p = await fetch(N, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        client_id: e,
        grant_type: "authorization_code",
        code: _,
        redirect_uri: t,
        code_verifier: m,
        token_endpoint_auth_method: "none"
      })
    }), {
      access_token: S,
      refresh_token: f,
      expires_in: w,
      error: V,
      error_description: x
    } = await p.json();
    if (V)
      return {
        loggedIn: !1,
        error: T(V, x),
        login: s
      };
    localStorage.setItem(o.accessToken, S), localStorage.setItem(o.refreshToken, f), localStorage.setItem(
      o.expiresAt,
      (Date.now() + w * 1e3).toString()
    ), I(), localStorage.removeItem(o.codeVerifier);
  }
  localStorage.removeItem(o.state);
  const k = await P(o, e);
  let u;
  if (typeof k == "string") {
    const h = async () => {
      if (u == null) {
        u = (async () => await P(o, e) ?? new Error("User not logged in."))();
        const m = await u;
        return u = void 0, m;
      }
      return await u;
    };
    let c;
    return {
      loggedIn: !0,
      getToken: h,
      getUserName: async () => {
        if (c !== void 0)
          return await c;
        const { promise: m, resolve: p } = Promise.withResolvers();
        c = m;
        const S = await h();
        if (S instanceof Error)
          return p(S), await c;
        const f = await U(
          `${L}/audiotool.auth.v1.AuthService/GetWhoami`,
          {
            method: "POST",
            headers: {
              Authorization: `Bearer ${S}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({})
          }
        );
        if (f instanceof Error)
          return p(f), await c;
        if (!f.ok)
          return p(new Error(`Failed to get user info: ${f.statusText}`)), await c;
        const { whoami: w } = await f.json();
        return console.debug("whoami", w), p((w == null ? void 0 : w.userName) ?? "Unknown User"), await c;
      },
      logout() {
        v(o), I(), window.location.reload();
      }
    };
  }
  return {
    loggedIn: !1,
    error: k,
    login: s
  };
}, v = (e) => {
  localStorage.removeItem(e.accessToken), localStorage.removeItem(e.refreshToken), localStorage.removeItem(e.expiresAt), localStorage.removeItem(e.codeVerifier), localStorage.removeItem(e.userName), localStorage.removeItem(e.state);
}, I = () => {
  const e = new URL(window.location.href);
  e.searchParams.delete("code"), e.searchParams.delete("scope"), e.searchParams.delete("state"), e.searchParams.delete("error"), e.searchParams.delete("error_description"), window.history.replaceState(
    {},
    document.title,
    e.search ? e.href : e.href.replace("?", "")
  );
}, $ = async (e, t, r, o) => {
  const s = O();
  localStorage.setItem(e.codeVerifier, s);
  const i = await b(s), d = crypto.getRandomValues(new Uint8Array(16)).join("");
  localStorage.setItem(e.state, d);
  const g = new URL(C);
  g.search = new URLSearchParams({
    response_type: "code",
    client_id: t,
    scope: r,
    code_challenge_method: "S256",
    code_challenge: i,
    redirect_uri: o,
    state: d
  }).toString(), window.location.href = g.toString();
}, T = (e, t) => (t = t ? `: ${t}` : "", new Error(`${e}${t}`)), O = () => {
  const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  return crypto.getRandomValues(new Uint8Array(64)).reduce(
    (r, o) => r + e[o % e.length],
    ""
  );
}, b = async (e) => {
  const t = new TextEncoder().encode(e), r = await crypto.subtle.digest("SHA-256", t);
  return btoa(String.fromCharCode(...new Uint8Array(r))).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}, P = async (e, t) => {
  const r = localStorage.getItem(e.accessToken);
  if (r == null)
    return;
  let o = !0;
  {
    const h = localStorage.getItem(e.expiresAt);
    o = h == null ? !0 : Date.now() >= parseInt(h) - 6e4;
  }
  if (!o)
    return r;
  const s = localStorage.getItem(e.refreshToken);
  if (s == null) {
    v(e);
    return;
  }
  const i = await U(N, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      client_id: t,
      grant_type: "refresh_token",
      refresh_token: s
    })
  });
  if (i instanceof Error)
    return new Error(`Error during refresh token request: ${i.name}`, {
      cause: i.message
    });
  const { error: d, error_description: g, access_token: _, refresh_token: k, expires_in: u } = await i.json();
  return d ? T(d, g) : (localStorage.setItem(e.accessToken, _), localStorage.setItem(e.refreshToken, k), localStorage.setItem(
    e.expiresAt,
    (Date.now() + u * 1e3).toString()
  ), _);
};
export {
  B as AsyncLock,
  G as HashMap,
  J as MapValueNotifier,
  R as Notifier,
  H as SetNotifier,
  W as ValueNotifier,
  F as createArrayTyped,
  M as getLoginStatus,
  U as neverThrowingFetch,
  Q as throw_
};
