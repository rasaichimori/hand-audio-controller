import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, FieldMask, Message, proto3 } from '@bufbuild/protobuf';
import { Sample } from './sample_pb.js';
import { SampleEvent } from './sample_event_pb.js';

/**
 * Request for SampleService.ListSamples.
 *
 * @generated from message audiotool.sample.v1.ListSamplesRequest
 */
export declare class ListSamplesRequest extends Message<ListSamplesRequest> {
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    pageSize: number;
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    pageToken: string;
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - sample.name
     * - sample.display_name
     * - sample.description
     * - sample.owner_name
     * - sample.num_favorites
     * - sample.num_usages
     * - sample.bpm
     * - sample.sample_type
     * - sample.play_duration
     * - sample.create_time
     * - sample.update_time
     * - sample.clearance
     * - sample.tags
     * - sample.favorited_by_user
     *
     * @generated from field: string filter = 4;
     */
    filter: string;
    /**
     * The order to sort the results by.
     *
     * Supported fields:
     * - sample.name
     * - sample.display_name
     * - sample.description
     * - sample.owner_name
     * - sample.num_favorites
     * - sample.num_usages
     * - sample.bpm
     * - sample.sample_type
     * - sample.play_duration
     * - sample.create_time
     * - sample.update_time
     * - sample.clearance
     * - sample.tags
     *
     * @generated from field: string order_by = 5;
     */
    orderBy: string;
    /**
     * An additional filter for matching text metadata
     *
     * Examples:
     * 'kepz & dub' : returns results matching both keywords
     * 'guitar & (jazz | funk)' : returns guitar samples tagged with either jazz or funk
     * '!bass & guitar & (jazz | funk)' : same as above but excludes samples matching "bass"
     *
     * @generated from field: string text_search = 6;
     */
    textSearch: string;
    constructor(data?: PartialMessage<ListSamplesRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.ListSamplesRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSamplesRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSamplesRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSamplesRequest;
    static equals(a: ListSamplesRequest | PlainMessage<ListSamplesRequest> | undefined, b: ListSamplesRequest | PlainMessage<ListSamplesRequest> | undefined): boolean;
}
/**
 * Response for SampleService.ListSamples.
 *
 * @generated from message audiotool.sample.v1.ListSamplesResponse
 */
export declare class ListSamplesResponse extends Message<ListSamplesResponse> {
    /**
     * The list of samples.
     *
     * @generated from field: repeated audiotool.sample.v1.Sample samples = 1;
     */
    samples: Sample[];
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    nextPageToken: string;
    constructor(data?: PartialMessage<ListSamplesResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.ListSamplesResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSamplesResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSamplesResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSamplesResponse;
    static equals(a: ListSamplesResponse | PlainMessage<ListSamplesResponse> | undefined, b: ListSamplesResponse | PlainMessage<ListSamplesResponse> | undefined): boolean;
}
/**
 * Request for SampleService.CreateSample.
 *
 * @generated from message audiotool.sample.v1.CreateSampleRequest
 */
export declare class CreateSampleRequest extends Message<CreateSampleRequest> {
    /**
     * The sample to create.
     *
     * A client can provide a sample ID ahead of time. If provided, the server will use this ID
     * instead of generating a new one.
     *
     * The sample ID must be unique and in the pattern of `samples/{uuid-v4}`.
     *
     * If the sample ID is already in use there are two possible outcomes:
     * - the CreateSample RPC will error out
     * - Later on Processing of the data will fail (UploadSampleFinished and the async processing)
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    sample?: Sample;
    constructor(data?: PartialMessage<CreateSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.CreateSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSampleRequest;
    static equals(a: CreateSampleRequest | PlainMessage<CreateSampleRequest> | undefined, b: CreateSampleRequest | PlainMessage<CreateSampleRequest> | undefined): boolean;
}
/**
 * Message containing the upload URL and values to be sent as FormData.
 *
 * @generated from message audiotool.sample.v1.SampleUploadEndpoint
 */
export declare class SampleUploadEndpoint extends Message<SampleUploadEndpoint> {
    /**
     * The URL to upload the sample to. This represents the Base URL to make a request to.
     * The request must be sent using a PUT request
     *
     * If the client is finished with the upload it must call the `UploadSampleFinished` RPC.
     *
     * @generated from field: string upload_url = 1;
     */
    uploadUrl: string;
    /**
     * Values is a key-value map of values to be sent with the request.
     *
     * @generated from field: map<string, string> headers = 2;
     */
    headers: {
        [key: string]: string;
    };
    constructor(data?: PartialMessage<SampleUploadEndpoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.SampleUploadEndpoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleUploadEndpoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleUploadEndpoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleUploadEndpoint;
    static equals(a: SampleUploadEndpoint | PlainMessage<SampleUploadEndpoint> | undefined, b: SampleUploadEndpoint | PlainMessage<SampleUploadEndpoint> | undefined): boolean;
}
/**
 * Response for SampleService.CreateSample.
 *
 * @generated from message audiotool.sample.v1.CreateSampleResponse
 */
export declare class CreateSampleResponse extends Message<CreateSampleResponse> {
    /**
     * The created sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    sample?: Sample;
    /**
     * The upload endpoint.
     *
     * The sample will not be visible in List requests until the upload is finished and processed.
     * The client must call the `UploadSampleFinished` RPC to signal the server that the upload is
     * finished.
     *
     * If the upload doesn't happen within a certain time frame the server will delete the sample and
     * the endpoint will be invalid.
     *
     * The accepted data formats are:
     * - mp3
     * - wav
     * - flac
     * - ogg
     *
     * @generated from field: audiotool.sample.v1.SampleUploadEndpoint upload_endpoint = 2;
     */
    uploadEndpoint?: SampleUploadEndpoint;
    constructor(data?: PartialMessage<CreateSampleResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.CreateSampleResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSampleResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSampleResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSampleResponse;
    static equals(a: CreateSampleResponse | PlainMessage<CreateSampleResponse> | undefined, b: CreateSampleResponse | PlainMessage<CreateSampleResponse> | undefined): boolean;
}
/**
 * Request for SampleService.UploadSampleFinished.
 *
 * @generated from message audiotool.sample.v1.UploadSampleFinishedRequest
 */
export declare class UploadSampleFinishedRequest extends Message<UploadSampleFinishedRequest> {
    /**
     * The name of the sample to be updated, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    name: string;
    constructor(data?: PartialMessage<UploadSampleFinishedRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.UploadSampleFinishedRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadSampleFinishedRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadSampleFinishedRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadSampleFinishedRequest;
    static equals(a: UploadSampleFinishedRequest | PlainMessage<UploadSampleFinishedRequest> | undefined, b: UploadSampleFinishedRequest | PlainMessage<UploadSampleFinishedRequest> | undefined): boolean;
}
/**
 * Response for SampleService.UploadSampleFinished.
 *
 * @generated from message audiotool.sample.v1.UploadSampleFinishedResponse
 */
export declare class UploadSampleFinishedResponse extends Message<UploadSampleFinishedResponse> {
    constructor(data?: PartialMessage<UploadSampleFinishedResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.UploadSampleFinishedResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadSampleFinishedResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadSampleFinishedResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadSampleFinishedResponse;
    static equals(a: UploadSampleFinishedResponse | PlainMessage<UploadSampleFinishedResponse> | undefined, b: UploadSampleFinishedResponse | PlainMessage<UploadSampleFinishedResponse> | undefined): boolean;
}
/**
 * Request for SampleService.GetSample.
 *
 * @generated from message audiotool.sample.v1.GetSampleRequest
 */
export declare class GetSampleRequest extends Message<GetSampleRequest> {
    /**
     * Required. The name of the sample to be retrieved, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    name: string;
    constructor(data?: PartialMessage<GetSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.GetSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSampleRequest;
    static equals(a: GetSampleRequest | PlainMessage<GetSampleRequest> | undefined, b: GetSampleRequest | PlainMessage<GetSampleRequest> | undefined): boolean;
}
/**
 * Response for SampleService.GetSample.
 *
 * @generated from message audiotool.sample.v1.GetSampleResponse
 */
export declare class GetSampleResponse extends Message<GetSampleResponse> {
    /**
     * The sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    sample?: Sample;
    constructor(data?: PartialMessage<GetSampleResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.GetSampleResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSampleResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSampleResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSampleResponse;
    static equals(a: GetSampleResponse | PlainMessage<GetSampleResponse> | undefined, b: GetSampleResponse | PlainMessage<GetSampleResponse> | undefined): boolean;
}
/**
 * Request for SampleService.UpdateSample.
 *
 * @generated from message audiotool.sample.v1.UpdateSampleRequest
 */
export declare class UpdateSampleRequest extends Message<UpdateSampleRequest> {
    /**
     * The sample
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    sample?: Sample;
    /**
     * The update mask
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    updateMask?: FieldMask;
    constructor(data?: PartialMessage<UpdateSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.UpdateSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSampleRequest;
    static equals(a: UpdateSampleRequest | PlainMessage<UpdateSampleRequest> | undefined, b: UpdateSampleRequest | PlainMessage<UpdateSampleRequest> | undefined): boolean;
}
/**
 * Response for SampleService.UpdateSample.
 *
 * @generated from message audiotool.sample.v1.UpdateSampleResponse
 */
export declare class UpdateSampleResponse extends Message<UpdateSampleResponse> {
    /**
     * The updated sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    sample?: Sample;
    constructor(data?: PartialMessage<UpdateSampleResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.UpdateSampleResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSampleResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSampleResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSampleResponse;
    static equals(a: UpdateSampleResponse | PlainMessage<UpdateSampleResponse> | undefined, b: UpdateSampleResponse | PlainMessage<UpdateSampleResponse> | undefined): boolean;
}
/**
 * Request for SampleService.DeleteSample.
 *
 * @generated from message audiotool.sample.v1.DeleteSampleRequest
 */
export declare class DeleteSampleRequest extends Message<DeleteSampleRequest> {
    /**
     * Required. The name of the sample to be deleted, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    name: string;
    constructor(data?: PartialMessage<DeleteSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.DeleteSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSampleRequest;
    static equals(a: DeleteSampleRequest | PlainMessage<DeleteSampleRequest> | undefined, b: DeleteSampleRequest | PlainMessage<DeleteSampleRequest> | undefined): boolean;
}
/**
 * Response for SampleService.DeleteSample.
 *
 * @generated from message audiotool.sample.v1.DeleteSampleResponse
 */
export declare class DeleteSampleResponse extends Message<DeleteSampleResponse> {
    constructor(data?: PartialMessage<DeleteSampleResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.DeleteSampleResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSampleResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSampleResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSampleResponse;
    static equals(a: DeleteSampleResponse | PlainMessage<DeleteSampleResponse> | undefined, b: DeleteSampleResponse | PlainMessage<DeleteSampleResponse> | undefined): boolean;
}
/**
 * Request for SampleService.Listen.
 *
 * @generated from message audiotool.sample.v1.ListenRequest
 */
export declare class ListenRequest extends Message<ListenRequest> {
    /**
     * The names of the sample to listen to, in the form `samples/{name}`.
     *
     * @generated from field: repeated string names = 1;
     */
    names: string[];
    constructor(data?: PartialMessage<ListenRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.ListenRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenRequest;
    static equals(a: ListenRequest | PlainMessage<ListenRequest> | undefined, b: ListenRequest | PlainMessage<ListenRequest> | undefined): boolean;
}
/**
 * Response for SampleService.Listen.
 *
 * @generated from message audiotool.sample.v1.ListenResponse
 */
export declare class ListenResponse extends Message<ListenResponse> {
    /**
     * The sample.
     *
     * @generated from field: audiotool.sample.v1.SampleEvent event = 1;
     */
    event?: SampleEvent;
    constructor(data?: PartialMessage<ListenResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.sample.v1.ListenResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenResponse;
    static equals(a: ListenResponse | PlainMessage<ListenResponse> | undefined, b: ListenResponse | PlainMessage<ListenResponse> | undefined): boolean;
}
