import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Any, Message, proto3 } from '@bufbuild/protobuf';
import { Pointer } from './pointer_pb.js';

/**
 * Request for [AttachMetadata][audiotool.document.v1.AttachMetadata].
 *
 * @generated from message audiotool.document.v1.AttachMetadataRequest
 */
export declare class AttachMetadataRequest extends Message<AttachMetadataRequest> {
    /**
     * The id of the document to attach to.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The client_id is used to identify the client.
     *
     * This is used to filter out messages so the client doesn't receive his own PutMetadata requests.
     *
     * @generated from field: string client_id = 2;
     */
    clientId: string;
    constructor(data?: PartialMessage<AttachMetadataRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.AttachMetadataRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachMetadataRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachMetadataRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachMetadataRequest;
    static equals(a: AttachMetadataRequest | PlainMessage<AttachMetadataRequest> | undefined, b: AttachMetadataRequest | PlainMessage<AttachMetadataRequest> | undefined): boolean;
}
/**
 * Response for [AttachMetadata][audiotool.document.v1.AttachMetadata].
 *
 * @generated from message audiotool.document.v1.AttachMetadataResponse
 */
export declare class AttachMetadataResponse extends Message<AttachMetadataResponse> {
    /**
     * Creator can be a user in the form of 'users/{id}' but is not guaranteed to be a user.
     *
     * @generated from field: string source_name = 1;
     */
    sourceName: string;
    /**
     * The client_id is used to identify the client. A user can have multiple clients as he could
     * have multiple devices or multiple tabs open.
     *
     * @generated from field: string client_id = 2;
     */
    clientId: string;
    /**
     * The coordinates of the client can be blank.
     *
     * @generated from field: audiotool.document.v1.ClientCoordinates client_coordinates = 3;
     */
    clientCoordinates?: ClientCoordinates;
    constructor(data?: PartialMessage<AttachMetadataResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.AttachMetadataResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachMetadataResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachMetadataResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachMetadataResponse;
    static equals(a: AttachMetadataResponse | PlainMessage<AttachMetadataResponse> | undefined, b: AttachMetadataResponse | PlainMessage<AttachMetadataResponse> | undefined): boolean;
}
/**
 * Request for [PutMetadata][audiotool.document.v1.PutMetadata].
 *
 * @generated from message audiotool.document.v1.PutMetadataRequest
 */
export declare class PutMetadataRequest extends Message<PutMetadataRequest> {
    /**
     * The project_name the metadata is for
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The client_id is used to identify the client.
     *
     * This field is required.
     *
     * @generated from field: string client_id = 2;
     */
    clientId: string;
    /**
     * The coordinates of the client can be blank.
     *
     * @generated from field: audiotool.document.v1.ClientCoordinates client_coordinates = 3;
     */
    clientCoordinates?: ClientCoordinates;
    constructor(data?: PartialMessage<PutMetadataRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.PutMetadataRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutMetadataRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutMetadataRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutMetadataRequest;
    static equals(a: PutMetadataRequest | PlainMessage<PutMetadataRequest> | undefined, b: PutMetadataRequest | PlainMessage<PutMetadataRequest> | undefined): boolean;
}
/**
 * Response for [PutMetadata][audiotool.document.v1.PutMetadata].
 *
 * @generated from message audiotool.document.v1.PutMetadataResponse
 */
export declare class PutMetadataResponse extends Message<PutMetadataResponse> {
    constructor(data?: PartialMessage<PutMetadataResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.PutMetadataResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutMetadataResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutMetadataResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutMetadataResponse;
    static equals(a: PutMetadataResponse | PlainMessage<PutMetadataResponse> | undefined, b: PutMetadataResponse | PlainMessage<PutMetadataResponse> | undefined): boolean;
}
/**
 * ClientCoordinates is used to store the coordinates of the client.
 *
 * @generated from message audiotool.document.v1.ClientCoordinates
 */
export declare class ClientCoordinates extends Message<ClientCoordinates> {
    /**
     * The x coordinate of the cursor.
     *
     * @generated from field: double x = 1;
     */
    x: number;
    /**
     * The y coordinate of the cursor.
     *
     * @generated from field: double y = 2;
     */
    y: number;
    /**
     * The context is a client specific information like:
     * - timeline
     * - mixer
     * - desktop
     * - ...
     *
     * The context may also be a descriptive information containing an element path like:
     *
     * - timeline.{id}.sth
     *
     * If the cursor left the window it also can be set to an empty string.
     *
     * @generated from field: string context = 3;
     */
    context: string;
    /**
     * The height of the context - optional.
     *
     * @generated from field: double context_height = 4;
     */
    contextHeight: number;
    /**
     * The width of the context - optional.
     *
     * @generated from field: double context_width = 5;
     */
    contextWidth: number;
    /**
     * The x display value of the context - optional.
     *
     * @generated from field: double context_x = 6;
     */
    contextX: number;
    /**
     * The y display value of the context - optional.
     *
     * @generated from field: double context_y = 7;
     */
    contextY: number;
    constructor(data?: PartialMessage<ClientCoordinates>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ClientCoordinates";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCoordinates;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCoordinates;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCoordinates;
    static equals(a: ClientCoordinates | PlainMessage<ClientCoordinates> | undefined, b: ClientCoordinates | PlainMessage<ClientCoordinates> | undefined): boolean;
}
/**
 * Request for [GetEntities][audiotool.document.v1.GetEntities].
 *
 * @generated from message audiotool.document.v1.GetEntitiesRequest
 */
export declare class GetEntitiesRequest extends Message<GetEntitiesRequest> {
    /**
     * The document id is used to identify the document.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The filter is used to filter the entities.
     *
     * @generated from field: string filter = 2;
     */
    filter: string;
    constructor(data?: PartialMessage<GetEntitiesRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetEntitiesRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEntitiesRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEntitiesRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEntitiesRequest;
    static equals(a: GetEntitiesRequest | PlainMessage<GetEntitiesRequest> | undefined, b: GetEntitiesRequest | PlainMessage<GetEntitiesRequest> | undefined): boolean;
}
/**
 * Response for [GetEntities][audiotool.document.v1.GetEntities].
 *
 * @generated from message audiotool.document.v1.GetEntitiesResponse
 */
export declare class GetEntitiesResponse extends Message<GetEntitiesResponse> {
    /**
     * A list of all entities in the document, topo-sorted so all pointers
     * are always valid.
     *
     * @generated from field: repeated google.protobuf.Any entities = 1;
     */
    entities: Any[];
    constructor(data?: PartialMessage<GetEntitiesResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetEntitiesResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEntitiesResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEntitiesResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEntitiesResponse;
    static equals(a: GetEntitiesResponse | PlainMessage<GetEntitiesResponse> | undefined, b: GetEntitiesResponse | PlainMessage<GetEntitiesResponse> | undefined): boolean;
}
/**
 * Request for [Attach][audiotool.document.v1.Attach].
 *
 * @generated from message audiotool.document.v1.AttachRequest
 */
export declare class AttachRequest extends Message<AttachRequest> {
    /**
     * The id of the document to attach to.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The commit_index which the client has last seen.
     *
     * If the commit_index is 0, the client has not seen any transactions yet and the client will
     * receive a NoopResponse message.
     *
     * If the commit_index is > 0, the client has seen transactions and the client will receive all
     * transactions (Modification, Create, Delete) starting from the commit_index. The DocumentService
     * will only hold a specific amount of transactions in memory, so if the commit_index is too far
     * in the past, the client will receive an error (grpc.CodeOutOfRange). A Client should then call
     * Attach with commit_index 0.
     *
     * If the client is up to date with the server the server will send a NoopResponse message.
     *
     * @generated from field: uint32 commit_index = 2;
     */
    commitIndex: number;
    constructor(data?: PartialMessage<AttachRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.AttachRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachRequest;
    static equals(a: AttachRequest | PlainMessage<AttachRequest> | undefined, b: AttachRequest | PlainMessage<AttachRequest> | undefined): boolean;
}
/**
 * Response for [Attach][audiotool.document.v1.Attach].
 *
 * @generated from message audiotool.document.v1.AttachResponse
 */
export declare class AttachResponse extends Message<AttachResponse> {
    /**
     * Possible responses; currently only transaction, but this might change.
     *
     * @generated from oneof audiotool.document.v1.AttachResponse.message
     */
    message: {
        /**
         * The document contains the current state of the document.
         *
         * @generated from field: audiotool.document.v1.Transaction transaction = 1;
         */
        value: Transaction;
        case: "transaction";
    } | {
        /**
         * NoopResponse is used when there is no transaction and the client is up to date.
         *
         * This message may also be used by the server to keep the connection alive.
         *
         * @generated from field: audiotool.document.v1.Noop noop = 2;
         */
        value: Noop;
        case: "noop";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<AttachResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.AttachResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AttachResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AttachResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AttachResponse;
    static equals(a: AttachResponse | PlainMessage<AttachResponse> | undefined, b: AttachResponse | PlainMessage<AttachResponse> | undefined): boolean;
}
/**
 * NoopResponse is used when there is no transaction and the client is up to date.
 *
 * @generated from message audiotool.document.v1.Noop
 */
export declare class Noop extends Message<Noop> {
    /**
     * The current commit_index of the server.
     *
     * @generated from field: uint32 server_commit_index = 1;
     */
    serverCommitIndex: number;
    constructor(data?: PartialMessage<Noop>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Noop";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Noop;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Noop;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Noop;
    static equals(a: Noop | PlainMessage<Noop> | undefined, b: Noop | PlainMessage<Noop> | undefined): boolean;
}
/**
 * Request for [Modify][audiotool.document.v1.Modify].
 *
 * @generated from message audiotool.document.v1.ModifyRequest
 */
export declare class ModifyRequest extends Message<ModifyRequest> {
    /**
     * Possible requests. The first one (and only the first one) should be the document id
     * to which subsequent transactions should be applied.
     *
     * @generated from oneof audiotool.document.v1.ModifyRequest.message
     */
    message: {
        /**
         * The document id on which to apply subsequent transactions.
         *
         * @generated from field: string project_name = 1;
         */
        value: string;
        case: "projectName";
    } | {
        /**
         * The transaction to apply to the document.
         *
         * @generated from field: audiotool.document.v1.Transaction transaction = 2;
         */
        value: Transaction;
        case: "transaction";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<ModifyRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ModifyRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModifyRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModifyRequest;
    static equals(a: ModifyRequest | PlainMessage<ModifyRequest> | undefined, b: ModifyRequest | PlainMessage<ModifyRequest> | undefined): boolean;
}
/**
 * Response for [Modify][audiotool.document.v1.Modify].
 *
 * @generated from message audiotool.document.v1.ModifyResponse
 */
export declare class ModifyResponse extends Message<ModifyResponse> {
    /**
     * If the transaction was applied to the document, this will be "". Otherwise contains a message
     * explaining why it couldn't be applied.
     *
     * @generated from field: string error = 1;
     */
    error: string;
    constructor(data?: PartialMessage<ModifyResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ModifyResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModifyResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModifyResponse;
    static equals(a: ModifyResponse | PlainMessage<ModifyResponse> | undefined, b: ModifyResponse | PlainMessage<ModifyResponse> | undefined): boolean;
}
/**
 * Request for [ApplyTransactions][audiotool.document.v1.ApplyTransactions].
 *
 * @generated from message audiotool.document.v1.ApplyTransactionsRequest
 */
export declare class ApplyTransactionsRequest extends Message<ApplyTransactionsRequest> {
    /**
     * The document id is used to identify the document.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The transactions to apply to the document, in order.
     *
     * @generated from field: repeated audiotool.document.v1.Transaction transactions = 2;
     */
    transactions: Transaction[];
    constructor(data?: PartialMessage<ApplyTransactionsRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ApplyTransactionsRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplyTransactionsRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplyTransactionsRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplyTransactionsRequest;
    static equals(a: ApplyTransactionsRequest | PlainMessage<ApplyTransactionsRequest> | undefined, b: ApplyTransactionsRequest | PlainMessage<ApplyTransactionsRequest> | undefined): boolean;
}
/**
 * Response for [ApplyTransactions][audiotool.document.v1.ApplyTransactions].
 *
 * @generated from message audiotool.document.v1.ApplyTransactionsResponse
 */
export declare class ApplyTransactionsResponse extends Message<ApplyTransactionsResponse> {
    /**
     * Maps transaction id to errors, if there are any.
     *
     * @generated from field: map<string, string> errors = 1;
     */
    errors: {
        [key: string]: string;
    };
    constructor(data?: PartialMessage<ApplyTransactionsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ApplyTransactionsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplyTransactionsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplyTransactionsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplyTransactionsResponse;
    static equals(a: ApplyTransactionsResponse | PlainMessage<ApplyTransactionsResponse> | undefined, b: ApplyTransactionsResponse | PlainMessage<ApplyTransactionsResponse> | undefined): boolean;
}
/**
 * A transaction is a list of modifications to the document.
 *
 * @generated from message audiotool.document.v1.Transaction
 */
export declare class Transaction extends Message<Transaction> {
    /**
     * The id of the transaction. When calling `Modify`, this id must be a valid uuid.
     * Can be empty in the initial AttachResponse message.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * An incremental number that is increased with each accepted transaction provided by the
     * document-service.
     *
     * @generated from field: uint32 commit_index = 2;
     */
    commitIndex: number;
    /**
     * A list of modifications to the document. The order of the modifications is important.
     *
     * @generated from field: repeated audiotool.document.v1.Modification modifications = 3;
     */
    modifications: Modification[];
    constructor(data?: PartialMessage<Transaction>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Transaction";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transaction;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transaction;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transaction;
    static equals(a: Transaction | PlainMessage<Transaction> | undefined, b: Transaction | PlainMessage<Transaction> | undefined): boolean;
}
/**
 * Modification of the document
 *
 * @generated from message audiotool.document.v1.Modification
 */
export declare class Modification extends Message<Modification> {
    /**
     * CUD message
     *
     * @generated from oneof audiotool.document.v1.Modification.modification
     */
    modification: {
        /**
         * Create a new entity.
         *
         * @generated from field: audiotool.document.v1.Create create = 2;
         */
        value: Create;
        case: "create";
    } | {
        /**
         * Delete an entity.
         *
         * @generated from field: audiotool.document.v1.Delete delete = 3;
         */
        value: Delete;
        case: "delete";
    } | {
        /**
         * Update an entity.
         *
         * @generated from field: audiotool.document.v1.Update update = 4;
         */
        value: Update;
        case: "update";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Modification>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Modification";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Modification;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Modification;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Modification;
    static equals(a: Modification | PlainMessage<Modification> | undefined, b: Modification | PlainMessage<Modification> | undefined): boolean;
}
/**
 * Create a new entity
 *
 * @generated from message audiotool.document.v1.Create
 */
export declare class Create extends Message<Create> {
    /**
     * The entity to create
     *
     * @generated from field: google.protobuf.Any entity = 1;
     */
    entity?: Any;
    constructor(data?: PartialMessage<Create>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Create";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Create;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Create;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Create;
    static equals(a: Create | PlainMessage<Create> | undefined, b: Create | PlainMessage<Create> | undefined): boolean;
}
/**
 * Update will update a field in an entity.
 * It is an optimized approach to update a single field, as this is the most common use case.
 * If we would send the whole entity, with all values kept empty it would be safe without type
 * comparsion, but it would be an overhead if we have nested structure with repeated fields, as
 * all values on lower indexes would be sent as nil value as well.
 *
 * @generated from message audiotool.document.v1.Update
 */
export declare class Update extends Message<Update> {
    /**
     * Pointer is used to reference the entity + field which shall be updated.
     *
     * @generated from field: audiotool.document.v1.Pointer field = 1;
     */
    field?: Pointer;
    /**
     * The poossible values for an update
     *
     * @generated from oneof audiotool.document.v1.Update.value
     */
    value: {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - double
         *
         * @generated from field: double double = 2;
         */
        value: number;
        case: "double";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - float
         *
         * @generated from field: float float = 3;
         */
        value: number;
        case: "float";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - int32
         *
         * @generated from field: int32 int32 = 4;
         */
        value: number;
        case: "int32";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - int64
         *
         * @generated from field: int64 int64 = 5;
         */
        value: bigint;
        case: "int64";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - uint32
         *
         * @generated from field: uint32 uint32 = 6;
         */
        value: number;
        case: "uint32";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - uint64
         *
         * @generated from field: uint64 uint64 = 7;
         */
        value: bigint;
        case: "uint64";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - sint32
         *
         * @generated from field: sint32 sint32 = 8;
         */
        value: number;
        case: "sint32";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - sint64
         *
         * @generated from field: sint64 sint64 = 9;
         */
        value: bigint;
        case: "sint64";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - fixed32
         *
         * @generated from field: fixed32 fixed32 = 10;
         */
        value: number;
        case: "fixed32";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - fixed64
         *
         * @generated from field: fixed64 fixed64 = 11;
         */
        value: bigint;
        case: "fixed64";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - sfixed32
         *
         * @generated from field: sfixed32 sfixed32 = 12;
         */
        value: number;
        case: "sfixed32";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - sfixed64
         *
         * @generated from field: sfixed64 sfixed64 = 13;
         */
        value: bigint;
        case: "sfixed64";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - bool
         *
         * @generated from field: bool bool = 14;
         */
        value: boolean;
        case: "bool";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - string
         *
         * @generated from field: string string = 15;
         */
        value: string;
        case: "string";
    } | {
        /**
         * https://developers.google.com/protocol-buffers/docs/proto3#scalar - bytes
         *
         * @generated from field: bytes bytes = 16;
         */
        value: Uint8Array;
        case: "bytes";
    } | {
        /**
         * Pointer value is used to reference another entity.
         *
         * @generated from field: audiotool.document.v1.Pointer pointer = 17;
         */
        value: Pointer;
        case: "pointer";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Update>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Update";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Update;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Update;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Update;
    static equals(a: Update | PlainMessage<Update> | undefined, b: Update | PlainMessage<Update> | undefined): boolean;
}
/**
 * Delete will remove an entity from the document.
 *
 * @generated from message audiotool.document.v1.Delete
 */
export declare class Delete extends Message<Delete> {
    /**
     * entity to remove
     *
     * @generated from field: string entity_id = 1;
     */
    entityId: string;
    constructor(data?: PartialMessage<Delete>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.Delete";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Delete;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Delete;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Delete;
    static equals(a: Delete | PlainMessage<Delete> | undefined, b: Delete | PlainMessage<Delete> | undefined): boolean;
}
/**
 * Request for [GetWasm][audiotool.document.v1.GetWasm].
 *
 * @generated from message audiotool.document.v1.GetWasmRequest
 */
export declare class GetWasmRequest extends Message<GetWasmRequest> {
    constructor(data?: PartialMessage<GetWasmRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetWasmRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWasmRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWasmRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWasmRequest;
    static equals(a: GetWasmRequest | PlainMessage<GetWasmRequest> | undefined, b: GetWasmRequest | PlainMessage<GetWasmRequest> | undefined): boolean;
}
/**
 * Response for [GetWasm][audiotool.document.v1.GetWasm].
 *
 * @generated from message audiotool.document.v1.GetWasmResponse
 */
export declare class GetWasmResponse extends Message<GetWasmResponse> {
    /**
     * data contains the wasm binary.
     *
     * @generated from field: bytes data = 1;
     */
    data: Uint8Array<ArrayBuffer>;
    constructor(data?: PartialMessage<GetWasmResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetWasmResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWasmResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWasmResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWasmResponse;
    static equals(a: GetWasmResponse | PlainMessage<GetWasmResponse> | undefined, b: GetWasmResponse | PlainMessage<GetWasmResponse> | undefined): boolean;
}
/**
 * Request for [GetWasmExec][audiotool.document.v1.GetWasmExec].
 *
 * @generated from message audiotool.document.v1.GetWasmExecRequest
 */
export declare class GetWasmExecRequest extends Message<GetWasmExecRequest> {
    constructor(data?: PartialMessage<GetWasmExecRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetWasmExecRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWasmExecRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWasmExecRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWasmExecRequest;
    static equals(a: GetWasmExecRequest | PlainMessage<GetWasmExecRequest> | undefined, b: GetWasmExecRequest | PlainMessage<GetWasmExecRequest> | undefined): boolean;
}
/**
 * Response for [GetWasmExec][audiotool.document.v1.GetWasmExec].
 *
 * @generated from message audiotool.document.v1.GetWasmExecResponse
 */
export declare class GetWasmExecResponse extends Message<GetWasmExecResponse> {
    /**
     * the js/go runtime script needed to execute the wasm binary on the client.
     *
     * @generated from field: string data = 1;
     */
    data: string;
    constructor(data?: PartialMessage<GetWasmExecResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetWasmExecResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWasmExecResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWasmExecResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWasmExecResponse;
    static equals(a: GetWasmExecResponse | PlainMessage<GetWasmExecResponse> | undefined, b: GetWasmExecResponse | PlainMessage<GetWasmExecResponse> | undefined): boolean;
}
/**
 * Request for [Ping][audiotool.document.v1.Ping].
 *
 * @generated from message audiotool.document.v1.PingRequest
 */
export declare class PingRequest extends Message<PingRequest> {
    /**
     * The document id is used to identify the document.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    /**
     * The client id is used to identify the client.
     *
     * @generated from field: string client_id = 2;
     */
    clientId: string;
    /**
     * The last ping duration in ms measured by the client.
     * if left empty, the server will not count the ping.
     *
     * @generated from field: uint32 last_ping_ms = 3;
     */
    lastPingMs: number;
    constructor(data?: PartialMessage<PingRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.PingRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest;
    static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean;
}
/**
 * Response for [Ping][audiotool.document.v1.Ping].
 *
 * @generated from message audiotool.document.v1.PingResponse
 */
export declare class PingResponse extends Message<PingResponse> {
    constructor(data?: PartialMessage<PingResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.PingResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse;
    static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean;
}
/**
 * Request for [GetClientStats][audiotool.document.v1.GetClientStats].
 *
 * @generated from message audiotool.document.v1.GetClientStatsRequest
 */
export declare class GetClientStatsRequest extends Message<GetClientStatsRequest> {
    /**
     * The document id is used to identify the document.
     *
     * @generated from field: string project_name = 1;
     */
    projectName: string;
    constructor(data?: PartialMessage<GetClientStatsRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetClientStatsRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClientStatsRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClientStatsRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClientStatsRequest;
    static equals(a: GetClientStatsRequest | PlainMessage<GetClientStatsRequest> | undefined, b: GetClientStatsRequest | PlainMessage<GetClientStatsRequest> | undefined): boolean;
}
/**
 * Response for [GetClientStats][audiotool.document.v1.GetClientStats].
 *
 * @generated from message audiotool.document.v1.GetClientStatsResponse
 */
export declare class GetClientStatsResponse extends Message<GetClientStatsResponse> {
    /**
     * A repeated list of information about clients paricipating in the document session.
     *
     * @generated from field: repeated audiotool.document.v1.ClientInfo client_info = 1;
     */
    clientInfo: ClientInfo[];
    constructor(data?: PartialMessage<GetClientStatsResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetClientStatsResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClientStatsResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClientStatsResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClientStatsResponse;
    static equals(a: GetClientStatsResponse | PlainMessage<GetClientStatsResponse> | undefined, b: GetClientStatsResponse | PlainMessage<GetClientStatsResponse> | undefined): boolean;
}
/**
 * ClientInfo contains information about a clients state.
 *
 * @generated from message audiotool.document.v1.ClientInfo
 */
export declare class ClientInfo extends Message<ClientInfo> {
    /**
     * the client's id
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * the client's ping
     *
     * @generated from field: uint32 ping_ms = 2;
     */
    pingMs: number;
    /**
     * set if client is offline
     *
     * @generated from field: bool offline = 3;
     */
    offline: boolean;
    /**
     * The source name of the client. This can be a user name in the form of 'users/{id}' but is not
     * guaranteed to be a user.
     *
     * @generated from field: string source_name = 4;
     */
    sourceName: string;
    constructor(data?: PartialMessage<ClientInfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.ClientInfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientInfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientInfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientInfo;
    static equals(a: ClientInfo | PlainMessage<ClientInfo> | undefined, b: ClientInfo | PlainMessage<ClientInfo> | undefined): boolean;
}
/**
 * Request for [GetVersion][audiotool.document.v1.GetVersion].
 *
 * @generated from message audiotool.document.v1.GetVersionRequest
 */
export declare class GetVersionRequest extends Message<GetVersionRequest> {
    constructor(data?: PartialMessage<GetVersionRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetVersionRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVersionRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVersionRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVersionRequest;
    static equals(a: GetVersionRequest | PlainMessage<GetVersionRequest> | undefined, b: GetVersionRequest | PlainMessage<GetVersionRequest> | undefined): boolean;
}
/**
 * Response for [GetVersion][audiotool.document.v1.GetVersion].
 *
 * @generated from message audiotool.document.v1.GetVersionResponse
 */
export declare class GetVersionResponse extends Message<GetVersionResponse> {
    /**
     * The version of the document service.
     *
     * @generated from field: string version = 1;
     */
    version: string;
    constructor(data?: PartialMessage<GetVersionResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetVersionResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVersionResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVersionResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVersionResponse;
    static equals(a: GetVersionResponse | PlainMessage<GetVersionResponse> | undefined, b: GetVersionResponse | PlainMessage<GetVersionResponse> | undefined): boolean;
}
/**
 * Request for [GetTime][audiotool.document.v1.GetTime].
 *
 * @generated from message audiotool.document.v1.GetTimeRequest
 */
export declare class GetTimeRequest extends Message<GetTimeRequest> {
    constructor(data?: PartialMessage<GetTimeRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetTimeRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTimeRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTimeRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTimeRequest;
    static equals(a: GetTimeRequest | PlainMessage<GetTimeRequest> | undefined, b: GetTimeRequest | PlainMessage<GetTimeRequest> | undefined): boolean;
}
/**
 * Response for [GetTime][audiotool.document.v1.GetTime].
 *
 * @generated from message audiotool.document.v1.GetTimeResponse
 */
export declare class GetTimeResponse extends Message<GetTimeResponse> {
    /**
     * The current time in seconds since the Unix epoch.
     *
     * @generated from field: int64 time = 1;
     */
    time: bigint;
    constructor(data?: PartialMessage<GetTimeResponse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.GetTimeResponse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTimeResponse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTimeResponse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTimeResponse;
    static equals(a: GetTimeResponse | PlainMessage<GetTimeResponse> | undefined, b: GetTimeResponse | PlainMessage<GetTimeResponse> | undefined): boolean;
}
