import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Pointer } from '../../../pointer_pb.js';
import { AdsrEnvelope } from '../../adsr_envelope/v1/adsr_envelope_pb.js';
import { Empty } from '../../../empty_pb.js';

/**
 * data structure for the Heisenberg FM synth
 *
 * @generated from message audiotool.document.v1.entity.heisenberg.v1.Heisenberg
 */
export declare class Heisenberg extends Message<Heisenberg> {
    /**
     * Uniquely identifies this stompbox delay.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Micro tuning.
     *
     * @generated from field: audiotool.document.v1.Pointer micro_tuning = 5;
     */
    microTuning?: Pointer;
    /**
     * Global tuning of the synth, moves all notes played by a given amount of semitones.
     *
     * @generated from field: float tune_semitones = 6;
     */
    tuneSemitones: number;
    /**
     * Gain of the synthesizer. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 7;
     */
    gain: number;
    /**
     * Selects the play mode of the synthesizer. The play mode determines how notes are played:
     * - 0: invalid
     * - 1: Mono
     * - 2: Legato
     * - 3: Polyphone
     *
     * Mono:
     * At most once note is played at once with slight overlap during release. An incoming note
     * cuts already playing notes.
     *
     * Legato:
     * Same as mono, but attack is omitted when a new incoming note cut off an already playing note.
     *
     * Polyphone:
     * Multiple notes/chords can be played simultaneously.
     *
     * @generated from field: uint32 play_mode_index = 8;
     */
    playModeIndex: number;
    /**
     * Glide time controls the duration that a note's pitch "glides" to the next note
     * once played. When in Mono or Legato mode, notes will glide if they overlap;
     * in Polyphone mode, notes will glide if they don't overlap.
     *
     * @generated from field: float glide_ms = 9;
     */
    glideMs: number;
    /**
     * Multiplier for the velocity of the notes, controlling their loudness. No unit.
     *
     * @generated from field: float velocity_factor = 10;
     */
    velocityFactor: number;
    /**
     * Setting this parameter to > 1 will create multiple voices per note.
     *
     * @generated from field: int32 unisono_count = 11;
     */
    unisonoCount: number;
    /**
     * If there's multiple voices per note (i.e. if unisono_count  > 1), increasing
     * this parameter will detune all voices from each other more by up to 1 semitone.
     * Increasing this parameter creates a "wider" sound.
     * If unisono_count is 1, this parameter has no effect.
     *
     * @generated from field: float unisono_detune_semitones = 12;
     */
    unisonoDetuneSemitones: number;
    /**
     * Spreads the voices across the stereo field. 0 is centered, 1 moves some voices
     * to the right, some to the left. -1 moves them in the opposite direction.
     *
     * @generated from field: float unisono_stereo_spread_factor = 13;
     */
    unisonoStereoSpreadFactor: number;
    /**
     * Selects the operator detune mode. This value affects which detune mode is shown in the DAW
     * for each operator's detune gauge. It doesn't have an effect on the produced audio.
     * - 0: invalid
     * - 1: Semitone  - show's semitone to detune an operator
     * - 2: Ratio     - show's the frequency ratio to detune an operator
     *
     * @generated from field: uint32 operator_detune_mode_index = 14;
     */
    operatorDetuneModeIndex: number;
    /**
     * Operator "A" of the Heisenberg.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator operator_a = 15;
     */
    operatorA?: HeisenbergOperator;
    /**
     * Operator "B" of the Heisenberg.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator operator_b = 16;
     */
    operatorB?: HeisenbergOperator;
    /**
     * Operator "C" of the Heisenberg.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator operator_c = 17;
     */
    operatorC?: HeisenbergOperator;
    /**
     * Operator "D" of the Heisenberg.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator operator_d = 18;
     */
    operatorD?: HeisenbergOperator;
    /**
     * The "main" envelope of the Heisenberg. Is always applied to the entire synth's gain, but can
     * also be assigned to individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.adsr_envelope.v1.AdsrEnvelope envelope_main = 19;
     */
    envelopeMain?: AdsrEnvelope;
    /**
     * The "env 1" envelope of the Heisenberg. Can be assigned to individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.adsr_envelope.v1.AdsrEnvelope envelope_2 = 20;
     */
    envelope2?: AdsrEnvelope;
    /**
     * The "env 2" envelope of the Heisenberg. Can be assigned to individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.adsr_envelope.v1.AdsrEnvelope envelope_3 = 21;
     */
    envelope3?: AdsrEnvelope;
    /**
     * The Heisenberg pitch envelope. Can be assigned to the individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergPitchEnvelope pitch_envelope = 22;
     */
    pitchEnvelope?: HeisenbergPitchEnvelope;
    /**
     * The first LFO of the Heisenberg. Can be assigned to the individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergLFO lfo_1 = 23;
     */
    lfo1?: HeisenbergLFO;
    /**
     * The second LFO of the Heisenberg. Can be assigned to the individual operators inside the operator message.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergLFO lfo_2 = 24;
     */
    lfo2?: HeisenbergLFO;
    /**
     * The Heisenberg filter configuration.
     *
     * @generated from field: audiotool.document.v1.entity.heisenberg.v1.HeisenbergFilter filter = 25;
     */
    filter?: HeisenbergFilter;
    /**
     * Notes Input.
     *
     * @generated from field: audiotool.document.v1.Empty notes_input = 26;
     */
    notesInput?: Empty;
    /**
     * Single Output.
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 27;
     */
    audioOutput?: Empty;
    /**
     * Whether the device is active or not. When is_active=false, the heisenberg is silent.
     *
     * @generated from field: bool is_active = 28;
     */
    isActive: boolean;
    constructor(data?: PartialMessage<Heisenberg>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.heisenberg.v1.Heisenberg";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Heisenberg;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Heisenberg;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Heisenberg;
    static equals(a: Heisenberg | PlainMessage<Heisenberg> | undefined, b: Heisenberg | PlainMessage<Heisenberg> | undefined): boolean;
}
/**
 * One of the 4 operators of the heisenberg. In the UI, they're also called
 * "A", "B", "C" and "D".
 *
 * @generated from message audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator
 */
export declare class HeisenbergOperator extends Message<HeisenbergOperator> {
    /**
     * The operator's gain. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 1;
     */
    gain: number;
    /**
     * Pans the signal to left/right. -1 is fully left, 0 is centered (unchanged), 1 is fully right.
     *
     * @generated from field: float panning = 2;
     */
    panning: number;
    /**
     * The detuning factor of this operator. Acts as a multiplier of the frequency the
     * operator is playing.
     *
     * The number of semitones this operator is detuned from is calculated as follows:
     * semitone = (12.0 * Math.log(detune_factor)) / Math.log(2.0)
     *
     * In the DAW, this is shown either as "semitone" or "ratio" depending on the operator_detune_mode_index
     * field of the heisenberg itself. The 'semitone" mode shows the number of semitones to detune,
     * down/up to 99.999 semitones. If detune_factor is above or below this semitone range,
     * looking at the ratio in semitone mode will show "--.-----"
     *
     * @generated from field: float detune_factor = 3;
     */
    detuneFactor: number;
    /**
     * Offset in Hz of the final frequency produced. Added to the operator frequency
     * after the detune factor has been applied.
     *
     * @generated from field: float frequency_offset_hz = 4;
     */
    frequencyOffsetHz: number;
    /**
     * Selects the waveform shape the operator produces.
     * - 0: invalid
     * - 1: Sinus
     * - 2: Parabola
     * - 3: Circle
     * - 4: Triangle
     * - 5: Sawtooth Up
     * - 6: Sawtooth Down
     * - 7: Square
     * - 8: Andrew Wiles
     * - 9: Ernest Rutherford
     * - 10: Wilhelm Conrad Röntgen
     * - 11: Peter Higgs
     * - 12: Gottfried Wilhelm Leibniz;
     * - 13: Alan Turing
     * - 14: Hans Geiger
     * - 15: Hermann von Helmholtz
     * - 16: Jean Baptiste Joseph Fourier
     * - 17: James Clerk Maxwell
     * - 18: Formant I
     * - 19: Formant II
     * - 20: Formant III
     * - 21: Formant IV
     * - 22: Blaise Pascal
     * - 23: Pierre de Fermat
     * - 24: Carl Friedrich Gauß
     * - 25: Isaac Newton
     * - 26: Marie Curie
     * - 27: Nikola Tesla
     * - 28: Alessandro Volta
     * - 29: Bernhard Riemann
     * - 30: André Weil
     * - 31: David Hilbert
     * - 32: Pierre-Simon Laplace
     * - 33: Andreas Christian Doppler
     * - 34: Paul Dirac
     * - 35: Max Planck
     * - 36: André-Marie Ampère
     * - 37: Max Born
     * - 38: Richard Feynman
     * - 39: Johannes Kepler
     * - 40: Heinrich Hertz
     * - 41: August Ferdinand Möbius
     * - 42: Robert Moog;
     * - 43: Albert Einstein
     * - 44: Erwin Schrödinger
     * - 45: Galileo Galilei
     * - 46: Michael Faraday
     * - 47: Leonhard Euler
     * - 48: Werner Heisenberg
     * - 49: Kurt Gödel
     *
     * @generated from field: uint32 waveform_index = 5;
     */
    waveformIndex: number;
    /**
     * Whether the pitch envelope influences the pitch of the operator. The pitch
     * envelope affects the pitch of the operator multiplicatively.
     *
     * @generated from field: bool use_pitch_envelope = 6;
     */
    usePitchEnvelope: boolean;
    /**
     * Setting this factor to > 0 offsets the phase of this operator by
     * the pre-modulation signal of operator "A" (the first operator of the 4)
     * multiplied by this factor.
     *
     * Note that for all operators, phase modulation is the last step,
     * after LFOs, envelopes, frequency offsets etc.
     *
     * @generated from field: float modulation_factor_a = 7;
     */
    modulationFactorA: number;
    /**
     * Setting this factor to > 0 offsets the phase of this operator by
     * the pre-modulation signal of operator "B" (the second operator of the 4)
     * multiplied by this factor.
     *
     * Note that for all operators, phase modulation is the last step,
     * after LFOs, envelopes, frequency offsets etc.
     *
     * @generated from field: float modulation_factor_b = 8;
     */
    modulationFactorB: number;
    /**
     * Setting this factor to > 0 offsets the phase of this operator by
     * the pre-modulation signal of operator "C" (the third operator of the 4)
     * multiplied by this factor.
     *
     * Note that for all operators, phase modulation is the last step,
     * after LFOs, envelopes, frequency offsets etc.
     *
     * @generated from field: float modulation_factor_c = 9;
     */
    modulationFactorC: number;
    /**
     * Setting this factor to > 0 offsets the phase of this operator by
     * the pre-modulation signal of operator "D" (the fourth operator of the 4)
     * multiplied by this factor.
     *
     * Note that for all operators, phase modulation is the last step,
     * after LFOs, envelopes, frequency offsets etc.
     *
     * @generated from field: float modulation_factor_d = 10;
     */
    modulationFactorD: number;
    /**
     * The extent to which a note's velocity influences this specific operator's
     * amplitude. 0.0 means no influence, 1.0 means full influence. 0.25 means
     * the operator's amplitude is between 0.75 and 1 depending on the note's velocity.
     *
     * Full formula:
     * factor = (1 - velocity_amplitude_modulation_depth) + note_velocity * velocity_amplitude_modulation_depth
     *
     * Note that a note's velocity still influences the signal's amplitude overall
     * after the operator's signals have been added together.
     *
     * @generated from field: float velocity_amplitude_modulation_depth = 11;
     */
    velocityAmplitudeModulationDepth: number;
    /**
     * The extent to which the main envelope influences this operator's amplitude.
     *
     * @generated from field: float envelope_main_amplitude_modulation_depth = 12;
     */
    envelopeMainAmplitudeModulationDepth: number;
    /**
     * The extent to which envelope 2 influences this operator's amplitude.
     *
     * @generated from field: float envelope_2_amplitude_modulation_depth = 13;
     */
    envelope2AmplitudeModulationDepth: number;
    /**
     * The extent to which envelope 3 influences this operator's amplitude.
     *
     * @generated from field: float envelope_3_amplitude_modulation_depth = 14;
     */
    envelope3AmplitudeModulationDepth: number;
    /**
     * The extent to which LFO 1 influences this operator's amplitude.
     *
     * @generated from field: float lfo_1_amplitude_modulation_depth = 15;
     */
    lfo1AmplitudeModulationDepth: number;
    /**
     * The extent to which LFO 2 influences this operator's amplitude.
     *
     * @generated from field: float lfo_2_amplitude_modulation_depth = 16;
     */
    lfo2AmplitudeModulationDepth: number;
    constructor(data?: PartialMessage<HeisenbergOperator>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.heisenberg.v1.HeisenbergOperator";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeisenbergOperator;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeisenbergOperator;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeisenbergOperator;
    static equals(a: HeisenbergOperator | PlainMessage<HeisenbergOperator> | undefined, b: HeisenbergOperator | PlainMessage<HeisenbergOperator> | undefined): boolean;
}
/**
 * The two LFO's for the Heisenberg that can be used to modulate the operators's
 * amplitude.
 *
 * @generated from message audiotool.document.v1.entity.heisenberg.v1.HeisenbergLFO
 */
export declare class HeisenbergLFO extends Message<HeisenbergLFO> {
    /**
     * Whether the LFO is synced to the project tempo. When synced, the
     * rate_normalized value below maps to "bar time" and as such depends on the project
     * tempo. When not synced, the rate_normalized value maps to "Hz" and as such is
     * independent of the project tempo.
     *
     * @generated from field: bool is_synced = 1;
     */
    isSynced: boolean;
    /**
     * If true, the LFO will restart its phase when a note is played.
     *
     * @generated from field: bool does_restart = 2;
     */
    doesRestart: boolean;
    /**
     * The rate of the LFO, expressed as a normalized value.
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the  value maps linearly to Hz (0.01 .. 500.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float rate_normalized = 3;
     */
    rateNormalized: number;
    /**
     * Phase offset factor of the LFO, in percentage of the entire phase.
     *
     * @generated from field: float offset_factor = 4;
     */
    offsetFactor: number;
    /**
     * The delay before the LFO enters the blend phase on every note trigger, expressed as a normalized value.
     * During the delay phase, the LFO is not active.
     *
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the value maps linearly to milliseconds (0 .. 5000.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      0, 1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float delay_time_normalized = 5;
     */
    delayTimeNormalized: number;
    /**
     * The duration of the blend phase of the LFO during which the LFO transitions from
     * no offset to full offset, expressed as a normalized value.
     *
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the value maps linearly to milliseconds (0 .. 5000.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      0, 1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float blend_time_normalized = 6;
     */
    blendTimeNormalized: number;
    /**
     * Selects the waveform of the LFO:
     * - 0: invalid
     * - 1: Sinus
     * - 2: Parabola
     * - 3: Circle
     * - 4: Triangle
     * - 5: Sawtooth Up
     * - 6: Sawtooth Down
     * - 7: Square
     * - 8: Andrew Wiles
     * - 9: Ernest Rutherford
     * - 10: Wilhelm Conrad Röntgen
     * - 11: Peter Higgs
     * - 12: Gottfried Wilhelm Leibniz;
     * - 13: Alan Turing
     * - 14: Hans Geiger
     * - 15: Hermann von Helmholtz
     * - 16: Jean Baptiste Joseph Fourier
     * - 17: James Clerk Maxwell
     * - 18: Formant I
     * - 19: Formant II
     * - 20: Formant III
     * - 21: Formant IV
     * - 22: Blaise Pascal
     * - 23: Pierre de Fermat
     * - 24: Carl Friedrich Gauß
     * - 25: Isaac Newton
     * - 26: Marie Curie
     * - 27: Nikola Tesla
     * - 28: Alessandro Volta
     * - 29: Bernhard Riemann
     * - 30: André Weil
     * - 31: David Hilbert
     * - 32: Pierre-Simon Laplace
     * - 33: Andreas Christian Doppler
     * - 34: Paul Dirac
     * - 35: Max Planck
     * - 36: André-Marie Ampère
     * - 37: Max Born
     * - 38: Richard Feynman
     * - 39: Johannes Kepler
     * - 40: Heinrich Hertz
     * - 41: August Ferdinand Möbius
     * - 42: Robert Moog;
     * - 43: Albert Einstein
     * - 44: Erwin Schrödinger
     * - 45: Galileo Galilei
     * - 46: Michael Faraday
     * - 47: Leonhard Euler
     * - 48: Werner Heisenberg
     * - 49: Kurt Gödel
     *
     * @generated from field: uint32 waveform_index = 7;
     */
    waveformIndex: number;
    constructor(data?: PartialMessage<HeisenbergLFO>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.heisenberg.v1.HeisenbergLFO";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeisenbergLFO;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeisenbergLFO;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeisenbergLFO;
    static equals(a: HeisenbergLFO | PlainMessage<HeisenbergLFO> | undefined, b: HeisenbergLFO | PlainMessage<HeisenbergLFO> | undefined): boolean;
}
/**
 * The Heisenberg pitch envelope is a ADSR envelope that controls the pitch detune of the notes played.
 * The enveloped can be toggled on or off on each operator using the use_pitch_envelope flag.
 * If active, the pitch envelope detunes each incoming note's pitch by a certain factor.
 *
 * @generated from message audiotool.document.v1.entity.heisenberg.v1.HeisenbergPitchEnvelope
 */
export declare class HeisenbergPitchEnvelope extends Message<HeisenbergPitchEnvelope> {
    /**
     * Wether the pitch envelope is in time sync or not. This affects the meaning of the time values below.
     *
     * @generated from field: bool is_synced = 1;
     */
    isSynced: boolean;
    /**
     * If enabled, the decay phase of the envelope will loop. Looping means playing
     * the decay phase "back and forth".
     * - 0: invalid
     * - 1: Off
     * - 2: Gate       loops the decay phase until the note is released; then it loops until
     *               the end of the currently playing decay phase, then enters the release phase and stops.
     * - 3: Infinity   the decay phase will loop forever.
     *
     * @generated from field: uint32 loop_decay_index = 2;
     */
    loopDecayIndex: number;
    /**
     * The value of the attack phase of the envelope. The amount detuned is this factor multiplied
     * by the semitone value below.
     *
     * @generated from field: float attack_range_factor = 3;
     */
    attackRangeFactor: number;
    /**
     * The attack time of the pitch envelope, expressed as a normalized value.
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the value maps linearly to milliseconds (1.0 .. 10_000.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float attack_time_normalized = 4;
     */
    attackTimeNormalized: number;
    /**
     * Controls how much the attack phase is bent. 0 is linear, more or less means more or less sloping.
     *
     * @generated from field: float attack_slope_factor = 5;
     */
    attackSlopeFactor: number;
    /**
     * The value of the decay phase of the envelope. The amount detuned is this factor multiplied
     * by the semitone value below.
     *
     * @generated from field: float decay_range_factor = 6;
     */
    decayRangeFactor: number;
    /**
     * The decay time of the pitch envelope, expressed as a normalized value.
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the value maps linearly to milliseconds (1.0 .. 10_000.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float decay_time_normalized = 7;
     */
    decayTimeNormalized: number;
    /**
     * Controls how much the decay phase is bent. 0 is linear, more or less means more or less sloping.
     *
     * @generated from field: float decay_slope_factor = 8;
     */
    decaySlopeFactor: number;
    /**
     * Sustain phase of the envelope. The amount detuned is this factor multiplied
     * by the semitone value below.
     *
     * @generated from field: float sustain_range_factor = 9;
     */
    sustainRangeFactor: number;
    /**
     * The release time of the pitch envelope, expressed as a normalized value.
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the value maps linearly to milliseconds (1.0 .. 10_000.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float release_time_normalized = 10;
     */
    releaseTimeNormalized: number;
    /**
     * Controls how much the release phase is bent. 0 is linear, more or less means more or less sloping.
     *
     * @generated from field: float release_slope_factor = 11;
     */
    releaseSlopeFactor: number;
    /**
     * The value the release phase ends at. The amount detuned is this factor multiplied
     * by the semitone value below.
     *
     * @generated from field: float release_range_factor = 12;
     */
    releaseRangeFactor: number;
    /**
     * The semitone value of the pitch envelope. This is the semitone value that is used to detune
     * the notes played. The different envelope phases use this value to calculate the amount detuned.
     *
     * @generated from field: int32 semitone_range = 13;
     */
    semitoneRange: number;
    constructor(data?: PartialMessage<HeisenbergPitchEnvelope>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.heisenberg.v1.HeisenbergPitchEnvelope";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeisenbergPitchEnvelope;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeisenbergPitchEnvelope;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeisenbergPitchEnvelope;
    static equals(a: HeisenbergPitchEnvelope | PlainMessage<HeisenbergPitchEnvelope> | undefined, b: HeisenbergPitchEnvelope | PlainMessage<HeisenbergPitchEnvelope> | undefined): boolean;
}
/**
 * The filter parameters of the Heisenberg. The filter is applied to the entire
 * signal after all operators have been added together.
 *
 * @generated from message audiotool.document.v1.entity.heisenberg.v1.HeisenbergFilter
 */
export declare class HeisenbergFilter extends Message<HeisenbergFilter> {
    /**
     * Filter cutoff frequency in Hz.
     *
     * @generated from field: float cutoff_frequency_hz = 1;
     */
    cutoffFrequencyHz: number;
    /**
     * Filter resonance. as a value from 1/sqrt(2) to 60 (maxQ).
     *
     * @generated from field: float resonance = 2;
     */
    resonance: number;
    /**
     * Controls the filter "type" in a continuous way:
     * - -1: LowPass
     * - ~0: Shelf Filter
     * -  1: HighPass
     *
     * @generated from field: float filter_type = 3;
     */
    filterType: number;
    /**
     * Selects the filter order/filter gain:
     * - 0: invalid
     * - 1: 12dB
     * - 2: 24dB
     * - 3: 36dB
     * - 4: 48dB
     *
     * @generated from field: uint32 order_index = 4;
     */
    orderIndex: number;
    /**
     * The extent to which the note's velocity influences the filter's cutoff frequency.
     *
     * @generated from field: float velocity_cutoff_modulation_depth = 5;
     */
    velocityCutoffModulationDepth: number;
    /**
     * The extent to which the main envelope influences the filter's cutoff frequency.
     *
     * @generated from field: float envelope_main_cutoff_modulation_depth = 6;
     */
    envelopeMainCutoffModulationDepth: number;
    /**
     * The extent to which envelope 1 influences the filter's cutoff frequency.
     *
     * @generated from field: float envelope_2_cutoff_modulation_depth = 7;
     */
    envelope2CutoffModulationDepth: number;
    /**
     * The extent to which envelope 2 influences the filter's cutoff frequency.
     *
     * @generated from field: float envelope_3_cutoff_modulation_depth = 8;
     */
    envelope3CutoffModulationDepth: number;
    /**
     * The extent to which LFO 1 influences the filter's cutoff frequency.
     *
     * @generated from field: float lfo_1_cutoff_modulation_depth = 9;
     */
    lfo1CutoffModulationDepth: number;
    /**
     * The extent to which LFO 2 influences the filter's cutoff frequency.
     *
     * @generated from field: float lfo_2_cutoff_modulation_depth = 10;
     */
    lfo2CutoffModulationDepth: number;
    /**
     * The extent to which the filter's cutoff frequency is influence by the playing note's
     * pitch. If this is > 0, the higher the note, the higher the filter's cutoff frequency.
     * If this is < 0, the higher the note, the lower the filter's cutoff frequency.
     *
     * @generated from field: float keyboard_tracking_amount = 11;
     */
    keyboardTrackingAmount: number;
    constructor(data?: PartialMessage<HeisenbergFilter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.heisenberg.v1.HeisenbergFilter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeisenbergFilter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeisenbergFilter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeisenbergFilter;
    static equals(a: HeisenbergFilter | PlainMessage<HeisenbergFilter> | undefined, b: HeisenbergFilter | PlainMessage<HeisenbergFilter> | undefined): boolean;
}
