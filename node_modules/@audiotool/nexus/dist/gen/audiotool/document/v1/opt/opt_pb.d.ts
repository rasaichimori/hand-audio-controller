import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, FieldOptions as FieldOptions$1, Message, MessageOptions, proto3 } from '@bufbuild/protobuf';

/**
 * Marks a location with a behaviour. A TargetType should describe what a
 * location "is".
 *
 * Good examples:
 * - a message "is" a Groove
 * - a field "is" an AutomatableParameter
 * - a message "is" a PatternTrackPlayer
 *
 * Bad examples:
 * - a device supporting pattern track "is" a PatternTrack - it is _pointed to_ by a PatterTrack,
 *   so it's a PatternTrack_Player_.
 *
 * Pointer fields must be given a TargetType they are allowed to point to.
 * A pointer can only point to exactly one TargetType.
 *
 *     Pointer foo = 3 [(opt.pointer).target: PatternTrackPlayer];
 *
 *
 * TargetTypes can be accepted by the following locations:
 *
 *   Fields:
 *
 *     float bar = 33  [(opt.field).is = [AutomatableParameter]];
 *
 *   List elements:
 *
 *     repeated Baz bar = 33 [(opt.list).element_is = [AutomatableParameter]];
 *
 *   Entities:
 *
 *      message Foo {
 *          option (opt.entity).is = [PatternTrackPlayer, Groove]};
 *          ...
 *      }
 * buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
 *
 * @generated from enum audiotool.document.v1.opt.TargetType
 */
export declare enum TargetType {
    /**
     * Marks a groove. Use to reference a Groove entity.
     *
     * @generated from enum value: Groove = 0;
     */
    Groove = 0,
    /**
     * Marks a sample. Use to reference a Sample entity.
     *
     * @generated from enum value: Sample = 1;
     */
    Sample = 1,
    /**
     * Marks a micro tuning. Use to reference a MicroTuning entity.
     *
     * @generated from enum value: MicroTuning = 2;
     */
    MicroTuning = 2,
    /**
     * Marks something that can be listened to. Use to reference an audio connection
     * by the User object, which is used by the "cue" tool.
     *
     * @generated from enum value: Listenable = 3;
     */
    Listenable = 3,
    /**
     * Makes a field automatable by e.g. an automation track.
     *
     * @generated from enum value: AutomatableParameter = 4;
     */
    AutomatableParameter = 4,
    /**
     * Marks an audio input of a device. Mark a field with that to make it connectable by
     * an audio cable.
     *
     * @generated from enum value: AudioInput = 6;
     */
    AudioInput = 6,
    /**
     * Marks an audio output of a device. Mark a field with that to make it connectable by
     * an audio cable.
     *
     * @generated from enum value: AudioOutput = 7;
     */
    AudioOutput = 7,
    /**
     * Use this to mark an note input of a device. Mark a field with that to make it connectable by
     * a note cable.
     *
     * @generated from enum value: NotesInput = 8;
     */
    NotesInput = 8,
    /**
     * Use this to mark an note output of a device. Mark a field with that to make it connectable by
     * a note cable.
     *
     * @generated from enum value: NotesOutput = 9;
     */
    NotesOutput = 9,
    /**
     * Marks an automation collection, used by AutomationRegions to point to AutomationCollections.
     *
     * @generated from enum value: AutomationCollection = 10;
     */
    AutomationCollection = 10,
    /**
     * Marks an audio track, used by AudioRegions to point to AudioTracks.
     *
     * @generated from enum value: AudioTrack = 11;
     */
    AudioTrack = 11,
    /**
     * Marks something that can have an audio track, used by AudioTrack to point to the AudioDevice.
     *
     * @generated from enum value: AudioTrackPlayer = 12;
     */
    AudioTrackPlayer = 12,
    /**
     * Marks a pattern track, used by PatternRegions to point to PatternTracks.
     *
     * @generated from enum value: PatternTrack = 13;
     */
    PatternTrack = 13,
    /**
     * Marks something that can have a pattern track, used e.g. by the bassline device.
     *
     * @generated from enum value: PatternTrackPlayer = 14;
     */
    PatternTrackPlayer = 14,
    /**
     * Marks a NoteCollection, used by Notes & NoteRegions to point to NoteCollections.
     *
     * @generated from enum value: NoteCollection = 16;
     */
    NoteCollection = 16,
    /**
     * Marks a note track, used by NoteRegions to point to NoteTracks.
     *
     * @generated from enum value: NoteTrack = 17;
     */
    NoteTrack = 17,
    /**
     * Marks something that can have a note track, used e.g. by the bassline device.
     *
     * @generated from enum value: NoteTrackPlayer = 18;
     */
    NoteTrackPlayer = 18,
    /**
     * Marks an automation track, used by AutomationRegions to point to AutomationTracks.
     *
     * @generated from enum value: AutomationTrack = 19;
     */
    AutomationTrack = 19,
    /**
     * Used to mark the connected Waveshaper by a WaveshaperAnchor.
     *
     * @generated from enum value: Waveshaper = 20;
     */
    Waveshaper = 20,
    /**
     * Used to mark the connected Centroid by a CentroidChannel.
     *
     * @generated from enum value: Centroid = 21;
     */
    Centroid = 21,
    /**
     * Used by the rasselbock pattern to point to their rasselbock
     *
     * @generated from enum value: RasselbockPatternSlot = 22;
     */
    RasselbockPatternSlot = 22,
    /**
     * Used by the Tonematrix pattern to point to their tonematrix
     *
     * @generated from enum value: TonematrixPatternSlot = 23;
     */
    TonematrixPatternSlot = 23,
    /**
     * Used by the Beatbox8 pattern to point to their Beatbox8
     *
     * @generated from enum value: Beatbox8PatternSlot = 24;
     */
    Beatbox8PatternSlot = 24,
    /**
     * Used by the Beatbox9 pattern to point to their Beatbox9
     *
     * @generated from enum value: Beatbox9PatternSlot = 25;
     */
    Beatbox9PatternSlot = 25,
    /**
     * Used by the Bassline pattern to point to their Bassline
     *
     * @generated from enum value: BasslinePatternSlot = 26;
     */
    BasslinePatternSlot = 26,
    /**
     * Used by the Machiniste pattern to point to their Machiniste
     *
     * @generated from enum value: MachinistePatternSlot = 27;
     */
    MachinistePatternSlot = 27,
    /**
     * Used by the Matrix pattern to point to their Matrix arpeggiator
     *
     * @generated from enum value: MatrixArpeggiatorPatternSlot = 28;
     */
    MatrixArpeggiatorPatternSlot = 28,
    /**
     * Marks a mixer group strip.
     *
     * @generated from enum value: MixerStripGroup = 29;
     */
    MixerStripGroup = 29,
    /**
     * Marks a mixer strip that can be grouped by a mixer group strip.
     *
     * @generated from enum value: MixerStripGroupChild = 30;
     */
    MixerStripGroupChild = 30,
    /**
     * Pointed to by "SidechainRoute" to connect the sidechin output of a strip to the sidechain input of another strip.
     *
     * @generated from enum value: MixerSideChainInput = 31;
     */
    MixerSideChainInput = 31,
    /**
     * Pointed to by "SidechainRoute" to connect the sidechin output of a strip to the sidechain input of another strip.
     *
     * @generated from enum value: MixerSideChainOutput = 32;
     */
    MixerSideChainOutput = 32,
    /**
     * Pointed to by "AuxRoute" to connect a channel/group strip to an aux strip.
     *
     * @generated from enum value: MixerAuxSend = 33;
     */
    MixerAuxSend = 33,
    /**
     * Pointed to by "AuxRoute" to connect an aux strip to a channel/group strip.
     *
     * @generated from enum value: MixerAuxReceive = 34;
     */
    MixerAuxReceive = 34
}
/**
 * Lists possible formats a `string` field can have
 *
 * @generated from enum audiotool.document.v1.opt.StringFormat
 */
export declare enum StringFormat {
    /**
     * No format specified, just any string.
     *
     * @generated from enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * String must be a valid uuid.
     *
     * @generated from enum value: UUID = 1;
     */
    UUID = 1
}
/**
 * A list provides 'length' elements in an array.
 * All items must immediately be created after creating the protobuf model.
 *
 * To add options to elements, such as floats, use the field options above.
 *
 * @generated from message audiotool.document.v1.opt.ListOptions
 */
export declare class ListOptions extends Message<ListOptions> {
    /**
     * The fixed length of the list.
     *
     * @generated from field: uint32 length = 1;
     */
    length: number;
    /**
     * Mark each element in a list of a list of TargetTypes.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType element_is = 2;
     */
    elementIs: TargetType[];
    constructor(data?: PartialMessage<ListOptions>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.ListOptions";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOptions;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOptions;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOptions;
    static equals(a: ListOptions | PlainMessage<ListOptions> | undefined, b: ListOptions | PlainMessage<ListOptions> | undefined): boolean;
}
/**
 * Options for fields
 *
 * @generated from message audiotool.document.v1.opt.FieldOptions
 */
export declare class FieldOptions extends Message<FieldOptions> {
    /**
     * Marks a field location with a specific name.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType is = 1;
     */
    is: TargetType[];
    /**
     * Marks a field as immutable. Transactions updating the field are rejected. Has no effect
     * on fields that are messages other than Pointer.
     *
     * @generated from field: bool immutable = 2;
     */
    immutable: boolean;
    constructor(data?: PartialMessage<FieldOptions>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.FieldOptions";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldOptions;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldOptions;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldOptions;
    static equals(a: FieldOptions | PlainMessage<FieldOptions> | undefined, b: FieldOptions | PlainMessage<FieldOptions> | undefined): boolean;
}
/**
 * Options for fields
 *
 * @generated from message audiotool.document.v1.opt.EntityOptions
 */
export declare class EntityOptions extends Message<EntityOptions> {
    /**
     * Marks a field location with a specific name.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType is = 1;
     */
    is: TargetType[];
    constructor(data?: PartialMessage<EntityOptions>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.EntityOptions";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityOptions;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityOptions;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityOptions;
    static equals(a: EntityOptions | PlainMessage<EntityOptions> | undefined, b: EntityOptions | PlainMessage<EntityOptions> | undefined): boolean;
}
/**
 * Options that must be set on any `Pointer` field.
 *
 * @generated from message audiotool.document.v1.opt.PointerOptions
 */
export declare class PointerOptions extends Message<PointerOptions> {
    /**
     * Restricts the field to only point to locations with a specific TargetType.
     *
     * @generated from field: audiotool.document.v1.opt.TargetType target = 1;
     */
    target: TargetType;
    /**
     * If this is true, the document is invalid if the value is not set to a valid
     * destination.
     *
     * @generated from field: bool required = 2;
     */
    required: boolean;
    constructor(data?: PartialMessage<PointerOptions>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.PointerOptions";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointerOptions;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointerOptions;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointerOptions;
    static equals(a: PointerOptions | PlainMessage<PointerOptions> | undefined, b: PointerOptions | PlainMessage<PointerOptions> | undefined): boolean;
}
/**
 * Options for `string` fields.
 *
 * @generated from message audiotool.document.v1.opt.String
 */
export declare class String extends Message<String> {
    /**
     * Required format of this string field.
     *
     * @generated from field: audiotool.document.v1.opt.StringFormat format = 1;
     */
    format: StringFormat;
    /**
     * Maximum byte length of this string field. Note that unicode character != 1 byte in general.
     * Must be set on any string field that has format "unspecified".
     *
     * @generated from field: uint32 max_byte_length = 2;
     */
    maxByteLength: number;
    constructor(data?: PartialMessage<String>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.String";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): String;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): String;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): String;
    static equals(a: String | PlainMessage<String> | undefined, b: String | PlainMessage<String> | undefined): boolean;
}
/**
 * Options for `bool` fields.
 *
 * @generated from message audiotool.document.v1.opt.Bool
 */
export declare class Bool extends Message<Bool> {
    /**
     * Suggested default value of this field.
     *
     * @generated from field: bool init = 1;
     */
    init: boolean;
    constructor(data?: PartialMessage<Bool>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.Bool";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bool;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bool;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bool;
    static equals(a: Bool | PlainMessage<Bool> | undefined, b: Bool | PlainMessage<Bool> | undefined): boolean;
}
/**
 * Options for `int32` fields.
 *
 * @generated from message audiotool.document.v1.opt.Int32
 */
export declare class Int32 extends Message<Int32> {
    /**
     * Suggested default value of this field.
     *
     * @generated from field: int32 init = 1;
     */
    init: number;
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.Int32Range range = 2;
     */
    range?: Int32Range;
    constructor(data?: PartialMessage<Int32>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.Int32";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32;
    static equals(a: Int32 | PlainMessage<Int32> | undefined, b: Int32 | PlainMessage<Int32> | undefined): boolean;
}
/**
 * Marks the field as only being valid if its value is within `[min, max]`, inclusive.
 *
 * Note that proto doesn't allow unset primitive fields; if one of `min` or
 * `max` is left out, that value will be set to 0.
 *
 * @generated from message audiotool.document.v1.opt.Int32Range
 */
export declare class Int32Range extends Message<Int32Range> {
    /**
     * lower bound of validity range
     *
     * @generated from field: int32 min = 1;
     */
    min: number;
    /**
     * Upper bound of validity range.
     *
     * @generated from field: int32 max = 2;
     */
    max: number;
    constructor(data?: PartialMessage<Int32Range>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.Int32Range";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Range;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Range;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Range;
    static equals(a: Int32Range | PlainMessage<Int32Range> | undefined, b: Int32Range | PlainMessage<Int32Range> | undefined): boolean;
}
/**
 * Options for `uint32` fields.
 *
 * @generated from message audiotool.document.v1.opt.UInt32
 */
export declare class UInt32 extends Message<UInt32> {
    /**
     * Suggested default value of this field.
     *
     * @generated from field: uint32 init = 1;
     */
    init: number;
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.UInt32Range range = 2;
     */
    range?: UInt32Range;
    constructor(data?: PartialMessage<UInt32>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.UInt32";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32;
    static equals(a: UInt32 | PlainMessage<UInt32> | undefined, b: UInt32 | PlainMessage<UInt32> | undefined): boolean;
}
/**
 * Marks the field as only being valid if its value is within `[min, max]`, inclusive.
 *
 * Note that proto doesn't allow unset primitive fields; if one of `min` or
 * `max` is left out, that value will be set to 0.
 *
 * @generated from message audiotool.document.v1.opt.UInt32Range
 */
export declare class UInt32Range extends Message<UInt32Range> {
    /**
     * Lower bound of validity range.
     *
     * @generated from field: uint32 min = 1;
     */
    min: number;
    /**
     * Upper bound of validity range.
     *
     * @generated from field: uint32 max = 2;
     */
    max: number;
    constructor(data?: PartialMessage<UInt32Range>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.UInt32Range";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Range;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Range;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Range;
    static equals(a: UInt32Range | PlainMessage<UInt32Range> | undefined, b: UInt32Range | PlainMessage<UInt32Range> | undefined): boolean;
}
/**
 * Options for `float` fields.
 *
 * @generated from message audiotool.document.v1.opt.Float
 */
export declare class Float extends Message<Float> {
    /**
     * Default value of this field.
     *
     * @generated from field: float init = 1;
     */
    init: number;
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.FloatRange range = 2;
     */
    range?: FloatRange;
    constructor(data?: PartialMessage<Float>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.Float";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Float;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Float;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Float;
    static equals(a: Float | PlainMessage<Float> | undefined, b: Float | PlainMessage<Float> | undefined): boolean;
}
/**
 * Marks the field as only being valid if its value is within `[min, max]`, inclusive.
 *
 * Note that proto doesn't allow unset primitive fields; if one of `min` or
 * `max` is left out, that value will be set to 0.
 *
 * @generated from message audiotool.document.v1.opt.FloatRange
 */
export declare class FloatRange extends Message<FloatRange> {
    /**
     * Lower bound of validity range.
     *
     * @generated from field: float min = 1;
     */
    min: number;
    /**
     * Upper bound of validity range.
     *
     * @generated from field: float max = 2;
     */
    max: number;
    constructor(data?: PartialMessage<FloatRange>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.FloatRange";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FloatRange;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FloatRange;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FloatRange;
    static equals(a: FloatRange | PlainMessage<FloatRange> | undefined, b: FloatRange | PlainMessage<FloatRange> | undefined): boolean;
}
/**
 * Options for `bytes` fields.
 *
 * @generated from message audiotool.document.v1.opt.Bytes
 */
export declare class Bytes extends Message<Bytes> {
    /**
     * Maximum byte length of this bytes field.
     *
     * @generated from field: uint32 max_byte_length = 1;
     */
    maxByteLength: number;
    constructor(data?: PartialMessage<Bytes>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.opt.Bytes";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bytes;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bytes;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bytes;
    static equals(a: Bytes | PlainMessage<Bytes> | undefined, b: Bytes | PlainMessage<Bytes> | undefined): boolean;
}
/**
 * Options that can only be attached to fields of type bool.
 *
 * @generated from extension: audiotool.document.v1.opt.Bool bool = 50002;
 */
export declare const bool: import('@bufbuild/protobuf').Extension<FieldOptions$1, Bool>;
/**
 * Options that can only be attached to fields of type int32.
 *
 * @generated from extension: audiotool.document.v1.opt.Int32 int32 = 50003;
 */
export declare const int32: import('@bufbuild/protobuf').Extension<FieldOptions$1, Int32>;
/**
 * Options that can only be attached to fields of type uint32.
 *
 * @generated from extension: audiotool.document.v1.opt.UInt32 uint32 = 50004;
 */
export declare const uint32: import('@bufbuild/protobuf').Extension<FieldOptions$1, UInt32>;
/**
 * Options that can only be attached to fields of type float.
 *
 * @generated from extension: audiotool.document.v1.opt.Float float = 50005;
 */
export declare const float: import('@bufbuild/protobuf').Extension<FieldOptions$1, Float>;
/**
 * Options that can only be attached to fields of type string.
 *
 * @generated from extension: audiotool.document.v1.opt.String string = 50006;
 */
export declare const string$: import('@bufbuild/protobuf').Extension<FieldOptions$1, String>;
/**
 * Options that can only be attached to fields of type bytes.
 *
 * @generated from extension: audiotool.document.v1.opt.Bytes bytes = 50009;
 */
export declare const bytes: import('@bufbuild/protobuf').Extension<FieldOptions$1, Bytes>;
/**
 * Options that can only be attached to fields of type Pointer.
 *
 * @generated from extension: audiotool.document.v1.opt.PointerOptions pointer = 50007;
 */
export declare const pointer: import('@bufbuild/protobuf').Extension<FieldOptions$1, PointerOptions>;
/**
 * Options that must be attached to `repeated` fields.
 *
 * @generated from extension: audiotool.document.v1.opt.ListOptions list = 50001;
 */
export declare const list: import('@bufbuild/protobuf').Extension<FieldOptions$1, ListOptions>;
/**
 * Options that can be attached to any field.
 *
 * @generated from extension: audiotool.document.v1.opt.FieldOptions field = 50008;
 */
export declare const field: import('@bufbuild/protobuf').Extension<FieldOptions$1, FieldOptions>;
/**
 * Options that can be attached to entities to make their location
 * of a specific TargetType
 *
 * @generated from extension: audiotool.document.v1.opt.EntityOptions entity = 5000;
 */
export declare const entity: import('@bufbuild/protobuf').Extension<MessageOptions, EntityOptions>;
