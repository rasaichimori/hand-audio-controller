import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';
import { Pointer } from '../../../pointer_pb.js';

/**
 * The MatrixArpeggiator is a pattern-based
 * arpeggiator that generates notes based on:
 * - the currently incoming notes (e.g. from a note track)
 * - the arpeggiation parameters of the currently playing pattern
 *
 * @generated from message audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiator
 */
export declare class MatrixArpeggiator extends Message<MatrixArpeggiator> {
    /**
     * Unique device ID.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Whether the arpeggio is active or not. If is_active=false, the notes are passed
     * through as chord without any arpeggio processing.
     *
     * @generated from field: bool is_active = 5;
     */
    isActive: boolean;
    /**
     * If this parameter is <0, then the absolute value of velocity overrides every incoming note's velocity.
     * If this parameter is >0, then the incoming note's velocity is multiplied by this parameter.
     *
     * @generated from field: float velocity = 6;
     */
    velocity: number;
    /**
     * The interval with which notes are emitted.
     *
     * - 0: invalid
     * - 1: 1 bar
     * - 2: 1/2 bars
     * - 3: 1/4 bars
     * - 4: 3/16 bars
     * - 5: 1/8 bars
     * - 6: 3/32 bars
     * - 7: 1/16 bars
     * - 8: 3/64 bars
     * - 9: 1/32 bars
     * - 10: 1/64 bars
     * - 11: 1/128 bars
     *
     * @generated from field: uint32 step_length_index = 7;
     */
    stepLengthIndex: number;
    /**
     * A note from the arpeggiation pattern is repeated for this many times
     * before the next note is emitted.
     *
     * @generated from field: int32 repeat = 8;
     */
    repeat: number;
    /**
     * The duration of each note in relation to the current step duration. Can
     * be up to two steps long, in which case the notes overlap.
     *
     * @generated from field: float gate_ratio = 9;
     */
    gateRatio: number;
    /**
     * The mode of the arpeggio.
     * - 0: invalid
     * - 1: Up,
     * - 2: Down,
     * - 3: Up/Down,
     * - 4: Zig Zack,
     * - 5: Zig Zack +,
     * - 6: Random
     *
     * @generated from field: uint32 arpeggiation_mode_index = 10;
     */
    arpeggiationModeIndex: number;
    /**
     * The seed used for the random mode, if selected.
     *
     * @generated from field: int32 random_seed = 11;
     */
    randomSeed: number;
    /**
     * The arpeggiation pattern's octave range. The way this influences the arpeggiation
     * pattern depends on arpeggiation_mode_index.
     *
     * @generated from field: int32 octaves = 12;
     */
    octaves: number;
    /**
     * If this flag is true, all incoming notes are assumed pressed until
     * hold_notes_until_note is played, where all notes are released. This allows
     * playing an arpeggiation pattern in real time while not keeping all notes pressed.
     *
     * @generated from field: bool hold_notes = 13;
     */
    holdNotes: boolean;
    /**
     * This defines the note (in MIDI index, i.e. C4=60) that will release all held notes,
     * if hold_notes is set to true.
     *
     * @generated from field: int32 hold_notes_until_note = 14;
     */
    holdNotesUntilNote: number;
    /**
     * If this flag is set to true, then the matrix behaves as though the parameters
     * set on the pattern itself are ignored, with the exception of the pattern's length.
     *
     * It essentially behaves as though the pattern is left to defaults.
     *
     * @generated from field: bool ignore_pattern_step_parameters = 15;
     */
    ignorePatternStepParameters: boolean;
    /**
     * Whether the pattern is started from the start if a note is pressed after a period of silence.
     * If this is false, the matrix pattern behaves as though the pattern continues playing
     * even if no notes are produced.
     *
     * @generated from field: bool pattern_is_synced = 16;
     */
    patternIsSynced: boolean;
    /**
     * Empty fields which MatrixPatterns can point to.
     * This field has an implicit validation rule, which is that at most one MatrixPattern
     * can point to a specific element in this list.
     *
     * @generated from field: repeated audiotool.document.v1.Empty pattern_slots = 17;
     */
    patternSlots: Empty[];
    /**
     * The index of the currently selected pattern. Results in the device playing that pattern, unless
     * a pattern track is connected to it.
     *
     * @generated from field: uint32 pattern_index = 18;
     */
    patternIndex: number;
    /**
     * Notes Input.
     *
     * @generated from field: audiotool.document.v1.Empty notes_input = 19;
     */
    notesInput?: Empty;
    /**
     * Output for the device's notes
     *
     * @generated from field: audiotool.document.v1.Empty notes_output = 20;
     */
    notesOutput?: Empty;
    constructor(data?: PartialMessage<MatrixArpeggiator>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiator";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatrixArpeggiator;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatrixArpeggiator;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatrixArpeggiator;
    static equals(a: MatrixArpeggiator | PlainMessage<MatrixArpeggiator> | undefined, b: MatrixArpeggiator | PlainMessage<MatrixArpeggiator> | undefined): boolean;
}
/**
 * A pattern of the matrix arpeggiator. Contains step-specific parameters such as
 * velocity and mute, and the pattern length.
 *
 * @generated from message audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiatorPattern
 */
export declare class MatrixArpeggiatorPattern extends Message<MatrixArpeggiatorPattern> {
    /**
     * Uniquely identifies this MatrixPattern
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The Matrix this pattern belongs to, also includes the index of the pattern.
     *
     * @generated from field: audiotool.document.v1.Pointer slot = 2;
     */
    slot?: Pointer;
    /**
     * Every pattern can have a groove applied individually.
     *
     * @generated from field: audiotool.document.v1.Pointer groove = 3;
     */
    groove?: Pointer;
    /**
     * The length of the pattern in steps. The duration of each step is controlled
     * by the step_length_index parameter of the matrix arpeggiator.
     *
     * @generated from field: int32 length = 4;
     */
    length: number;
    /**
     * The 64 steps of the pattern.
     *
     * @generated from field: repeated audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiatorPatternStep steps = 5;
     */
    steps: MatrixArpeggiatorPatternStep[];
    constructor(data?: PartialMessage<MatrixArpeggiatorPattern>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiatorPattern";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatrixArpeggiatorPattern;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatrixArpeggiatorPattern;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatrixArpeggiatorPattern;
    static equals(a: MatrixArpeggiatorPattern | PlainMessage<MatrixArpeggiatorPattern> | undefined, b: MatrixArpeggiatorPattern | PlainMessage<MatrixArpeggiatorPattern> | undefined): boolean;
}
/**
 * A step in a matrix arpeggiator pattern.
 *
 * @generated from message audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiatorPatternStep
 */
export declare class MatrixArpeggiatorPatternStep extends Message<MatrixArpeggiatorPatternStep> {
    /**
     * Whether the step's velocity is overridden by the step_velocity parameter; otherwise,
     * the velocity defined by the matrix arpeggiator's velocity parameter is used.
     *
     * @generated from field: bool override_velocity = 1;
     */
    overrideVelocity: boolean;
    /**
     * The velocity to use for this step. If override_velocity is false, the velocity defined
     * by the matrix arpeggiator's velocity parameter is used, and this parameter is ignored.
     *
     * @generated from field: float step_velocity = 2;
     */
    stepVelocity: number;
    /**
     * Whether the step is muted or not. Muted steps are not played.
     *
     * @generated from field: bool is_muted = 3;
     */
    isMuted: boolean;
    /**
     * Whether the step is tied or not. Tied steps are "tied together" with the next
     * step, resulting in a single note being played for both steps. If multiple
     * steps in a row are tied together, the first tied step is played longer.
     *
     * The parameters of a step following a tied step are ignored.
     *
     * @generated from field: bool is_tied = 4;
     */
    isTied: boolean;
    /**
     * If this is true, then in this step a chord is played made up of all notes
     * currently entering the arpeggiator.
     *
     * @generated from field: bool is_chord = 5;
     */
    isChord: boolean;
    constructor(data?: PartialMessage<MatrixArpeggiatorPatternStep>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.matrix_arpeggiator.v1.MatrixArpeggiatorPatternStep";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatrixArpeggiatorPatternStep;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatrixArpeggiatorPatternStep;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatrixArpeggiatorPatternStep;
    static equals(a: MatrixArpeggiatorPatternStep | PlainMessage<MatrixArpeggiatorPatternStep> | undefined, b: MatrixArpeggiatorPatternStep | PlainMessage<MatrixArpeggiatorPatternStep> | undefined): boolean;
}
