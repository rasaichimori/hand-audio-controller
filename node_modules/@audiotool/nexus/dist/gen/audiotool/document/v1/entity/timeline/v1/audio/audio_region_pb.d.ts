import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Region } from '../../../region/v1/region_pb.js';
import { Pointer } from '../../../../pointer_pb.js';

/**
 * An Region of audio on the timeline. Must be attached to an AudioTrack.
 *
 * Note that multiple regions can point to the same sample and/or the same
 * automation collection. In the current audio tool version, it's possible to create
 * "virtual regions" that point to both the same sample and same automation collection,
 * and to create two regions with different collections but the same sample.
 *
 * It is also possible to create two regions that point to
 * different samples but the same automation collection, even though the UI
 * doesn't allow for such an operation.
 *
 * @generated from message audiotool.document.v1.entity.timeline.v1.audio.AudioRegion
 */
export declare class AudioRegion extends Message<AudioRegion> {
    /**
     * The unique identifier of the region.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * This region maps to the audio content of the track.
     *
     * @generated from field: audiotool.document.v1.entity.region.v1.Region region = 2;
     */
    region?: Region;
    /**
     * The track this region belongs to.
     *
     * @generated from field: audiotool.document.v1.Pointer track = 3;
     */
    track?: Pointer;
    /**
     * Automation events that define the playback speed of the sample in this region.
     *
     * @generated from field: audiotool.document.v1.Pointer playback_automation_collection = 4;
     */
    playbackAutomationCollection?: Pointer;
    /**
     * The sample that is played back in this region.
     *
     * @generated from field: audiotool.document.v1.Pointer sample = 5;
     */
    sample?: Pointer;
    /**
     * Gain applied to the sample in the region. Equivalent to a dB range of [-inf, 30.0].
     *
     * @generated from field: float gain = 6;
     */
    gain: number;
    /**
     * The duration of the fade-in envelope in ticks. The sum of this and fade out
     * duration cannot be higher than the region's total duration.
     *
     * @generated from field: uint32 fade_in_duration_ticks = 7;
     */
    fadeInDurationTicks: number;
    /**
     * The slope of the fade-in envelope. 0 is linear, more or less curves the slope.
     *
     * @generated from field: float fade_in_slope = 8;
     */
    fadeInSlope: number;
    /**
     * The duration of the fade-out envelope in ticks. The sum of this and fade in
     * duration cannot be higher than the region's total duration.
     *
     * @generated from field: uint32 fade_out_duration_ticks = 9;
     */
    fadeOutDurationTicks: number;
    /**
     * The slope of the fade-out envelope. 0 is linear, more or less curves the slope.
     *
     * @generated from field: float fade_out_slope = 10;
     */
    fadeOutSlope: number;
    /**
     * The time stretching algorithm, determines the pitch of the sample if it's stretched
     * or compressed over time:
     * - 0: invalid
     * - 1: pitch shift    no processing - faster/slower playback result in lower/higher pitch
     * - 2: time stretch   processing - faster/slower keeps the original pitch, with some artifacts.
     *
     * @generated from field: uint32 timestretch_mode = 11;
     */
    timestretchMode: number;
    /**
     * in timestretch mode, pitch shift the signal by a certain
     * amount of semitones
     *
     * @generated from field: float pitch_shift_semitones = 12;
     */
    pitchShiftSemitones: number;
    constructor(data?: PartialMessage<AudioRegion>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.timeline.v1.audio.AudioRegion";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioRegion;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioRegion;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioRegion;
    static equals(a: AudioRegion | PlainMessage<AudioRegion> | undefined, b: AudioRegion | PlainMessage<AudioRegion> | undefined): boolean;
}
