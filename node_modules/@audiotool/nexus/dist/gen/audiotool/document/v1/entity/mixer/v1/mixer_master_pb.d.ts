import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';

/**
 * The master strip of the DAW. Audio that passes through this strip is audible, audio that doesn't
 * pass through this strip is not audible (unless cuing is enabled).
 *
 * The master can be placed on the desktop. In the DAW, it's represented as the "stagebox", which contains all audio sockets
 * from the mixer so they can be connected to devices on the desktop. The position of the stagebox in the DAW
 * is determined by the position_x and position_y fields.
 *
 * @generated from message audiotool.document.v1.entity.mixer.v1.MixerMaster
 */
export declare class MixerMaster extends Message<MixerMaster> {
    /**
     * Uniquely identifies this mixer master entity.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * X position of the stagebox in the DAW. The Stagebox represents the entire mixer on the desktop.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position of the stagebox in the DAW. The Stagebox represents the entire mixer on the desktop.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * If this is true, the audio will bypass inserts. This is true automatically if both insert_output and insert_input are not connected.
     *
     * @generated from field: bool do_bypass_inserts = 5;
     */
    doBypassInserts: boolean;
    /**
     * Insert leaving the strip. Represented on stage box.
     *
     * @generated from field: audiotool.document.v1.Empty insert_output = 6;
     */
    insertOutput?: Empty;
    /**
     * Insert returning to the strip. Represented on stage box.
     *
     * @generated from field: audiotool.document.v1.Empty insert_input = 7;
     */
    insertInput?: Empty;
    /**
     * Panning of the entire project. -1 is fully left, 0 is centered (unchanged), 1 is fully right.
     *
     * @generated from field: float panning = 8;
     */
    panning: number;
    /**
     * Gain right before the signal leaves the mixer, before the limiter is applied. Equivalent to a dB range of [-inf, 6.0].
     *
     * @generated from field: float post_gain = 9;
     */
    postGain: number;
    /**
     * Whether the limited is enabled or not. The limiter reduces the volume of the output signal
     * to 0dB by reducing the incoming signal if it exceeds this threshold in a smooth manner, otherwise
     * it leaves the signal untouched.
     *
     * Enabling the limiter incurs a global latency penalty of 20ms for the entire project
     * because the limiter has to "look ahead" the signal to have smooth volume reduction.
     *
     * @generated from field: bool limiter_enabled = 10;
     */
    limiterEnabled: boolean;
    /**
     * Mutes everything. Why? Why not.
     *
     * @generated from field: bool is_muted = 11;
     */
    isMuted: boolean;
    constructor(data?: PartialMessage<MixerMaster>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.mixer.v1.MixerMaster";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MixerMaster;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MixerMaster;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MixerMaster;
    static equals(a: MixerMaster | PlainMessage<MixerMaster> | undefined, b: MixerMaster | PlainMessage<MixerMaster> | undefined): boolean;
}
