import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';
import { Pointer } from '../../../pointer_pb.js';

/**
 * data structure for the Machiniste sampler
 *
 * @generated from message audiotool.document.v1.entity.machiniste.v1.Machiniste
 */
export declare class Machiniste extends Message<Machiniste> {
    /**
     * Uniquely identifies this Machiniste
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Output gain of the main output channel. This only affects the sum signal, not
     * the individual channels. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float main_output_gain = 5;
     */
    mainOutputGain: number;
    /**
     * The sum output of all channels, influenced by the main_output_gain.
     *
     * @generated from field: audiotool.document.v1.Empty main_output = 12;
     */
    mainOutput?: Empty;
    /**
     * Global modulation depth applied to all notes.
     *
     * @generated from field: float global_modulation_depth = 6;
     */
    globalModulationDepth: number;
    /**
     * Empty fields which MachinistePatterns can point to. At most one pattern
     * can point to a specific element in this list.
     *
     * @generated from field: repeated audiotool.document.v1.Empty pattern_slots = 7;
     */
    patternSlots: Empty[];
    /**
     * The index of the currently selected pattern. Determines which pattern the Machiniste
     * currently plays back, unless a pattern track is connected to it.
     *
     * @generated from field: uint32 pattern_index = 8;
     */
    patternIndex: number;
    /**
     * Each channel's sample and modulation config.
     *
     * @generated from field: repeated audiotool.document.v1.entity.machiniste.v1.MachinisteChannel channels = 9;
     */
    channels: MachinisteChannel[];
    /**
     * Notes Input.
     *
     * @generated from field: audiotool.document.v1.Empty notes_input = 11;
     */
    notesInput?: Empty;
    /**
     * Whether the device is active or not. If is_active=false, no sound is produced.
     *
     * @generated from field: bool is_active = 13;
     */
    isActive: boolean;
    constructor(data?: PartialMessage<Machiniste>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.machiniste.v1.Machiniste";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Machiniste;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Machiniste;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Machiniste;
    static equals(a: Machiniste | PlainMessage<Machiniste> | undefined, b: Machiniste | PlainMessage<Machiniste> | undefined): boolean;
}
/**
 * A machiniste pattern. Contains all steps for all channels in a single pattern.
 * Can point to a "pattern slot" of the machiniste.
 *
 * @generated from message audiotool.document.v1.entity.machiniste.v1.MachinistePattern
 */
export declare class MachinistePattern extends Message<MachinistePattern> {
    /**
     * Uniquely identifies this MachinistePattern
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The slot in a machiniste that this pattern belongs to.
     *
     * @generated from field: audiotool.document.v1.Pointer slot = 2;
     */
    slot?: Pointer;
    /**
     * Every pattern can have a groove applied individually.
     *
     * @generated from field: audiotool.document.v1.Pointer groove = 3;
     */
    groove?: Pointer;
    /**
     * The duration of each step in ticks:
     *
     * - 0: invalid
     * - 1: 4 steps per 1/4th note = 1/16th semibreve (960 ticks) per step
     * - 2: 8 steps per 1/4th note = 1/32nd semibreve (480 ticks) per step
     * - 3: 3 steps per 1/4th note = 1/12th semibreve (1280 ticks) per step
     * - 4: 6 steps per 1/4th note = 1/24th semibreve (640 ticks) per step
     *
     * @generated from field: uint32 step_scale_index = 4;
     */
    stepScaleIndex: number;
    /**
     * Number of steps before the pattern repeats.
     *
     * @generated from field: int32 length = 5;
     */
    length: number;
    /**
     * Storage of the actual pattern steps for each of the 9 channels.
     *
     * @generated from field: repeated audiotool.document.v1.entity.machiniste.v1.MachinisteChannelPattern channel_patterns = 6;
     */
    channelPatterns: MachinisteChannelPattern[];
    constructor(data?: PartialMessage<MachinistePattern>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.machiniste.v1.MachinistePattern";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MachinistePattern;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MachinistePattern;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MachinistePattern;
    static equals(a: MachinistePattern | PlainMessage<MachinistePattern> | undefined, b: MachinistePattern | PlainMessage<MachinistePattern> | undefined): boolean;
}
/**
 * Holds the pattern steps for a single machiniste chanel.
 *
 * @generated from message audiotool.document.v1.entity.machiniste.v1.MachinisteChannelPattern
 */
export declare class MachinisteChannelPattern extends Message<MachinisteChannelPattern> {
    /**
     * Specifies whether the channel is grouped as "exclusive", preventing channels from playing notes on the same step
     *
     * @generated from field: bool is_exclusive = 1;
     */
    isExclusive: boolean;
    /**
     * Specifies whether the channel is muted
     *
     * @generated from field: bool is_muted = 2;
     */
    isMuted: boolean;
    /**
     * Storage of the pattern steps.
     *
     * @generated from field: repeated audiotool.document.v1.entity.machiniste.v1.MachinisteStep steps = 3;
     */
    steps: MachinisteStep[];
    constructor(data?: PartialMessage<MachinisteChannelPattern>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.machiniste.v1.MachinisteChannelPattern";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MachinisteChannelPattern;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MachinisteChannelPattern;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MachinisteChannelPattern;
    static equals(a: MachinisteChannelPattern | PlainMessage<MachinisteChannelPattern> | undefined, b: MachinisteChannelPattern | PlainMessage<MachinisteChannelPattern> | undefined): boolean;
}
/**
 * The step information for a single step. Each step has a modulation depth
 * and a boolean flag indicating whether the step is on or off.
 * The modulation depth causes the note played for that step to be modulated
 * by the modulation amount assigned to every parameter for that channel
 * below.
 *
 * @generated from message audiotool.document.v1.entity.machiniste.v1.MachinisteStep
 */
export declare class MachinisteStep extends Message<MachinisteStep> {
    /**
     * Whether the step is active. If is_active=false, the step is not played.
     *
     * @generated from field: bool is_active = 1;
     */
    isActive: boolean;
    /**
     * The modulation depth for the step.
     *
     * @generated from field: float modulation_depth = 2;
     */
    modulationDepth: number;
    constructor(data?: PartialMessage<MachinisteStep>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.machiniste.v1.MachinisteStep";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MachinisteStep;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MachinisteStep;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MachinisteStep;
    static equals(a: MachinisteStep | PlainMessage<MachinisteStep> | undefined, b: MachinisteStep | PlainMessage<MachinisteStep> | undefined): boolean;
}
/**
 * Holds the parameters, their modulation amount, and the loaded sample
 * for a single channel.
 *
 * The effective "modulation depth" for each step is the multiplication of
 * the various modulation depths for this step & parameter, which are:
 * - the global modulation depth
 * - the parameter modulation depth
 * - the step modulation depth
 *
 * Call this "mod amount".
 *
 * The effective parameter value used, in % of the parameter's full range, is:
 * - -> if the modulation is positive:
 *        mod amount * (1 - parameter value) + parameter value
 * - -> if the modulation is negative:
 *        mod amount * parameter value + parameter value
 *
 * @generated from message audiotool.document.v1.entity.machiniste.v1.MachinisteChannel
 */
export declare class MachinisteChannel extends Message<MachinisteChannel> {
    /**
     * Audio sample to be played on this channel.
     *
     * @generated from field: audiotool.document.v1.Pointer sample = 1;
     */
    sample?: Pointer;
    /**
     * This sets the starting point in the sample in % of the sample length.
     * 0 means start is at time 0, 1 means start is at the end of the sample.
     *
     * If start > end, the sample is played backwards.
     *
     * @generated from field: float start_trim_factor = 2;
     */
    startTrimFactor: number;
    /**
     * Modulation depth of start_trim_factor. See message documentation for more details.
     *
     * @generated from field: float start_trim_modulation_depth = 3;
     */
    startTrimModulationDepth: number;
    /**
     * This sets the ending point in the sample in % of the sample length.
     * 0 means end is at time 0, 1 means end is at the end of the sample.
     *
     * If start > end, the sample is played backwards.
     *
     * @generated from field: float end_trim_factor = 4;
     */
    endTrimFactor: number;
    /**
     * Modulation depth of end_trim_factor. See message documentation for more details.
     *
     * @generated from field: float end_trim_modulation_depth = 5;
     */
    endTrimModulationDepth: number;
    /**
     * Tunes the sample by a given amount of semitones by playing it at a different speed.
     *
     * For example, -12 detunes the sample by 1 octave by playing it at half the original speed.
     *
     * @generated from field: float pitch_semitones = 6;
     */
    pitchSemitones: number;
    /**
     * Modulation depth of tune. See message documentation for more details.
     *
     * @generated from field: float pitch_modulation_depth = 7;
     */
    pitchModulationDepth: number;
    /**
     * Selects the sample filter type.
     *
     * - 0: invalid
     * - 1: no filter
     * - 2: low-pass
     * - 3: high-pass
     *
     * @generated from field: uint32 filter_type_index = 8;
     */
    filterTypeIndex: number;
    /**
     * Filter cutoff, mapped to [28hz, 12000hz].
     *
     * @generated from field: float cutoff_frequency_hz = 9;
     */
    cutoffFrequencyHz: number;
    /**
     * Modulation depth of cutoff. See message documentation for more details.
     *
     * @generated from field: float cutoff_modulation_depth = 10;
     */
    cutoffModulationDepth: number;
    /**
     * Filter resonance. No unit.
     *
     * @generated from field: float resonance = 11;
     */
    resonance: number;
    /**
     * Modulation depth of resonance. See message documentation for more details.
     *
     * @generated from field: float resonance_modulation_depth = 12;
     */
    resonanceModulationDepth: number;
    /**
     * At what point during the sample playback, in % of the sample length, the envelope peaks.
     *
     * @generated from field: float envelope_peak_ratio = 13;
     */
    envelopePeakRatio: number;
    /**
     * Modulation depth of envelope ratio. See message documentation for more details.
     *
     * @generated from field: float envelope_ratio_modulation_depth = 14;
     */
    envelopeRatioModulationDepth: number;
    /**
     * The steepness of the slope. 0 is linear, -1 slopes up, 1 slopes down.
     *
     * @generated from field: float envelope_slope = 15;
     */
    envelopeSlope: number;
    /**
     * Modulation depth of envelope slope. See message documentation for more details.
     *
     * @generated from field: float envelope_slope_modulation_depth = 16;
     */
    envelopeSlopeModulationDepth: number;
    /**
     * Pans the signal to left/right. -1 is fully left, 0 is centered (unchanged), 1 is fully right.
     *
     * @generated from field: float panning = 17;
     */
    panning: number;
    /**
     * Modulation depth of panning. See message documentation for more details.
     *
     * @generated from field: float panning_modulation_depth = 18;
     */
    panningModulationDepth: number;
    /**
     * Output gain of the channel. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 19;
     */
    gain: number;
    /**
     * Modulation depth of gain. See message documentation for more details.
     *
     * @generated from field: float gain_modulation_depth = 20;
     */
    gainModulationDepth: number;
    /**
     * Individual channel output, if connected then the audio from
     * this channel no longer outputs via the master output.
     *
     * @generated from field: audiotool.document.v1.Empty channel_output = 21;
     */
    channelOutput?: Empty;
    constructor(data?: PartialMessage<MachinisteChannel>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.machiniste.v1.MachinisteChannel";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MachinisteChannel;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MachinisteChannel;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MachinisteChannel;
    static equals(a: MachinisteChannel | PlainMessage<MachinisteChannel> | undefined, b: MachinisteChannel | PlainMessage<MachinisteChannel> | undefined): boolean;
}
