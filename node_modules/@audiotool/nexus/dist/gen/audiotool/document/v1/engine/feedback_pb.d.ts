import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Pointer } from '../pointer_pb.js';

/**
 * An array of feedback messages, contains all collected feedback messages
 * between the last time the audio engine was polled and the current time.
 *
 * @generated from message audiotool.document.v1.engine.Feedback
 */
export declare class Feedback extends Message<Feedback> {
    /**
     * Peaks of the audio currently outputted by the engine.
     *
     * @generated from field: audiotool.document.v1.engine.GlobalAudioPeaks audio_peaks = 1;
     */
    audioPeaks?: GlobalAudioPeaks;
    /**
     * Information on the CPU load of the engine.
     *
     * @generated from field: audiotool.document.v1.engine.LoadFeedback load = 2;
     */
    load?: LoadFeedback;
    /**
     * circuit breaker state
     *
     * @generated from field: audiotool.document.v1.engine.CircuitBreaker circuit_breaker = 3;
     */
    circuitBreaker?: CircuitBreaker;
    /**
     * Information on the current transport position.
     *
     * @generated from field: repeated audiotool.document.v1.engine.TransportPositionFeedback transport_position = 4;
     */
    transportPosition: TransportPositionFeedback[];
    /**
     * The feedback messages collected since the last time
     * feedback was collected. Contains at most one message per entity.
     *
     * @generated from field: repeated audiotool.document.v1.engine.ProcessorFeedback processors = 5;
     */
    processors: ProcessorFeedback[];
    constructor(data?: PartialMessage<Feedback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.Feedback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Feedback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Feedback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Feedback;
    static equals(a: Feedback | PlainMessage<Feedback> | undefined, b: Feedback | PlainMessage<Feedback> | undefined): boolean;
}
/**
 * A feedback coming from a specific processor. The adapter maps the processor fedback
 * to a nexus path.
 *
 * @generated from message audiotool.document.v1.engine.ProcessorFeedback
 */
export declare class ProcessorFeedback extends Message<ProcessorFeedback> {
    /**
     * What the feedback is for. What exactly this points to is dependent on the entity.
     *
     * @generated from field: audiotool.document.v1.Pointer location = 1;
     */
    location?: Pointer;
    /**
     * The feedback content. The meaning of this value depends on the entity the feedback is for.
     * For example, the waveshapder has a single gain display, and so will receive a single
     * float value as feedback.
     *
     * @generated from field: repeated float values = 2;
     */
    values: number[];
    constructor(data?: PartialMessage<ProcessorFeedback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.ProcessorFeedback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProcessorFeedback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProcessorFeedback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProcessorFeedback;
    static equals(a: ProcessorFeedback | PlainMessage<ProcessorFeedback> | undefined, b: ProcessorFeedback | PlainMessage<ProcessorFeedback> | undefined): boolean;
}
/**
 * Contains feedback related to the overall engine state.
 *
 * @generated from message audiotool.document.v1.engine.GlobalAudioPeaks
 */
export declare class GlobalAudioPeaks extends Message<GlobalAudioPeaks> {
    /**
     * Last peak on the left of whatever the engine outputs,
     * minus the metronome.
     *
     * @generated from field: float last_peak_left = 2;
     */
    lastPeakLeft: number;
    /**
     * Last peak on the right of whatever the engine outputs,
     * minus the metronome.
     *
     * @generated from field: float last_peak_right = 3;
     */
    lastPeakRight: number;
    /**
     * Last rms on the left of whatever the engine outputs,
     * minus the metronome.
     *
     * @generated from field: float last_rms_left = 4;
     */
    lastRmsLeft: number;
    /**
     * Last rms on the right of whatever the engine outputs,
     * minus the metronome.
     *
     * @generated from field: float last_rms_right = 5;
     */
    lastRmsRight: number;
    constructor(data?: PartialMessage<GlobalAudioPeaks>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.GlobalAudioPeaks";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GlobalAudioPeaks;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GlobalAudioPeaks;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GlobalAudioPeaks;
    static equals(a: GlobalAudioPeaks | PlainMessage<GlobalAudioPeaks> | undefined, b: GlobalAudioPeaks | PlainMessage<GlobalAudioPeaks> | undefined): boolean;
}
/**
 * Contains current engine load feedback. Might be extended with more data,
 * such as buffer underruns.
 *
 * @generated from message audiotool.document.v1.engine.LoadFeedback
 */
export declare class LoadFeedback extends Message<LoadFeedback> {
    /**
     * Current CPU load of the audio thread, calculated as `time needed / time available` to calculate
     * the next block.
     *
     * @generated from field: float cpu_load_pct = 6;
     */
    cpuLoadPct: number;
    constructor(data?: PartialMessage<LoadFeedback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.LoadFeedback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadFeedback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadFeedback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadFeedback;
    static equals(a: LoadFeedback | PlainMessage<LoadFeedback> | undefined, b: LoadFeedback | PlainMessage<LoadFeedback> | undefined): boolean;
}
/**
 * the circuit breaker (ear protection safety feature) state
 *
 * @generated from message audiotool.document.v1.engine.CircuitBreaker
 */
export declare class CircuitBreaker extends Message<CircuitBreaker> {
    /**
     * if we exceeded a certain level, we'll trip the circuit breaker
     * so all audio will be muted ...
     *
     * @generated from field: bool tripped = 1;
     */
    tripped: boolean;
    constructor(data?: PartialMessage<CircuitBreaker>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.CircuitBreaker";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CircuitBreaker;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CircuitBreaker;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CircuitBreaker;
    static equals(a: CircuitBreaker | PlainMessage<CircuitBreaker> | undefined, b: CircuitBreaker | PlainMessage<CircuitBreaker> | undefined): boolean;
}
/**
 * Contains feedback related to the transport position.
 *
 * @generated from message audiotool.document.v1.engine.TransportPositionFeedback
 */
export declare class TransportPositionFeedback extends Message<TransportPositionFeedback> {
    /**
     * Contains the current position of the transport.
     *
     * @generated from field: int32 current_transport_position_ticks = 7;
     */
    currentTransportPositionTicks: number;
    /**
     * the total elapsed time since reference time point
     *
     * @generated from field: double total_elapsed_time = 8;
     */
    totalElapsedTime: number;
    /**
     * If set, the transport jumped since the last feedback, and the message
     * contains where from & to.
     *
     * @generated from field: audiotool.document.v1.engine.TransportJump transport_position_jump = 9;
     */
    transportPositionJump?: TransportJump;
    /**
     * the last engine request that was executed on this postion
     *
     * @generated from field: optional uint64 last_executed_request = 10;
     */
    lastExecutedRequest?: bigint;
    constructor(data?: PartialMessage<TransportPositionFeedback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.TransportPositionFeedback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransportPositionFeedback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransportPositionFeedback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransportPositionFeedback;
    static equals(a: TransportPositionFeedback | PlainMessage<TransportPositionFeedback> | undefined, b: TransportPositionFeedback | PlainMessage<TransportPositionFeedback> | undefined): boolean;
}
/**
 * If this message is set, the transport jumped since the last feedback.
 *
 * @generated from message audiotool.document.v1.engine.TransportJump
 */
export declare class TransportJump extends Message<TransportJump> {
    /**
     * What position the transport jumped from
     *
     * @generated from field: int32 from_position_ticks = 1;
     */
    fromPositionTicks: number;
    /**
     * What position the transport jumped to
     *
     * @generated from field: int32 to_position_ticks = 2;
     */
    toPositionTicks: number;
    constructor(data?: PartialMessage<TransportJump>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.TransportJump";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransportJump;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransportJump;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransportJump;
    static equals(a: TransportJump | PlainMessage<TransportJump> | undefined, b: TransportJump | PlainMessage<TransportJump> | undefined): boolean;
}
