import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Modification } from '../document_service_pb.js';
import { Pointer } from '../pointer_pb.js';
import { VST3PluginState } from './plugin_state_pb.js';

/**
 * Play action message for the engine.
 * buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
 *
 * @generated from enum audiotool.document.v1.engine.PlayStatus
 */
export declare enum PlayStatus {
    /**
     * Starts playing the transport at the current position.
     *
     * @generated from enum value: Start = 0;
     */
    Start = 0,
    /**
     * Starts recording at the current position
     *
     * @generated from enum value: Record = 1;
     */
    Record = 1,
    /**
     * Pauses the transport at the current position.
     *
     * @generated from enum value: Pause = 2;
     */
    Pause = 2,
    /**
     * Moves the transport to time 0, and resets all processors.
     *
     * @generated from enum value: Stop = 3;
     */
    Stop = 3
}
/**
 * A message to control the engine - control the transport,
 * apply modifications,  play midi, ...
 *
 * @generated from message audiotool.document.v1.engine.Request
 */
export declare class Request extends Message<Request> {
    /**
     * The id of this request. Used to send back timestamps of when the request was applied.
     *
     * @generated from field: uint64 id = 1;
     */
    id: bigint;
    /**
     * either transport or CRUD
     *
     * @generated from oneof audiotool.document.v1.engine.Request.action
     */
    action: {
        /**
         * Control the playback state/
         *
         * @generated from field: audiotool.document.v1.engine.Transport transport = 2;
         */
        value: Transport;
        case: "transport";
    } | {
        /**
         * Modifications to the document, such as the creation, update and deletion
         * of processors, regions, and the like, will spawn this message to inform the audio
         * about the change. Keep in mind that at that point, the modification has already
         * happened, this message has no effect directly on the document.
         *
         * @generated from field: audiotool.document.v1.Modification modification = 3;
         */
        value: Modification;
        case: "modification";
    } | {
        /**
         * Turn on a midi note on a specific processor.
         *
         * @generated from field: audiotool.document.v1.engine.MidiNoteOn midi_note_on = 4;
         */
        value: MidiNoteOn;
        case: "midiNoteOn";
    } | {
        /**
         * Turn off a midi note on a specific processor
         *
         * @generated from field: audiotool.document.v1.engine.MidiNoteOff midi_note_off = 5;
         */
        value: MidiNoteOff;
        case: "midiNoteOff";
    } | {
        /**
         * A midi bend message on a specific processor.
         *
         * @generated from field: audiotool.document.v1.engine.MidiBend midi_bend = 6;
         */
        value: MidiBend;
        case: "midiBend";
    } | {
        /**
         * Enable or disable looping of audio playback
         *
         * @generated from field: audiotool.document.v1.engine.LoopPlayback loop_playback = 7;
         */
        value: LoopPlayback;
        case: "loopPlayback";
    } | {
        /**
         * Update the timeline loop range
         *
         * @generated from field: audiotool.document.v1.engine.LoopRange loop_range = 8;
         */
        value: LoopRange;
        case: "loopRange";
    } | {
        /**
         * Change whether audio is cued from a specific connection
         *
         * @generated from field: audiotool.document.v1.engine.AudioPickup audio_pickup = 9;
         */
        value: AudioPickup;
        case: "audioPickup";
    } | {
        /**
         * Control the metronome playback state
         *
         * @generated from field: audiotool.document.v1.engine.MetronomePlayback metronome_playback = 10;
         */
        value: MetronomePlayback;
        case: "metronomePlayback";
    } | {
        /**
         * Control the metronome gain
         *
         * @generated from field: audiotool.document.v1.engine.MetronomeGain metronome_gain = 11;
         */
        value: MetronomeGain;
        case: "metronomeGain";
    } | {
        /**
         * Control the metronome count-in duration
         *
         * @generated from field: audiotool.document.v1.engine.MetronomeCountIn metronome_count_in = 12;
         */
        value: MetronomeCountIn;
        case: "metronomeCountIn";
    } | {
        /**
         * Unlink an automated parameter from its automation track.
         *
         * @generated from field: audiotool.document.v1.engine.UnlinkAutomatableParameter unlink_automatable_parameter = 13;
         */
        value: UnlinkAutomatableParameter;
        case: "unlinkAutomatableParameter";
    } | {
        /**
         * explicitly link a parameter its automation track, if present
         *
         * @generated from field: audiotool.document.v1.engine.LinkAutomatableParameter link_automatable_parameter = 14;
         */
        value: LinkAutomatableParameter;
        case: "linkAutomatableParameter";
    } | {
        /**
         * synchronize timestamps
         *
         * @generated from field: audiotool.document.v1.engine.SyncZero sync_zero = 15;
         */
        value: SyncZero;
        case: "syncZero";
    } | {
        /**
         * enable/disable circuit breaker
         *
         * @generated from field: audiotool.document.v1.engine.CircuitBreakerEnabled circuit_breaker_enabled = 16;
         */
        value: CircuitBreakerEnabled;
        case: "circuitBreakerEnabled";
    } | {
        /**
         * set circuit breaker threshold
         *
         * @generated from field: audiotool.document.v1.engine.CircuitBreakerThreshold circuit_breaker_threshold = 17;
         */
        value: CircuitBreakerThreshold;
        case: "circuitBreakerThreshold";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Request>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.Request";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request;
    static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean;
}
/**
 * Meta-message for transport events.
 *
 * @generated from message audiotool.document.v1.engine.Transport
 */
export declare class Transport extends Message<Transport> {
    /**
     * currently there's 2 options
     *
     * @generated from oneof audiotool.document.v1.engine.Transport.event
     */
    event: {
        /**
         * The playback status, see above.
         *
         * @generated from field: audiotool.document.v1.engine.PlayStatus play_status = 1;
         */
        value: PlayStatus;
        case: "playStatus";
    } | {
        /**
         * Jump to a time position.
         *
         * @generated from field: audiotool.document.v1.engine.Seek seek = 2;
         */
        value: Seek;
        case: "seek";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Transport>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.Transport";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transport;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transport;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transport;
    static equals(a: Transport | PlainMessage<Transport> | undefined, b: Transport | PlainMessage<Transport> | undefined): boolean;
}
/**
 * This message sets the playhead position to a certain time.
 *
 * @generated from message audiotool.document.v1.engine.Seek
 */
export declare class Seek extends Message<Seek> {
    /**
     * The position in BarTime, relative to the tempo (that is, one bar will have a shorter or longer
     * absolute duration relative to the tempo, as specified in BPM).
     *
     * @generated from field: double position = 1;
     */
    position: number;
    constructor(data?: PartialMessage<Seek>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.Seek";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Seek;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Seek;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Seek;
    static equals(a: Seek | PlainMessage<Seek> | undefined, b: Seek | PlainMessage<Seek> | undefined): boolean;
}
/**
 * Trigger a midi note on a specific processor.
 *
 * Note that at most one note can be playing per processor and note key.
 *
 * @generated from message audiotool.document.v1.engine.MidiNoteOn
 */
export declare class MidiNoteOn extends Message<MidiNoteOn> {
    /**
     * The processor id the midi note is for.
     *
     * @generated from field: string processor_id = 1;
     */
    processorId: string;
    /**
     * The key of the note. A number between 0 and 127.
     *
     * @generated from field: uint32 key = 2;
     */
    key: number;
    /**
     * The velocity of the note, between 0 and 1, excluding 0.
     *
     * @generated from field: float velocity = 3;
     */
    velocity: number;
    constructor(data?: PartialMessage<MidiNoteOn>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MidiNoteOn";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MidiNoteOn;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MidiNoteOn;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MidiNoteOn;
    static equals(a: MidiNoteOn | PlainMessage<MidiNoteOn> | undefined, b: MidiNoteOn | PlainMessage<MidiNoteOn> | undefined): boolean;
}
/**
 * Turn a playing midi note off.
 *
 * @generated from message audiotool.document.v1.engine.MidiNoteOff
 */
export declare class MidiNoteOff extends Message<MidiNoteOff> {
    /**
     * The processor id the midi note is for.
     *
     * @generated from field: string processor_id = 1;
     */
    processorId: string;
    /**
     * The key of the note. A number between 0 and 127.
     *
     * @generated from field: uint32 key = 2;
     */
    key: number;
    constructor(data?: PartialMessage<MidiNoteOff>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MidiNoteOff";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MidiNoteOff;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MidiNoteOff;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MidiNoteOff;
    static equals(a: MidiNoteOff | PlainMessage<MidiNoteOff> | undefined, b: MidiNoteOff | PlainMessage<MidiNoteOff> | undefined): boolean;
}
/**
 * A midi bend message - this will bend all currently running notes of a specific processor
 * by some amount of cents.
 *
 * @generated from message audiotool.document.v1.engine.MidiBend
 */
export declare class MidiBend extends Message<MidiBend> {
    /**
     * The processor id this bend message is for.
     *
     * @generated from field: string processor_id = 1;
     */
    processorId: string;
    /**
     * normalized bend factor, range [-1,1]
     *
     * @generated from field: float bend_factor = 2;
     */
    bendFactor: number;
    constructor(data?: PartialMessage<MidiBend>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MidiBend";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MidiBend;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MidiBend;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MidiBend;
    static equals(a: MidiBend | PlainMessage<MidiBend> | undefined, b: MidiBend | PlainMessage<MidiBend> | undefined): boolean;
}
/**
 * Toggle looping of audio playback
 *
 * @generated from message audiotool.document.v1.engine.LoopPlayback
 */
export declare class LoopPlayback extends Message<LoopPlayback> {
    /**
     * Defines whether the engine should be looping in the timeline
     *
     * @generated from field: bool enabled = 1;
     */
    enabled: boolean;
    constructor(data?: PartialMessage<LoopPlayback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.LoopPlayback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoopPlayback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoopPlayback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoopPlayback;
    static equals(a: LoopPlayback | PlainMessage<LoopPlayback> | undefined, b: LoopPlayback | PlainMessage<LoopPlayback> | undefined): boolean;
}
/**
 * Modify the region of the arrangement to be looped
 *
 * @generated from message audiotool.document.v1.engine.LoopRange
 */
export declare class LoopRange extends Message<LoopRange> {
    /**
     * Start position of the looped interval
     *
     * @generated from field: uint32 start_tick = 1;
     */
    startTick: number;
    /**
     * The duration of the loop interval. 61440 = 4 bars
     *
     * @generated from field: uint32 duration_ticks = 2;
     */
    durationTicks: number;
    constructor(data?: PartialMessage<LoopRange>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.LoopRange";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoopRange;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoopRange;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoopRange;
    static equals(a: LoopRange | PlainMessage<LoopRange> | undefined, b: LoopRange | PlainMessage<LoopRange> | undefined): boolean;
}
/**
 * Specify an audio connection to cue audio from, if any
 *
 * @generated from message audiotool.document.v1.engine.AudioPickup
 */
export declare class AudioPickup extends Message<AudioPickup> {
    /**
     * the audio connection currently listened to using the "cue" tool, if any
     *
     * @generated from field: audiotool.document.v1.Pointer connection = 1;
     */
    connection?: Pointer;
    constructor(data?: PartialMessage<AudioPickup>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.AudioPickup";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioPickup;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioPickup;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioPickup;
    static equals(a: AudioPickup | PlainMessage<AudioPickup> | undefined, b: AudioPickup | PlainMessage<AudioPickup> | undefined): boolean;
}
/**
 * Toggle metronome audio playback
 *
 * @generated from message audiotool.document.v1.engine.MetronomePlayback
 */
export declare class MetronomePlayback extends Message<MetronomePlayback> {
    /**
     * Set whether metronome is enabled during playback
     *
     * @generated from field: bool enabled = 1;
     */
    enabled: boolean;
    constructor(data?: PartialMessage<MetronomePlayback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MetronomePlayback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetronomePlayback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetronomePlayback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetronomePlayback;
    static equals(a: MetronomePlayback | PlainMessage<MetronomePlayback> | undefined, b: MetronomePlayback | PlainMessage<MetronomePlayback> | undefined): boolean;
}
/**
 * Specify metronome volume gain
 *
 * @generated from message audiotool.document.v1.engine.MetronomeGain
 */
export declare class MetronomeGain extends Message<MetronomeGain> {
    /**
     * Set the metronome volume gain
     *
     * @generated from field: float gain = 1;
     */
    gain: number;
    constructor(data?: PartialMessage<MetronomeGain>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MetronomeGain";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetronomeGain;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetronomeGain;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetronomeGain;
    static equals(a: MetronomeGain | PlainMessage<MetronomeGain> | undefined, b: MetronomeGain | PlainMessage<MetronomeGain> | undefined): boolean;
}
/**
 * Specify metronome count-in duration
 *
 * @generated from message audiotool.document.v1.engine.MetronomeCountIn
 */
export declare class MetronomeCountIn extends Message<MetronomeCountIn> {
    /**
     * Set the metronome count-in length in ticks
     *
     * @generated from field: uint32 count_in = 1;
     */
    countIn: number;
    constructor(data?: PartialMessage<MetronomeCountIn>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MetronomeCountIn";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetronomeCountIn;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetronomeCountIn;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetronomeCountIn;
    static equals(a: MetronomeCountIn | PlainMessage<MetronomeCountIn> | undefined, b: MetronomeCountIn | PlainMessage<MetronomeCountIn> | undefined): boolean;
}
/**
 * synchronize time between audio threads
 *
 * @generated from message audiotool.document.v1.engine.SyncZero
 */
export declare class SyncZero extends Message<SyncZero> {
    /**
     * the zero timestamp
     *
     * @generated from field: double timestamp = 1;
     */
    timestamp: number;
    constructor(data?: PartialMessage<SyncZero>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.SyncZero";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncZero;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncZero;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncZero;
    static equals(a: SyncZero | PlainMessage<SyncZero> | undefined, b: SyncZero | PlainMessage<SyncZero> | undefined): boolean;
}
/**
 * enable or disable the circuit breaker
 *
 * @generated from message audiotool.document.v1.engine.CircuitBreakerEnabled
 */
export declare class CircuitBreakerEnabled extends Message<CircuitBreakerEnabled> {
    /**
     * flag whether it's enabled or not
     *
     * @generated from field: bool enabled = 1;
     */
    enabled: boolean;
    constructor(data?: PartialMessage<CircuitBreakerEnabled>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.CircuitBreakerEnabled";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CircuitBreakerEnabled;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CircuitBreakerEnabled;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CircuitBreakerEnabled;
    static equals(a: CircuitBreakerEnabled | PlainMessage<CircuitBreakerEnabled> | undefined, b: CircuitBreakerEnabled | PlainMessage<CircuitBreakerEnabled> | undefined): boolean;
}
/**
 * set the circuit breaker threshold
 *
 * @generated from message audiotool.document.v1.engine.CircuitBreakerThreshold
 */
export declare class CircuitBreakerThreshold extends Message<CircuitBreakerThreshold> {
    /**
     * threshold
     *
     * @generated from field: float threshold = 1;
     */
    threshold: number;
    constructor(data?: PartialMessage<CircuitBreakerThreshold>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.CircuitBreakerThreshold";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CircuitBreakerThreshold;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CircuitBreakerThreshold;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CircuitBreakerThreshold;
    static equals(a: CircuitBreakerThreshold | PlainMessage<CircuitBreakerThreshold> | undefined, b: CircuitBreakerThreshold | PlainMessage<CircuitBreakerThreshold> | undefined): boolean;
}
/**
 * load a stereo sample
 *
 * @generated from message audiotool.document.v1.engine.StereoBuffer
 */
export declare class StereoBuffer extends Message<StereoBuffer> {
    /**
     * the left channel of this sample
     *
     * @generated from field: repeated float left_ch = 3;
     */
    leftCh: number[];
    /**
     * the right channel of this sample
     *
     * @generated from field: repeated float right_ch = 4;
     */
    rightCh: number[];
    constructor(data?: PartialMessage<StereoBuffer>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.StereoBuffer";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StereoBuffer;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StereoBuffer;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StereoBuffer;
    static equals(a: StereoBuffer | PlainMessage<StereoBuffer> | undefined, b: StereoBuffer | PlainMessage<StereoBuffer> | undefined): boolean;
}
/**
 * load a mono sample
 *
 * @generated from message audiotool.document.v1.engine.MonoBuffer
 */
export declare class MonoBuffer extends Message<MonoBuffer> {
    /**
     * the single channel of this sample
     *
     * @generated from field: repeated float mono_ch = 3;
     */
    monoCh: number[];
    constructor(data?: PartialMessage<MonoBuffer>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.MonoBuffer";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MonoBuffer;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MonoBuffer;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MonoBuffer;
    static equals(a: MonoBuffer | PlainMessage<MonoBuffer> | undefined, b: MonoBuffer | PlainMessage<MonoBuffer> | undefined): boolean;
}
/**
 * load a sample ... named to distinguish it
 * from other samples ...
 *
 * @generated from message audiotool.document.v1.engine.BoosterSample
 */
export declare class BoosterSample extends Message<BoosterSample> {
    /**
     * the id of this sample
     *
     * @generated from field: string sample_id = 1;
     */
    sampleId: string;
    /**
     * the samplerate of this sample
     *
     * @generated from field: uint32 samplerate = 2;
     */
    samplerate: number;
    /**
     * the contents of the sample ...
     *
     * @generated from oneof audiotool.document.v1.engine.BoosterSample.buffer
     */
    buffer: {
        /**
         * ... either mono ...
         *
         * @generated from field: audiotool.document.v1.engine.MonoBuffer mono = 3;
         */
        value: MonoBuffer;
        case: "mono";
    } | {
        /**
         * ... or stereo.
         *
         * @generated from field: audiotool.document.v1.engine.StereoBuffer stereo = 4;
         */
        value: StereoBuffer;
        case: "stereo";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<BoosterSample>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.BoosterSample";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoosterSample;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoosterSample;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoosterSample;
    static equals(a: BoosterSample | PlainMessage<BoosterSample> | undefined, b: BoosterSample | PlainMessage<BoosterSample> | undefined): boolean;
}
/**
 * unload a sample from booster
 *
 * @generated from message audiotool.document.v1.engine.DeleteSampleRequest
 */
export declare class DeleteSampleRequest extends Message<DeleteSampleRequest> {
    /**
     * The id of this request. Used to send back timestamps of when the request was applied.
     *
     * @generated from field: uint64 id = 1;
     */
    id: bigint;
    /**
     * the sample id to be unloaded
     *
     * @generated from field: string sample_id = 2;
     */
    sampleId: string;
    constructor(data?: PartialMessage<DeleteSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.DeleteSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSampleRequest;
    static equals(a: DeleteSampleRequest | PlainMessage<DeleteSampleRequest> | undefined, b: DeleteSampleRequest | PlainMessage<DeleteSampleRequest> | undefined): boolean;
}
/**
 * unload a sample from booster
 *
 * @generated from message audiotool.document.v1.engine.LoadSampleRequest
 */
export declare class LoadSampleRequest extends Message<LoadSampleRequest> {
    /**
     * The id of this request. Used to send back timestamps of when the request was applied.
     *
     * @generated from field: uint64 id = 1;
     */
    id: bigint;
    /**
     * the sample id to be unloaded
     *
     * @generated from field: audiotool.document.v1.engine.BoosterSample sample = 2;
     */
    sample?: BoosterSample;
    constructor(data?: PartialMessage<LoadSampleRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.LoadSampleRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadSampleRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadSampleRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadSampleRequest;
    static equals(a: LoadSampleRequest | PlainMessage<LoadSampleRequest> | undefined, b: LoadSampleRequest | PlainMessage<LoadSampleRequest> | undefined): boolean;
}
/**
 * load a soundfont to the native booster
 *
 * @generated from message audiotool.document.v1.engine.CreateSoundfontRequest
 */
export declare class CreateSoundfontRequest extends Message<CreateSoundfontRequest> {
    /**
     * The id of this request. Used to send back timestamps of when the request was applied.
     *
     * @generated from field: uint64 request_id = 1;
     */
    requestId: bigint;
    /**
     * The id of the soundfont to be created
     *
     * @generated from field: string soundfont_id = 2;
     */
    soundfontId: string;
    /**
     * The buffer of the soundfont
     *
     * @generated from field: bytes buffer = 3;
     */
    buffer: Uint8Array<ArrayBuffer>;
    constructor(data?: PartialMessage<CreateSoundfontRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.CreateSoundfontRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSoundfontRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSoundfontRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSoundfontRequest;
    static equals(a: CreateSoundfontRequest | PlainMessage<CreateSoundfontRequest> | undefined, b: CreateSoundfontRequest | PlainMessage<CreateSoundfontRequest> | undefined): boolean;
}
/**
 * unload a soundfont from the native booster
 *
 * @generated from message audiotool.document.v1.engine.DeleteSoundfontRequest
 */
export declare class DeleteSoundfontRequest extends Message<DeleteSoundfontRequest> {
    /**
     * The id of this request. Used to send back timestamps of when the request was applied.
     *
     * @generated from field: uint64 request_id = 1;
     */
    requestId: bigint;
    /**
     * The id of the soundfont to be deleted
     *
     * @generated from field: string soundfont_id = 2;
     */
    soundfontId: string;
    constructor(data?: PartialMessage<DeleteSoundfontRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.DeleteSoundfontRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSoundfontRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSoundfontRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSoundfontRequest;
    static equals(a: DeleteSoundfontRequest | PlainMessage<DeleteSoundfontRequest> | undefined, b: DeleteSoundfontRequest | PlainMessage<DeleteSoundfontRequest> | undefined): boolean;
}
/**
 * request feedback from the booster
 *
 * @generated from message audiotool.document.v1.engine.RequestFeedback
 */
export declare class RequestFeedback extends Message<RequestFeedback> {
    constructor(data?: PartialMessage<RequestFeedback>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.RequestFeedback";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestFeedback;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestFeedback;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestFeedback;
    static equals(a: RequestFeedback | PlainMessage<RequestFeedback> | undefined, b: RequestFeedback | PlainMessage<RequestFeedback> | undefined): boolean;
}
/**
 * request a portion of the arrangement to be rendered
 * faster-than-realtime
 *
 * @generated from message audiotool.document.v1.engine.OfflineRenderRequest
 */
export declare class OfflineRenderRequest extends Message<OfflineRenderRequest> {
    /**
     * beginning of portion to be rendered
     *
     * @generated from field: uint32 from_ticks = 1;
     */
    fromTicks: number;
    /**
     * end of portion to be rendered
     *
     * @generated from field: uint32 to_ticks = 2;
     */
    toTicks: number;
    constructor(data?: PartialMessage<OfflineRenderRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.OfflineRenderRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OfflineRenderRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OfflineRenderRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OfflineRenderRequest;
    static equals(a: OfflineRenderRequest | PlainMessage<OfflineRenderRequest> | undefined, b: OfflineRenderRequest | PlainMessage<OfflineRenderRequest> | undefined): boolean;
}
/**
 * request a portion of the arrangement to be rendered
 * faster-than-realtime
 *
 * @generated from message audiotool.document.v1.engine.BounceOutputRequest
 */
export declare class BounceOutputRequest extends Message<BounceOutputRequest> {
    /**
     * points to the device output we want to bounce ...
     *
     * @generated from field: audiotool.document.v1.Pointer output_pointer = 1;
     */
    outputPointer?: Pointer;
    /**
     * beginning of portion to be rendered
     *
     * @generated from field: uint32 from_ticks = 2;
     */
    fromTicks: number;
    /**
     * end of portion to be rendered
     *
     * @generated from field: uint32 to_ticks = 3;
     */
    toTicks: number;
    constructor(data?: PartialMessage<BounceOutputRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.BounceOutputRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BounceOutputRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BounceOutputRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BounceOutputRequest;
    static equals(a: BounceOutputRequest | PlainMessage<BounceOutputRequest> | undefined, b: BounceOutputRequest | PlainMessage<BounceOutputRequest> | undefined): boolean;
}
/**
 * request the binary state of a VST3 plugin
 *
 * @generated from message audiotool.document.v1.engine.RequestVST3PluginState
 */
export declare class RequestVST3PluginState extends Message<RequestVST3PluginState> {
    /**
     * the plugin id to be queried
     *
     * @generated from field: string plugin_id = 1;
     */
    pluginId: string;
    constructor(data?: PartialMessage<RequestVST3PluginState>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.RequestVST3PluginState";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestVST3PluginState;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestVST3PluginState;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestVST3PluginState;
    static equals(a: RequestVST3PluginState | PlainMessage<RequestVST3PluginState> | undefined, b: RequestVST3PluginState | PlainMessage<RequestVST3PluginState> | undefined): boolean;
}
/**
 * request re-opening the plugin window for the specified ID
 * will be ignored if window is open
 *
 * @generated from message audiotool.document.v1.engine.OpenPluginWindow
 */
export declare class OpenPluginWindow extends Message<OpenPluginWindow> {
    /**
     * the plugin id to be queried
     *
     * @generated from field: string plugin_id = 1;
     */
    pluginId: string;
    constructor(data?: PartialMessage<OpenPluginWindow>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.OpenPluginWindow";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenPluginWindow;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenPluginWindow;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenPluginWindow;
    static equals(a: OpenPluginWindow | PlainMessage<OpenPluginWindow> | undefined, b: OpenPluginWindow | PlainMessage<OpenPluginWindow> | undefined): boolean;
}
/**
 * a request to check whether the spitfire plugin is available ...
 * doesn't need any parameters
 *
 * @generated from message audiotool.document.v1.engine.RequestSpitfireLabsAvailability
 */
export declare class RequestSpitfireLabsAvailability extends Message<RequestSpitfireLabsAvailability> {
    constructor(data?: PartialMessage<RequestSpitfireLabsAvailability>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.RequestSpitfireLabsAvailability";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestSpitfireLabsAvailability;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestSpitfireLabsAvailability;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestSpitfireLabsAvailability;
    static equals(a: RequestSpitfireLabsAvailability | PlainMessage<RequestSpitfireLabsAvailability> | undefined, b: RequestSpitfireLabsAvailability | PlainMessage<RequestSpitfireLabsAvailability> | undefined): boolean;
}
/**
 * a request to the booster, to be sent in serialized form
 * over a websocket.
 * some actions have a response
 *
 * @generated from message audiotool.document.v1.engine.BoosterRequest
 */
export declare class BoosterRequest extends Message<BoosterRequest> {
    /**
     * booster request can be any of these
     *
     * @generated from oneof audiotool.document.v1.engine.BoosterRequest.action
     */
    action: {
        /**
         * a regular request
         * RESPONSE -> Response::TimestampResponse
         *
         * @generated from field: audiotool.document.v1.engine.Request request = 1;
         */
        value: Request;
        case: "request";
    } | {
        /**
         * load a sample to the native booster
         * RESPONSE -> None
         *
         * @generated from field: audiotool.document.v1.engine.LoadSampleRequest load_sample_request = 2;
         */
        value: LoadSampleRequest;
        case: "loadSampleRequest";
    } | {
        /**
         * delete a sample from the native booster
         * RESPONSE -> None
         *
         * @generated from field: audiotool.document.v1.engine.DeleteSampleRequest delete_sample_request = 3;
         */
        value: DeleteSampleRequest;
        case: "deleteSampleRequest";
    } | {
        /**
         * request feedback from engine
         * RESPONSE -> Response::Feedback
         *
         * @generated from field: audiotool.document.v1.engine.RequestFeedback request_feedback = 4;
         */
        value: RequestFeedback;
        case: "requestFeedback";
    } | {
        /**
         * request faster-than-realtime rendering
         * RESPONSE -> RenderedAudioResponse
         *
         * @generated from field: audiotool.document.v1.engine.OfflineRenderRequest offline_render_request = 5;
         */
        value: OfflineRenderRequest;
        case: "offlineRenderRequest";
    } | {
        /**
         * request the state of a VST3 plugin
         * RESPONSE -> Response::VST3PluginState
         *
         * @generated from field: audiotool.document.v1.engine.RequestVST3PluginState request_vst3_plugin_state = 6;
         */
        value: RequestVST3PluginState;
        case: "requestVst3PluginState";
    } | {
        /**
         * load a plugin state
         *
         * @generated from field: audiotool.document.v1.engine.VST3PluginState load_plugin_state = 7;
         */
        value: VST3PluginState;
        case: "loadPluginState";
    } | {
        /**
         * request faster-than-realtime rendering with a connetion cue
         * RESPONSE -> BouncedOutputAudioResponse
         *
         * @generated from field: audiotool.document.v1.engine.BounceOutputRequest bounce_output_request = 8;
         */
        value: BounceOutputRequest;
        case: "bounceOutputRequest";
    } | {
        /**
         * request whether spitfire labs is currently available
         *
         * Note that this flag can change over the lifetime of a session. On
         * startup it might report false even though the spitfire plugin will
         * become available later. Also if the user moves the plugin somewhere else,
         * it might become false again.
         *
         * The user is able to create spitfire plugins as long as this flag is true.
         * If it becomes false, existing instance of the plugin keep working, but no
         * new instances can be created.
         *
         * @generated from field: audiotool.document.v1.engine.RequestSpitfireLabsAvailability labs_available = 9;
         */
        value: RequestSpitfireLabsAvailability;
        case: "labsAvailable";
    } | {
        /**
         * triggers opening the vst3 plugin window if it's not open yet
         * RESPONSE: none
         *
         * @generated from field: audiotool.document.v1.engine.OpenPluginWindow open_plugin_window = 10;
         */
        value: OpenPluginWindow;
        case: "openPluginWindow";
    } | {
        /**
         * load a soundfont to the native booster
         * RESPONSE -> None
         *
         * @generated from field: audiotool.document.v1.engine.CreateSoundfontRequest create_soundfont_request = 11;
         */
        value: CreateSoundfontRequest;
        case: "createSoundfontRequest";
    } | {
        /**
         * unload a soundfont from the native booster
         * RESPONSE -> None
         *
         * @generated from field: audiotool.document.v1.engine.DeleteSoundfontRequest delete_soundfont_request = 12;
         */
        value: DeleteSoundfontRequest;
        case: "deleteSoundfontRequest";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<BoosterRequest>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.BoosterRequest";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoosterRequest;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoosterRequest;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoosterRequest;
    static equals(a: BoosterRequest | PlainMessage<BoosterRequest> | undefined, b: BoosterRequest | PlainMessage<BoosterRequest> | undefined): boolean;
}
/**
 * By default, if an automated parameter has an automation track, the automation track
 * will take precedence over the value of the parameter field, even if the parameter is updated.
 *
 * To hear the parameter as it's written at the field, send this message with a pointer to the field.
 * This will cause the engine to play back the field value and ignore the automation track until the
 * next play or pause event.
 *
 * @generated from message audiotool.document.v1.engine.UnlinkAutomatableParameter
 */
export declare class UnlinkAutomatableParameter extends Message<UnlinkAutomatableParameter> {
    /**
     * The parameter to unlink. This must point to field of target type AutomatableParameter, but
     * that is never validated.
     *
     * @generated from field: audiotool.document.v1.Pointer parameter = 1;
     */
    parameter?: Pointer;
    constructor(data?: PartialMessage<UnlinkAutomatableParameter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.UnlinkAutomatableParameter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnlinkAutomatableParameter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnlinkAutomatableParameter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnlinkAutomatableParameter;
    static equals(a: UnlinkAutomatableParameter | PlainMessage<UnlinkAutomatableParameter> | undefined, b: UnlinkAutomatableParameter | PlainMessage<UnlinkAutomatableParameter> | undefined): boolean;
}
/**
 * in some situations (i.e. when the first point/region on an otherwise empty automation track
 * is created while playing), we need to explicitly link a parameter
 *
 * @generated from message audiotool.document.v1.engine.LinkAutomatableParameter
 */
export declare class LinkAutomatableParameter extends Message<LinkAutomatableParameter> {
    /**
     * The parameter to unlink. This must point to field of target type AutomatableParameter, but
     * that is never validated.
     *
     * @generated from field: audiotool.document.v1.Pointer parameter = 1;
     */
    parameter?: Pointer;
    constructor(data?: PartialMessage<LinkAutomatableParameter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.engine.LinkAutomatableParameter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkAutomatableParameter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkAutomatableParameter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkAutomatableParameter;
    static equals(a: LinkAutomatableParameter | PlainMessage<LinkAutomatableParameter> | undefined, b: LinkAutomatableParameter | PlainMessage<LinkAutomatableParameter> | undefined): boolean;
}
