import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';
import { Pointer } from '../../../pointer_pb.js';

/**
 * The Rasselbock is a multi-purpose effects device that has patterns
 * that can turn different modules on or off over time.
 *
 * The patterns can toggle a variety of effects, plus a few "channels"
 * that can be toggled  audio to a different output if enabled.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.Rasselbock
 */
export declare class Rasselbock extends Message<Rasselbock> {
    /**
     * Uniquely identifies this Rasselbock
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Empty fields which RasselbockPatterns can point to. At most one pattern
     * can point to a specific element in this list.
     *
     * @generated from field: repeated audiotool.document.v1.Empty pattern_slots = 5;
     */
    patternSlots: Empty[];
    /**
     * The index of the currently selected pattern. Determines which pattern the Rasselbock
     * currently plays back, unless a pattern track is connected to it.
     *
     * @generated from field: uint32 pattern_index = 6;
     */
    patternIndex: number;
    /**
     * Each rasselbock channel's configuration. Channels configure the re-routing
     * of audio to a different output.
     *
     * @generated from field: repeated audiotool.document.v1.entity.rasselbock.v1.RasselbockChannel channel_configs = 7;
     */
    channelConfigs: RasselbockChannel[];
    /**
     * The shuffle effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockShuffle shuffle_config = 8;
     */
    shuffleConfig?: RasselbockShuffle;
    /**
     * The speed effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockSpeed speed_config = 9;
     */
    speedConfig?: RasselbockSpeed;
    /**
     * The stop effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockStop stop_config = 10;
     */
    stopConfig?: RasselbockStop;
    /**
     * The gate effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockGate gate_config = 11;
     */
    gateConfig?: RasselbockGate;
    /**
     * The stutter effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockStutter stutter_config = 12;
     */
    stutterConfig?: RasselbockStutter;
    /**
     * The scratch effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockScratch scratch_config = 13;
     */
    scratchConfig?: RasselbockScratch;
    /**
     * The reverse effect's configuration.
     *
     * @generated from field: audiotool.document.v1.entity.rasselbock.v1.RasselbockReverse reverse_config = 14;
     */
    reverseConfig?: RasselbockReverse;
    /**
     * Single Input.
     *
     * @generated from field: audiotool.document.v1.Empty audio_input = 15;
     */
    audioInput?: Empty;
    /**
     * The master output that doesn't go through any channels
     *
     * @generated from field: audiotool.document.v1.Empty master_output = 16;
     */
    masterOutput?: Empty;
    /**
     * Whether the device is active or not. When is_active=false,
     * audio signals bypass the effects and go directly to the main output.
     * The secondary channels are quiet.
     *
     * @generated from field: bool is_active = 17;
     */
    isActive: boolean;
    constructor(data?: PartialMessage<Rasselbock>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.Rasselbock";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rasselbock;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rasselbock;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rasselbock;
    static equals(a: Rasselbock | PlainMessage<Rasselbock> | undefined, b: Rasselbock | PlainMessage<Rasselbock> | undefined): boolean;
}
/**
 * A Rasselbock pattern, which turns effects and channels on or off
 * for every pattern step.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockPattern
 */
export declare class RasselbockPattern extends Message<RasselbockPattern> {
    /**
     * Uniquely identifies this RasselbockPattern
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The pattern slot in the Rasselbock that this pattern belongs to.
     *
     * @generated from field: audiotool.document.v1.Pointer slot = 2;
     */
    slot?: Pointer;
    /**
     * Length of the pattern in steps. One step is always 1/64th of a semibreve long.
     *
     * @generated from field: int32 length = 3;
     */
    length: number;
    /**
     * Store of the channel pattern splitting the audio to secondary audio outputs.
     *
     * @generated from field: repeated audiotool.document.v1.entity.rasselbock.v1.RasselbockRowPattern channel_patterns = 4;
     */
    channelPatterns: RasselbockRowPattern[];
    /**
     * This list defines the order in which the effects are applied in this pattern.
     * The i-th element defines the "magnitude" of that effect. The audio engine orders
     * the list in magnitudes, and takes the original indices as orders.
     *
     * - Example:         [0.5, 0.2, 10]
     * - Sorted to:       [0.2, 0.5, 10]
     * - => Effect order: [  1,   0,  2]
     *
     * @generated from field: repeated float effect_order = 5;
     */
    effectOrder: number[];
    /**
     * Storage of the step pattern of each effect row. The order of effects is independent of effect_order
     * as follows:
     * * 0: Shuffle
     * * 1: Speed
     * * 2: Stop
     * * 3: Gate
     * * 4: Stutter
     * * 5: Scratch
     * * 6: Reverse
     *
     * @generated from field: repeated audiotool.document.v1.entity.rasselbock.v1.RasselbockRowPattern effect_patterns = 6;
     */
    effectPatterns: RasselbockRowPattern[];
    /**
     * Every pattern can have a groove applied individually.
     *
     * @generated from field: audiotool.document.v1.Pointer groove = 7;
     */
    groove?: Pointer;
    constructor(data?: PartialMessage<RasselbockPattern>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockPattern";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockPattern;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockPattern;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockPattern;
    static equals(a: RasselbockPattern | PlainMessage<RasselbockPattern> | undefined, b: RasselbockPattern | PlainMessage<RasselbockPattern> | undefined): boolean;
}
/**
 * Holds the state of a pattern for a single channel or effect.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockRowPattern
 */
export declare class RasselbockRowPattern extends Message<RasselbockRowPattern> {
    /**
     * A pattern is made up of 256 steps, each representing 1/64th of a semibreve.
     *
     * @generated from field: repeated audiotool.document.v1.entity.rasselbock.v1.RasselbockStep steps = 1;
     */
    steps: RasselbockStep[];
    constructor(data?: PartialMessage<RasselbockRowPattern>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockRowPattern";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockRowPattern;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockRowPattern;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockRowPattern;
    static equals(a: RasselbockRowPattern | PlainMessage<RasselbockRowPattern> | undefined, b: RasselbockRowPattern | PlainMessage<RasselbockRowPattern> | undefined): boolean;
}
/**
 * Holds the state for an individual pattern step. Visually/acoustically,
 * a step can have more than 1 1/64th of a duration. Steps like these
 * are represented as multiple consecutive steps that each have is_on=true
 * and is_end=false. Multiple consecutive steps with is_on=true and is_end=true
 * result in individual consecutive 1/64th-long steps.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockStep
 */
export declare class RasselbockStep extends Message<RasselbockStep> {
    /**
     * whether the step is on.
     *
     * @generated from field: bool is_on = 1;
     */
    isOn: boolean;
    /**
     * whether the step is an end of a region (multiple steps connected)
     *
     * @generated from field: bool is_end = 2;
     */
    isEnd: boolean;
    constructor(data?: PartialMessage<RasselbockStep>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockStep";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockStep;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockStep;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockStep;
    static equals(a: RasselbockStep | PlainMessage<RasselbockStep> | undefined, b: RasselbockStep | PlainMessage<RasselbockStep> | undefined): boolean;
}
/**
 * Holds the modulation and output socket of an individual channel.
 *
 * A channel is a row that corresponds to a secondary output socket.
 * Patterns on that row turn the output socket on or off; if on,
 * the output socket receives the audio of the rasselbock after
 * all effects have been applied. If no effect is active for the current step,
 * the plain input signal is sent to the output.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockChannel
 */
export declare class RasselbockChannel extends Message<RasselbockChannel> {
    /**
     * Output gain of this channel. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 1;
     */
    gain: number;
    /**
     * Panning of the channel. -1 is fully left, 0 is centered (unchanged), 1 is fully right.
     *
     * @generated from field: float panning = 2;
     */
    panning: number;
    /**
     * Controls the mix between the incoming and the effect signal. 0 ("dry") means 0% effect
     * applied, 1 ("wet") means 100% effect applied; values between mixes the two linearly.
     *
     * The exact mixing is determined by the
     *
     * @generated from field: float mix = 3;
     */
    mix: number;
    /**
     * How the dry signal is mixed with the effect signal according to the mix parameter:
     * 0: invalid
     * 1: linear       the output is slightly quieter if mix factor is 0.5
     * 2: equal-power  the output is equal when the mix factor is 0.5
     *
     * @generated from field: int32 mix_mode = 4;
     */
    mixMode: number;
    /**
     * If d=true, the audio output of this channel is muted.
     *
     * @generated from field: bool is_muted = 5;
     */
    isMuted: boolean;
    /**
     * is_soloed=true mutes all channels except those that have is_soloed=true.
     *
     * @generated from field: bool is_soloed = 6;
     */
    isSoloed: boolean;
    /**
     * Individual channel output
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 7;
     */
    audioOutput?: Empty;
    constructor(data?: PartialMessage<RasselbockChannel>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockChannel";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockChannel;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockChannel;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockChannel;
    static equals(a: RasselbockChannel | PlainMessage<RasselbockChannel> | undefined, b: RasselbockChannel | PlainMessage<RasselbockChannel> | undefined): boolean;
}
/**
 * Holds the configuration for the rasselbock shuffle effect.
 *
 * The shuffle effect writes all incoming signal on a delay line, and plays
 * the delay line back in segments (sized by interval_index) at random positions quantized by the
 * interval_index parameter.
 *
 * The delay line is cleared and built up from scratch every time a step starts, and the random segment
 * is only picked from the already written to part of the delay line. This means the first
 * interval heard when a step starts will always be the incoming signal, and the longer the step lasts,
 * the more random the audio will become.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockShuffle
 */
export declare class RasselbockShuffle extends Message<RasselbockShuffle> {
    /**
     * The size of the interval picked randomly from the delay line.
     * - 0:  invalid
     * - 1:  1/64 bars
     * - 2:  1/32 bars
     * - 3:  1/16 bars
     * - 4:  1/8  bars
     *
     * @generated from field: uint32 interval_index = 1;
     */
    intervalIndex: number;
    /**
     * The seed for the random number generator. Determines the order in which the intervals are picked.
     *
     * @generated from field: int32 seed = 2;
     */
    seed: number;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 3;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 4;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockShuffle>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockShuffle";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockShuffle;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockShuffle;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockShuffle;
    static equals(a: RasselbockShuffle | PlainMessage<RasselbockShuffle> | undefined, b: RasselbockShuffle | PlainMessage<RasselbockShuffle> | undefined): boolean;
}
/**
 * The configuration for the rasselbock speed effect.
 * The speed effect writes the incoming signal to a delay line, and plays it back at a slower speed.
 * When a step starts, the delay line is cleared and started fresh.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockSpeed
 */
export declare class RasselbockSpeed extends Message<RasselbockSpeed> {
    /**
     * The speed of the played back audio. 1/2 means half the speed compared to the incoming signal.
     * - 0:  invalid
     * - 1:  1/16
     * - 2:  1/8
     * - 3:  1/6
     * - 4:  1/4
     * - 5:  1/3
     * - 6:  1/2
     * - 7:  2/3
     * - 8:  3/4
     *
     * @generated from field: uint32 speed_ratio_index = 1;
     */
    speedRatioIndex: number;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 2;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 3;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockSpeed>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockSpeed";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockSpeed;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockSpeed;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockSpeed;
    static equals(a: RasselbockSpeed | PlainMessage<RasselbockSpeed> | undefined, b: RasselbockSpeed | PlainMessage<RasselbockSpeed> | undefined): boolean;
}
/**
 * The configuration for the rasselbock stop effect.
 * The stop effect emulates the effect of a stop button on a turntable.
 *
 * The stop effect writes the incoming signal to a delay line, which is then played back
 * at the normal speed when the step starts, and gradually slows down as the step progresses.
 * When a step starts, the delay line is cleared, the new incoming signal is written to it,
 * and the speed is reset to the normal speed, to slow down again.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockStop
 */
export declare class RasselbockStop extends Message<RasselbockStop> {
    /**
     * How long it takes for the audio to come to a stop.
     * - 0:  invalid
     * - 1:  1/64 bars
     * - 2:  1/32 bars
     * - 3:  1/16 bars
     * - 4:  1/8  bars
     * - 5:  1/4  bars
     * - 6:  1/2  bars
     * - 7:  1/1  bars
     *
     * @generated from field: uint32 duration_index = 1;
     */
    durationIndex: number;
    /**
     * If does_spinback=true, the audio will ramp back to the normal speed after the stop, gradually
     * such that the original speed is reached at the end of the step.
     *
     * @generated from field: bool does_spinback = 2;
     */
    doesSpinback: boolean;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 3;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 4;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockStop>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockStop";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockStop;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockStop;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockStop;
    static equals(a: RasselbockStop | PlainMessage<RasselbockStop> | undefined, b: RasselbockStop | PlainMessage<RasselbockStop> | undefined): boolean;
}
/**
 * The configuration for the rasselbock gate effect.
 * The gate effect "gates" the audio (meaning, turns it on and off) in intervals
 * defined by the interval_duration_index parameter.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockGate
 */
export declare class RasselbockGate extends Message<RasselbockGate> {
    /**
     * The duration of the interval during which the audio is turned on and off.
     * 0:  invalid
     * 1:  1/64 bars
     * 2:  1/32 bars
     * 3:  1/16 bars
     * 4:  1/8  bars
     * 5:  1/4  bars
     * 6:  1/2  bars
     * 7:  1/1  bars
     *
     * @generated from field: uint32 interval_duration_index = 1;
     */
    intervalDurationIndex: number;
    /**
     * The percentage within the interval during which the audio is turned on.
     *
     * @generated from field: float duration_factor = 2;
     */
    durationFactor: number;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 3;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 4;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockGate>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockGate";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockGate;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockGate;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockGate;
    static equals(a: RasselbockGate | PlainMessage<RasselbockGate> | undefined, b: RasselbockGate | PlainMessage<RasselbockGate> | undefined): boolean;
}
/**
 * The configuration for the rasselbock stutter effect.
 * The stutter effect passed the signal through for a given interval duration while writing
 * it to a delay line. After that interval has passed, it plays back that delay line
 * again and again, optionally while changing the pitch every repetition interval.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockStutter
 */
export declare class RasselbockStutter extends Message<RasselbockStutter> {
    /**
     * The duration of the interval during which the signal is passed through.
     * - 0:  invalid
     * - 1:  1/256 bars
     * - 2:  1/128 bars
     * - 3:  1/64 bars
     * - 4:  1/32 bars
     * - 5:  1/16 bars
     * - 6:  1/8  bars
     * - 7:  1/4  bars
     * - 8:  1/2  bars
     *
     * @generated from field: uint32 interval_duration_index = 1;
     */
    intervalDurationIndex: number;
    /**
     * Out of the interval duration, how long the audio is audible for every interval.
     *
     * @generated from field: float scale_factor = 2;
     */
    scaleFactor: number;
    /**
     * The pitch change in semitones per repetition interval. -12/+12 semitones is equivalent to +/- 1 octave.
     *
     * @generated from field: float pitch_semitones = 3;
     */
    pitchSemitones: number;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 4;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 5;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockStutter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockStutter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockStutter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockStutter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockStutter;
    static equals(a: RasselbockStutter | PlainMessage<RasselbockStutter> | undefined, b: RasselbockStutter | PlainMessage<RasselbockStutter> | undefined): boolean;
}
/**
 * The configuration for the rasselbock scratch effect.
 * The scratch effect writes the incoming signal to a delay line which it plays back
 * with a speed modulated by an LFO.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockScratch
 */
export declare class RasselbockScratch extends Message<RasselbockScratch> {
    /**
     * The rate of the oscillator controlling the playback speed, and the length of the
     * sample that's written to the delay line. The effect will repeat the audio
     * after this duration has passed.
     * - 0:  invalid
     * - 1:  1/64 bars
     * - 2:  1/32 bars
     * - 3:  1/16 bars
     * - 4:  1/8  bars
     * - 5:  1/6  bars
     * - 6:  1/4  bars
     * - 7:   1/3  bars
     * - 8:  1/2  bars
     * - 9:   2/3  bars
     * - 10: 3/4  bars
     * - 11: 1/1  bars
     *
     * @generated from field: int32 rate_bars = 1;
     */
    rateBars: number;
    /**
     * Multiplied with the LFO and the modulation offset to get the final speed.
     * Influences the difference between the highest and lowest speed of the sample.
     *
     * @generated from field: float modulation_depth = 2;
     */
    modulationDepth: number;
    /**
     * The "base" speed from which the modulation changes.
     * Multiplied with the LFO and the modulation depth to get the final speed.
     *
     * @generated from field: float modulation_offset = 3;
     */
    modulationOffset: number;
    /**
     * The shape of the modulation curve, is repeated in intervals of the rate_bars parameter.
     * - 0:  invalid
     * - 1:  Sinus
     * - 2:  Triangle
     * - 3:  Sawtooth Down
     * - 4:  Sawtooth Up
     *
     * Note that the wave is phase offset to make sure the sample always plays slower before it plays faster,
     * so the delay line always has audio to play back.
     *
     * @generated from field: uint32 modulation_shape_index = 4;
     */
    modulationShapeIndex: number;
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 5;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 6;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockScratch>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockScratch";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockScratch;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockScratch;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockScratch;
    static equals(a: RasselbockScratch | PlainMessage<RasselbockScratch> | undefined, b: RasselbockScratch | PlainMessage<RasselbockScratch> | undefined): boolean;
}
/**
 * Configuration for the rasselbock reverse effect.
 * The reverse effect writes the incoming signal to the delay line during the first half of every step,
 * then plays it back in reverse during the second half.
 *
 * @generated from message audiotool.document.v1.entity.rasselbock.v1.RasselbockReverse
 */
export declare class RasselbockReverse extends Message<RasselbockReverse> {
    /**
     * If is_muted=true, this effect is bypassed.
     *
     * @generated from field: bool is_muted = 1;
     */
    isMuted: boolean;
    /**
     * If is_soloed=true, effects that don't have is_soloed=true are bypassed.
     *
     * @generated from field: bool is_soloed = 2;
     */
    isSoloed: boolean;
    constructor(data?: PartialMessage<RasselbockReverse>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.rasselbock.v1.RasselbockReverse";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RasselbockReverse;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RasselbockReverse;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RasselbockReverse;
    static equals(a: RasselbockReverse | PlainMessage<RasselbockReverse> | undefined, b: RasselbockReverse | PlainMessage<RasselbockReverse> | undefined): boolean;
}
