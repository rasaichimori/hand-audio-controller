import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';

/**
 * The Pulsar delay is an advanced delay effect.
 *
 * The pre-delay allows adjusting the delay time for the left and right channel independently,
 * and further allows panning the left/right channel for the pre-delay independently.
 *
 * The main delay controls allow applying a filter, setting sync and unsynced delay times, and applying
 * a LFO to modulate the delay amount continuously.
 *
 * @generated from message audiotool.document.v1.entity.pulsar.v1.Pulsar
 */
export declare class Pulsar extends Message<Pulsar> {
    /**
     * Uniquely identifies this pulsar.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Semibreve (music time) duration of the pre-delay of the left channel.
     * Is added with the milliseconds delay time internally to calculate the actual pre-delay time.
     * - 0: invalid
     * - 1:  0    semibreve
     * - 2:  1/16 semibreve
     * - 3:  1/12 semibreve
     * - 4:  1/8  semibreve
     * - 5:  1/6  semibreve
     * - 6:  3/16 semibreve
     * - 7:  1/4  semibreve
     * - 8:  5/16 semibreve
     * - 9:  1/3  semibreve
     * - 10:  3/8  semibreve
     * - 11: 7/16 semibreve
     * - 12: 1/2  semibreve
     *
     * @generated from field: uint32 pre_delay_left_time_semibreve_index = 5;
     */
    preDelayLeftTimeSemibreveIndex: number;
    /**
     * Milliseconds duration of the pre-delay of the left channel. Added to pre_delay_left_time_semibreve internally.
     *
     * @generated from field: float pre_delay_left_time_ms = 6;
     */
    preDelayLeftTimeMs: number;
    /**
     * Panning of the left channel of the pre-delay. This value controls the panning of the delayed signal.
     * -1 is fully left (unchanged), 0 is centered, 1 is fully right.
     *
     * @generated from field: float pre_delay_left_panning = 7;
     */
    preDelayLeftPanning: number;
    /**
     * Semibreve (music time) duration of the pre-delay of the right channel.
     * Is added with the milliseconds delay time internally to calculate the actual pre-delay time.
     * - 0: invalid
     * - 1:  0/1  semibreve
     * - 2:  1/16 semibreve
     * - 3:  1/12 semibreve
     * - 4:  1/8  semibreve
     * - 5:  1/6  semibreve
     * - 6:  3/16 semibreve
     * - 7:  1/4  semibreve
     * - 8:  5/16 semibreve
     * - 9:  1/3  semibreve
     * - 10: 3/8  semibreve
     * - 11: 7/16 semibreve
     * - 12: 1/2  semibreve
     *
     * @generated from field: uint32 pre_delay_right_time_semibreve_index = 8;
     */
    preDelayRightTimeSemibreveIndex: number;
    /**
     * Milliseconds duration of the pre-delay of the right channel. Added to pre_delay_right_time_semibreve internally.
     *
     * @generated from field: float pre_delay_right_time_ms = 9;
     */
    preDelayRightTimeMs: number;
    /**
     * Panning of the right channel of the pre-delay. This value controls the panning of the delayed signal.
     * -1 is fully left, 0 is centered, 1 is fully right (unchanged).
     *
     * @generated from field: float pre_delay_right_panning = 10;
     */
    preDelayRightPanning: number;
    /**
     * Semibreve (music time) duration of the main delay feedback.
     * Is added with the milliseconds delay time internally to calculate the actual interval time
     * - 0: invalid
     * - 1:  0    semibreve
     * - 2:  1/16 semibreve
     * - 3:  1/12 semibreve
     * - 4:  1/8  semibreve
     * - 5:  1/6  semibreve
     * - 6:  3/16 semibreve
     * - 7:  1/4  semibreve
     * - 8:  5/16 semibreve
     * - 9:  1/3  semibreve
     * - 10:  3/8  semibreve
     * - 11: 7/16 semibreve
     * - 12: 1/2  semibreve
     *
     * @generated from field: uint32 feedback_delay_time_semibreve_index = 11;
     */
    feedbackDelayTimeSemibreveIndex: number;
    /**
     * Milliseconds duration of the main delay feedback. Added to feedback_delay_time_semibreve internally.
     *
     * @generated from field: float feedback_delay_time_ms = 12;
     */
    feedbackDelayTimeMs: number;
    /**
     * The delay-time modulating LFO's speed in Hz.
     *
     * @generated from field: float lfo_speed_hz = 13;
     */
    lfoSpeedHz: number;
    /**
     * The delay-time modulating LFO's depth in milliseconds.
     *
     * @generated from field: float lfo_modulation_depth_ms = 14;
     */
    lfoModulationDepthMs: number;
    /**
     * The feedback factor of the main delay.
     *
     * @generated from field: float feedback_factor = 15;
     */
    feedbackFactor: number;
    /**
     * This controls to what extend the signal swaps left/right channel on every feedback cycle:
     * 1: fully swapped,
     * 0.5: turned into mono
     * 0: unmodified
     *
     * @generated from field: float stereo_cross_factor = 16;
     */
    stereoCrossFactor: number;
    /**
     * The min frequency cutoff for the highpass filter applied to the feedback signal.
     *
     * @generated from field: float filter_min_hz = 17;
     */
    filterMinHz: number;
    /**
     * The max frequency cutoff for the lowpass filter applied to the feedback signal.
     *
     * @generated from field: float filter_max_hz = 18;
     */
    filterMaxHz: number;
    /**
     * The gain applied to the (unprocessed) incoming signal that's added to the output mix. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float dry_gain = 19;
     */
    dryGain: number;
    /**
     * The gain applied to the (processed) delayed signal that's added to the output mix. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float wet_gain = 20;
     */
    wetGain: number;
    /**
     * Whether the device is active or not. When is_active=false, audio signal bypasses the device.
     *
     * @generated from field: bool is_active = 21;
     */
    isActive: boolean;
    /**
     * Single Input.
     *
     * @generated from field: audiotool.document.v1.Empty audio_input = 22;
     */
    audioInput?: Empty;
    /**
     * Single Output.
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 23;
     */
    audioOutput?: Empty;
    constructor(data?: PartialMessage<Pulsar>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulsar.v1.Pulsar";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pulsar;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pulsar;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pulsar;
    static equals(a: Pulsar | PlainMessage<Pulsar> | undefined, b: Pulsar | PlainMessage<Pulsar> | undefined): boolean;
}
