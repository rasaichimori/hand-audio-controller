import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Empty } from '../../../empty_pb.js';
import { Pointer } from '../../../pointer_pb.js';

/**
 * The Pulverisateur is a subtractive synth with 3 regular oscillators,
 * a noise generator, a keyboard-tracking envelope filter, an ADSR envelope,
 * and an LFO. It also features an audio input that can act as another source of
 * audio like the oscillators.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.Pulverisateur
 */
export declare class Pulverisateur extends Message<Pulverisateur> {
    /**
     * Unique id for this entity
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Notes input
     *
     * @generated from field: audiotool.document.v1.Empty notes_input = 5;
     */
    notesInput?: Empty;
    /**
     * Audio input
     *
     * @generated from field: audiotool.document.v1.Empty audio_input = 6;
     */
    audioInput?: Empty;
    /**
     * Audio output
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 7;
     */
    audioOutput?: Empty;
    /**
     * The main output gain of the device. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 8;
     */
    gain: number;
    /**
     * Oscillator A
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorA oscillator_a = 9;
     */
    oscillatorA?: PulverisateurOscillatorA;
    /**
     * Oscillator B
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorB oscillator_b = 10;
     */
    oscillatorB?: PulverisateurOscillatorB;
    /**
     * Oscillator C
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorC oscillator_c = 11;
     */
    oscillatorC?: PulverisateurOscillatorC;
    /**
     * Noise Oscillator
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurNoise noise = 12;
     */
    noise?: PulverisateurNoise;
    /**
     * Audio Input Section
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAudio audio = 13;
     */
    audio?: PulverisateurAudio;
    /**
     * Filter
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilter filter = 14;
     */
    filter?: PulverisateurFilter;
    /**
     * LFO
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurLfo lfo = 15;
     */
    lfo?: PulverisateurLfo;
    /**
     * Filter Envelope
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilterEnvelope filter_envelope = 16;
     */
    filterEnvelope?: PulverisateurFilterEnvelope;
    /**
     * Amplitude Envelope
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAmplitudeEnvelope amplitude_envelope = 18;
     */
    amplitudeEnvelope?: PulverisateurAmplitudeEnvelope;
    /**
     * The amount of time pitch change for a new note takes
     *
     * @generated from field: float glide_time_ms = 19;
     */
    glideTimeMs: number;
    /**
     * Tuning of the pitch of all notes of the synth by a number of semitones.
     *
     * @generated from field: float tune_semitones = 20;
     */
    tuneSemitones: number;
    /**
     * Selects the play mode of the synthesizer.
     * - 0: invalid
     * - 1: Mono         At most once note is played at once with slight overlap during release. An incoming note
     *                 cuts already playing notes.
     * - 2: Polyphonic   Multiple notes/chords can be played simultaneously.
     *
     * @generated from field: uint32 play_mode_index = 21;
     */
    playModeIndex: number;
    /**
     * Reference to the microtuning.
     *
     * @generated from field: audiotool.document.v1.Pointer micro_tuning = 22;
     */
    microTuning?: Pointer;
    /**
     * Whether the pulverisateur is active or not. When is_active=false no audio is produced by the pulverisateur, including audio passed
     * through the audio input.
     *
     * @generated from field: bool is_active = 23;
     */
    isActive: boolean;
    constructor(data?: PartialMessage<Pulverisateur>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.Pulverisateur";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pulverisateur;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pulverisateur;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pulverisateur;
    static equals(a: Pulverisateur | PlainMessage<Pulverisateur> | undefined, b: Pulverisateur | PlainMessage<Pulverisateur> | undefined): boolean;
}
/**
 * The Pulverisateur's first oscillator.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorA
 */
export declare class PulverisateurOscillatorA extends Message<PulverisateurOscillatorA> {
    /**
     * Channel object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel channel = 1;
     */
    channel?: PulverisateurChannel;
    /**
     * Oscillator object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillator oscillator = 2;
     */
    oscillator?: PulverisateurOscillator;
    constructor(data?: PartialMessage<PulverisateurOscillatorA>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorA";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurOscillatorA;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurOscillatorA;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurOscillatorA;
    static equals(a: PulverisateurOscillatorA | PlainMessage<PulverisateurOscillatorA> | undefined, b: PulverisateurOscillatorA | PlainMessage<PulverisateurOscillatorA> | undefined): boolean;
}
/**
 * The Pulverisateur's second oscillator. Same as the first one, but can be synced to the first one's phase.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorB
 */
export declare class PulverisateurOscillatorB extends Message<PulverisateurOscillatorB> {
    /**
     * Channel object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel channel = 1;
     */
    channel?: PulverisateurChannel;
    /**
     * Oscillator object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillator oscillator = 2;
     */
    oscillator?: PulverisateurOscillator;
    /**
     * If this is true, then whenever oscillator A's phase restarts, oscillator B's phase is restarted as well.
     *
     * @generated from field: bool hard_sync_to_oscillator_a = 3;
     */
    hardSyncToOscillatorA: boolean;
    constructor(data?: PartialMessage<PulverisateurOscillatorB>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorB";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurOscillatorB;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurOscillatorB;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurOscillatorB;
    static equals(a: PulverisateurOscillatorB | PlainMessage<PulverisateurOscillatorB> | undefined, b: PulverisateurOscillatorB | PlainMessage<PulverisateurOscillatorB> | undefined): boolean;
}
/**
 * The Pulverisateur's third oscillator. Same as the first one, but can be tracked by the keyboard.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorC
 */
export declare class PulverisateurOscillatorC extends Message<PulverisateurOscillatorC> {
    /**
     * Channel object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel channel = 1;
     */
    channel?: PulverisateurChannel;
    /**
     * Oscillator object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillator oscillator = 2;
     */
    oscillator?: PulverisateurOscillator;
    /**
     * Whether this oscillator's pitch is tracked by the keyboard.
     * If does_track_keyboard is off, then the oscillator plays as if every incoming note was a C4/midi 60.
     * If it's on, it behaves the same as oscillator A & B.
     *
     * @generated from field: bool does_track_keyboard = 3;
     */
    doesTrackKeyboard: boolean;
    constructor(data?: PartialMessage<PulverisateurOscillatorC>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillatorC";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurOscillatorC;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurOscillatorC;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurOscillatorC;
    static equals(a: PulverisateurOscillatorC | PlainMessage<PulverisateurOscillatorC> | undefined, b: PulverisateurOscillatorC | PlainMessage<PulverisateurOscillatorC> | undefined): boolean;
}
/**
 * The Pulverisateur's noise generator.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurNoise
 */
export declare class PulverisateurNoise extends Message<PulverisateurNoise> {
    /**
     * Channel object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel channel = 1;
     */
    channel?: PulverisateurChannel;
    /**
     * Color of noise. Meaning of values:
     * - 0:    brown noise
     * - 0.2:  pink noise
     * - 0.5:  white noise
     * - 0.8:  blue noise
     * - 1:    purple noise
     *
     * Values between any two of these linearly mix the two colors.
     *
     * @generated from field: float color = 2;
     */
    color: number;
    constructor(data?: PartialMessage<PulverisateurNoise>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurNoise";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurNoise;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurNoise;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurNoise;
    static equals(a: PulverisateurNoise | PlainMessage<PulverisateurNoise> | undefined, b: PulverisateurNoise | PlainMessage<PulverisateurNoise> | undefined): boolean;
}
/**
 * Data structure for Pulverisateur's audio input channel.
 * Audio connected to this input passes through the Pulverisateur as though it were one of the oscillators.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAudio
 */
export declare class PulverisateurAudio extends Message<PulverisateurAudio> {
    /**
     * Channel object containing common controls
     *
     * @generated from field: audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel channel = 1;
     */
    channel?: PulverisateurChannel;
    /**
     * The drive parameter applies some distortion to the incoming signal similar to the waveshaper device.
     *
     * @generated from field: float drive = 2;
     */
    drive: number;
    constructor(data?: PartialMessage<PulverisateurAudio>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAudio";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurAudio;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurAudio;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurAudio;
    static equals(a: PulverisateurAudio | PlainMessage<PulverisateurAudio> | undefined, b: PulverisateurAudio | PlainMessage<PulverisateurAudio> | undefined): boolean;
}
/**
 * The Pulverisateur's filter. The filter can be set to track the keyboard.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilter
 */
export declare class PulverisateurFilter extends Message<PulverisateurFilter> {
    /**
     * Filter mode.
     * - 0: invalid
     * - 1: "LP/LP"  Two low pass filters in series
     * - 2: "LP/HP"  A low and a high pass filter, run in parallel and added together, creating something like a notch filter.
     *
     * @generated from field: uint32 mode_index = 1;
     */
    modeIndex: number;
    /**
     * Controls the cutoff frequencies of the filters. The
     *
     * @generated from field: float cutoff_frequency_hz = 2;
     */
    cutoffFrequencyHz: number;
    /**
     * Controls the resonance of the filters.
     *
     * @generated from field: float resonance = 3;
     */
    resonance: number;
    /**
     * Controls the spacing between the two filters. Only has an effect in the HP/LP mode,
     * ignored in LP/LP mode.
     *
     * @generated from field: float filter_spacing = 4;
     */
    filterSpacing: number;
    /**
     * How much filter cutoff frequency tracks notes's pitch.
     * -1 means the higher the note, the lower is the cutoff frequency
     * 1 means the higher the note, the higher is the cutoff frequency
     * 0 means the cutoff frequency is not affected by the note's pitch.
     *
     * @generated from field: float keyboard_tracking_amount = 5;
     */
    keyboardTrackingAmount: number;
    constructor(data?: PartialMessage<PulverisateurFilter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurFilter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurFilter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurFilter;
    static equals(a: PulverisateurFilter | PlainMessage<PulverisateurFilter> | undefined, b: PulverisateurFilter | PlainMessage<PulverisateurFilter> | undefined): boolean;
}
/**
 * The Pulverisateur's LFO.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurLfo
 */
export declare class PulverisateurLfo extends Message<PulverisateurLfo> {
    /**
     * The LFO's waveform shape:
     * 0:     random          Randomly switches between amplitudes in certain intervals.
     * 0.25:  sine            ∿∿∿
     * 0.5:   triangle        /\/\/\
     * 0.75:  sawtooth up     /|/|/|
     * 1:     square          |⎺|⎽|⎺|
     * Values between any two of these linearly interpolate the two waveforms.
     *
     * @generated from field: float waveform = 1;
     */
    waveform: number;
    /**
     * Whether the LFO's frequency
     *
     * @generated from field: bool rate_is_synced = 2;
     */
    rateIsSynced: boolean;
    /**
     * The LFO's rate/frequency in normalized form. The exact rate depends
     * on the value of rate_is_synced:
     * - if false, the value maps to milliseconds (1 .. 10_000.0)
     * - if true, the value is quantized to the durations  8/1, 6/1, 4/1, 2/1, 1/1, 1/2, 1/4, 1/6, 1/8,
     *   1/12, 1/16, 1/24, 1/32, 1/48, 1/64, 1/96, 1/128.
     *
     * @generated from field: float rate_normalized = 3;
     */
    rateNormalized: number;
    /**
     * The "trigger" parameter in the UI. If restart_on_note=true, the LFO's phase is reest on each note;
     * if =false, the LFO's phase starts on global time 0 and continues indefinitely (resulting in
     * the LFO's phase offset being consistent on play/pause/loop).
     *
     * @generated from field: bool restart_on_note = 4;
     */
    restartOnNote: boolean;
    /**
     * Whether lfo is applied to Oscillator A pitch.
     *
     * @generated from field: bool targets_oscillator_a_pitch = 5;
     */
    targetsOscillatorAPitch: boolean;
    /**
     * Whether lfo is applied to Oscillator B pitch.
     *
     * @generated from field: bool targets_oscillator_b_pitch = 6;
     */
    targetsOscillatorBPitch: boolean;
    /**
     * Whether lfo is applied to Oscillator C pitch.
     *
     * @generated from field: bool targets_oscillator_c_pitch = 7;
     */
    targetsOscillatorCPitch: boolean;
    /**
     * Whether lfo is applied to filter cutoff.
     *
     * @generated from field: bool targets_filter_cutoff = 8;
     */
    targetsFilterCutoff: boolean;
    /**
     * Whether lfo is applied to pulse width. The pulse width controls the width of the first half
     * of the waves of every oscillator.
     *
     * Example:
     * Square wave for pulse width 0.5:  |⎺⎺⎺|⎽⎽⎽|
     * Square wave for pulse width 0.75: |⎺⎺⎺⎺⎺|⎽|
     *
     * This adds harmonic frequencies to the waveform.
     *
     * @generated from field: bool targets_pulse_width = 9;
     */
    targetsPulseWidth: boolean;
    /**
     * The modulation depth of the LFO. If this is 1, the LFO affects pitch/filter/pulse with
     * in its entire with.
     *
     * @generated from field: float modulation_depth = 10;
     */
    modulationDepth: number;
    constructor(data?: PartialMessage<PulverisateurLfo>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurLfo";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurLfo;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurLfo;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurLfo;
    static equals(a: PulverisateurLfo | PlainMessage<PulverisateurLfo> | undefined, b: PulverisateurLfo | PlainMessage<PulverisateurLfo> | undefined): boolean;
}
/**
 * The Pulverisateur filter envelope.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilterEnvelope
 */
export declare class PulverisateurFilterEnvelope extends Message<PulverisateurFilterEnvelope> {
    /**
     * Duration of the attack phase of the envelope.
     *
     * @generated from field: float attack_ms = 1;
     */
    attackMs: number;
    /**
     * Duration of the decay phase of the envelope.
     *
     * @generated from field: float decay_ms = 2;
     */
    decayMs: number;
    /**
     * Whether the decay phase is looped. If decay_is_looped=true, the decay phase
     * will repeat indefinitely, going forward and backward.
     *
     * @generated from field: bool decay_is_looped = 3;
     */
    decayIsLooped: boolean;
    /**
     * Sustain factor of the envelope.
     *
     * @generated from field: float sustain_factor = 4;
     */
    sustainFactor: number;
    /**
     * The duration of the release phase of this envelope
     *
     * @generated from field: float release_ms = 5;
     */
    releaseMs: number;
    /**
     * The amount of modulation applied to the filter by this envelope.
     *
     * @generated from field: float modulation_depth = 17;
     */
    modulationDepth: number;
    constructor(data?: PartialMessage<PulverisateurFilterEnvelope>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurFilterEnvelope";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurFilterEnvelope;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurFilterEnvelope;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurFilterEnvelope;
    static equals(a: PulverisateurFilterEnvelope | PlainMessage<PulverisateurFilterEnvelope> | undefined, b: PulverisateurFilterEnvelope | PlainMessage<PulverisateurFilterEnvelope> | undefined): boolean;
}
/**
 * The Pulverisateur's amplitude envelope.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAmplitudeEnvelope
 */
export declare class PulverisateurAmplitudeEnvelope extends Message<PulverisateurAmplitudeEnvelope> {
    /**
     * Duration of the attack phase of the envelope.
     *
     * @generated from field: float attack_ms = 1;
     */
    attackMs: number;
    /**
     * Duration of the decay phase of the envelope.
     *
     * @generated from field: float decay_ms = 2;
     */
    decayMs: number;
    /**
     * Whether the decay phase is looped. If loop_decay=true, the decay phase
     * will repeat indefinitely, going forward and backward.
     *
     * @generated from field: bool decay_is_looped = 3;
     */
    decayIsLooped: boolean;
    /**
     * The sustain factor of the envelope.
     *
     * @generated from field: float sustain_factor = 4;
     */
    sustainFactor: number;
    /**
     * The duration of the release phase of this envelope.
     *
     * @generated from field: float release_ms = 5;
     */
    releaseMs: number;
    constructor(data?: PartialMessage<PulverisateurAmplitudeEnvelope>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurAmplitudeEnvelope";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurAmplitudeEnvelope;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurAmplitudeEnvelope;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurAmplitudeEnvelope;
    static equals(a: PulverisateurAmplitudeEnvelope | PlainMessage<PulverisateurAmplitudeEnvelope> | undefined, b: PulverisateurAmplitudeEnvelope | PlainMessage<PulverisateurAmplitudeEnvelope> | undefined): boolean;
}
/**
 * This object contains fields shared between the Oscillators, noise and audio channels, such as
 * whether they're turned on, panning, and gain.
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel
 */
export declare class PulverisateurChannel extends Message<PulverisateurChannel> {
    /**
     * If is_active=false, the channel does not produce any sound.
     *
     * @generated from field: bool is_active = 1;
     */
    isActive: boolean;
    /**
     * Panning of the oscillator
     *
     * @generated from field: float panning = 2;
     */
    panning: number;
    /**
     * This channel's output gain. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 3;
     */
    gain: number;
    constructor(data?: PartialMessage<PulverisateurChannel>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurChannel";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurChannel;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurChannel;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurChannel;
    static equals(a: PulverisateurChannel | PlainMessage<PulverisateurChannel> | undefined, b: PulverisateurChannel | PlainMessage<PulverisateurChannel> | undefined): boolean;
}
/**
 * This object contains fields shared between the 3 main oscillators
 *
 * @generated from message audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillator
 */
export declare class PulverisateurOscillator extends Message<PulverisateurOscillator> {
    /**
     * Tuning moves the oscillator frequency relative to the
     * incoming note's pitch.
     *
     * @generated from field: float tune_semitones = 1;
     */
    tuneSemitones: number;
    /**
     * Adds or subtracts octaves to the oscillator frequency.
     *
     * @generated from field: int32 tune_octaves = 2;
     */
    tuneOctaves: number;
    /**
     * This parameter selects the waveform shape. There are 4 values that map
     * to a specific waveform; values between any two of them linearly interpolate
     * between the two waveforms.
     *
     * 0:      sine           ∿∿∿
     * 0.3333: triangle       /\/\/\
     * 0.6666: sawtooth down  |\|\|\
     * 1:      square         |⎺|⎽|⎺|
     *
     * @generated from field: float waveform = 3;
     */
    waveform: number;
    constructor(data?: PartialMessage<PulverisateurOscillator>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.pulverisateur.v1.PulverisateurOscillator";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PulverisateurOscillator;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PulverisateurOscillator;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PulverisateurOscillator;
    static equals(a: PulverisateurOscillator | PlainMessage<PulverisateurOscillator> | undefined, b: PulverisateurOscillator | PlainMessage<PulverisateurOscillator> | undefined): boolean;
}
