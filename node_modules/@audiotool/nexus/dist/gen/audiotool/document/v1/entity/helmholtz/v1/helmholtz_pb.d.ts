import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Pointer } from '../../../pointer_pb.js';
import { Empty } from '../../../empty_pb.js';

/**
 * The Helmholtz is a device that has up to 5 short delay lines
 * that can be tuned to make certain frequencies resonate,
 * resulting in something akin to a comb filter, i.e. a filter
 * that filters out frequencies that are multiples of a certain frequency.
 *
 * The filter frequencies can be set to specific notes such as C4, D3, etc.
 *
 * Because it's implemented with delay lines, the Helmholtz sounds like
 * it's "resonating" and highlighting certain frequencies and their overtones,
 * and the resonance frequencies will sound after the incoming signal has become quiet.
 *
 * @generated from message audiotool.document.v1.entity.helmholtz.v1.Helmholtz
 */
export declare class Helmholtz extends Message<Helmholtz> {
    /**
     * The device unique identifier.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Reference to the microtuning.
     *
     * @generated from field: audiotool.document.v1.Pointer micro_tuning = 5;
     */
    microTuning?: Pointer;
    /**
     * This device's output gain. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 6;
     */
    gain: number;
    /**
     * The decay time of the delay lines. Increasing this value will make the
     * Helmholtz resonate for longer and louder after the incoming signal has become quiet.
     * No unit.
     *
     * @generated from field: float decay_time = 7;
     */
    decayTime: number;
    /**
     * Controls the mix between the incoming and the effect signal. 0 ("dry") means 0% effect
     * applied, 1 ("wet") means 100% effect applied; values between mixes the two linearly.
     *
     * @generated from field: float mix = 8;
     */
    mix: number;
    /**
     * Whether the device is active or not. When is_active=false, audio signal bypasses the device.
     *
     * @generated from field: bool is_active = 9;
     */
    isActive: boolean;
    /**
     * The 5 filters/delay lines of the Helmholtz.
     *
     * @generated from field: repeated audiotool.document.v1.entity.helmholtz.v1.HelmholtzFilter filters = 10;
     */
    filters: HelmholtzFilter[];
    /**
     * Audio input.
     *
     * @generated from field: audiotool.document.v1.Empty audio_input = 11;
     */
    audioInput?: Empty;
    /**
     * Audio output.
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 12;
     */
    audioOutput?: Empty;
    constructor(data?: PartialMessage<Helmholtz>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.helmholtz.v1.Helmholtz";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Helmholtz;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Helmholtz;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Helmholtz;
    static equals(a: Helmholtz | PlainMessage<Helmholtz> | undefined, b: Helmholtz | PlainMessage<Helmholtz> | undefined): boolean;
}
/**
 * One of the 5 filters/delay lines of the Helmholtz.
 *
 * @generated from message audiotool.document.v1.entity.helmholtz.v1.HelmholtzFilter
 */
export declare class HelmholtzFilter extends Message<HelmholtzFilter> {
    /**
     * Whether the filter is active or not. When is_active=false, the filter doesn't produce any sound.
     *
     * @generated from field: bool is_active = 1;
     */
    isActive: boolean;
    /**
     * Gain applied to the signal after the filter. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 2;
     */
    gain: number;
    /**
     * Pans the signal to left/right. -1 is fully left, 0 is centered (unchanged), 1 is fully right.
     *
     * @generated from field: float panning = 3;
     */
    panning: number;
    /**
     * The frequency this filter will resonate at. Is a midi note, e.g. C4 is 60, D4 is 62, etc.
     *
     * @generated from field: int32 frequency_note = 4;
     */
    frequencyNote: number;
    /**
     * Detune the filter frequency by a given amount of semitones, these are added
     * to the frequency_note. You can detune the filter frequency by up
     * to 7 semitones (a perfect fifth, the dominant) above or down to
     * 7 semitones below (a perfect fourth, the subdominant) the original note.
     *
     * @generated from field: float frequency_tune_semitones = 5;
     */
    frequencyTuneSemitones: number;
    constructor(data?: PartialMessage<HelmholtzFilter>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.helmholtz.v1.HelmholtzFilter";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HelmholtzFilter;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HelmholtzFilter;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HelmholtzFilter;
    static equals(a: HelmholtzFilter | PlainMessage<HelmholtzFilter> | undefined, b: HelmholtzFilter | PlainMessage<HelmholtzFilter> | undefined): boolean;
}
