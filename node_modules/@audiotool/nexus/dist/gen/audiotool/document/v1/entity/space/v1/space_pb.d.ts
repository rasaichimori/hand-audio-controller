import { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Message, proto3 } from '@bufbuild/protobuf';
import { Pointer } from '../../../pointer_pb.js';
import { AdsrEnvelope } from '../../adsr_envelope/v1/adsr_envelope_pb.js';
import { Empty } from '../../../empty_pb.js';

/**
 * The Space is a wavetable synthesizer.
 *
 * It features 2 wavetables called "A" and "B", which can be independently adjusted
 * and mixed together.
 *
 * @generated from message audiotool.document.v1.entity.space.v1.Space
 */
export declare class Space extends Message<Space> {
    /**
     * Uniquely identifies this space synth.
     *
     * @generated from field: string id = 1;
     */
    id: string;
    /**
     * The user-assigned name of this device.
     *
     * @generated from field: string display_name = 2;
     */
    displayName: string;
    /**
     * X position on the desktop in the DAW.
     *
     * @generated from field: int32 position_x = 3;
     */
    positionX: number;
    /**
     * Y position on the desktop in the DAW.
     *
     * @generated from field: int32 position_y = 4;
     */
    positionY: number;
    /**
     * Micro tuning.
     *
     * @generated from field: audiotool.document.v1.Pointer micro_tuning = 5;
     */
    microTuning?: Pointer;
    /**
     * Gain of the synthesizer. Equivalent to a dB range of [-inf, 0.0].
     *
     * @generated from field: float gain = 6;
     */
    gain: number;
    /**
     * Multi purpose parameter to widen the stereo image of the sound.
     *
     * In the negative range (-1..0) the widening happens by phase shifting the two channels
     * (resulting in a wider perceived stereo sound without pitch shift), while
     * in the positive range (0 ..1) the widening happens by detuning the voices, with
     * the right channel being pitched down and the right channel being pitched up
     * on a range between 0 and 12 semitones.
     *
     * If the value is at -1, both voices are equal (resulting in a mono sound).
     *
     * @generated from field: float stereo_detune_shift = 7;
     */
    stereoDetuneShift: number;
    /**
     * Global tuning of the synth, moves all notes played by a given amount of semitones.
     * +/-12 semitones is equivalent to +/- 1 octave.
     *
     * @generated from field: float tune_semitones = 8;
     */
    tuneSemitones: number;
    /**
     * Tuning of wavetable "A".
     *
     * @generated from field: float tune_a_semitones = 9;
     */
    tuneASemitones: number;
    /**
     * Tuning of wavetable "B".
     *
     * @generated from field: float tune_b_semitones = 10;
     */
    tuneBSemitones: number;
    /**
     * Glide time between notes in milliseconds.
     *
     * @generated from field: float glide_ms = 11;
     */
    glideMs: number;
    /**
     * Mixes the two wavetables A and B. -1 means only wavetable A is used, 1.0 means only wavetable B is used.
     *
     * @generated from field: float mix_a_b = 12;
     */
    mixAB: number;
    /**
     * The amount by which the LFO modulates the mix_a_b parameter.
     *
     * @generated from field: float lfo_mix_modulation_depth = 13;
     */
    lfoMixModulationDepth: number;
    /**
     * The amount by which the LFO modulates the gain parameter.
     *
     * @generated from field: float lfo_gain_modulation_depth = 14;
     */
    lfoGainModulationDepth: number;
    /**
     * The amount by which the LFO modulates the stereo_detune_shift parameter.
     *
     * @generated from field: float lfo_stereo_detune_shift_modulation_depth = 15;
     */
    lfoStereoDetuneShiftModulationDepth: number;
    /**
     * The amount by which the LFO modulates the panning of the signal.
     *
     * @generated from field: float lfo_panning_modulation_depth = 16;
     */
    lfoPanningModulationDepth: number;
    /**
     * The amount by which the modulation envelope modulates the mix_a_b parameter.
     *
     * @generated from field: float envelope_mix_modulation_depth = 17;
     */
    envelopeMixModulationDepth: number;
    /**
     * The amount by which the modulation envelope modulates the tune_semitones parameter.
     *
     * @generated from field: float envelope_tune_modulation_depth = 18;
     */
    envelopeTuneModulationDepth: number;
    /**
     * The amount by which the modulation envelope modulates the LFO rate.
     *
     * @generated from field: float envelope_lfo_rate_modulation_depth = 19;
     */
    envelopeLfoRateModulationDepth: number;
    /**
     * The amount by which the modulation envelope modulates the LFO amount.
     *
     * @generated from field: float envelope_lfo_amount_modulation_depth = 20;
     */
    envelopeLfoAmountModulationDepth: number;
    /**
     * The amount by which the velocity modulates the gain parameter.
     *
     * @generated from field: float velocity_gain_modulation_depth = 21;
     */
    velocityGainModulationDepth: number;
    /**
     * The amount by which the note velocity modulates the mix_a_b parameter.
     *
     * @generated from field: float velocity_mix_modulation_depth = 22;
     */
    velocityMixModulationDepth: number;
    /**
     * The amount by which the keyboard (i.e. note pitch) modulates the mix_a_b parameter.
     *
     * @generated from field: float keyboard_mix_modulation_depth = 23;
     */
    keyboardMixModulationDepth: number;
    /**
     * Selects the play mode of the synth for notes.
     * - 0: invalid
     * - 1: Mono       At most once note is played at once with slight overlap during release. An incoming note
     *               cuts already playing notes, starting from the attack phase.
     * - 2: Legato     At most once note is played at once. Incoming notes cut already playing notes, skipping the attack phase of notes,
     *               essentially acting as if the currently playing note's pitch was changed to the new note.
     * - 3: Polyphone  Multiple notes/chords can be played simultaneously.
     *
     * @generated from field: uint32 note_play_mode_index = 24;
     */
    notePlayModeIndex: number;
    /**
     * Parameters for the space LFO.
     *
     * @generated from field: audiotool.document.v1.entity.space.v1.SpaceLFO lfo = 25;
     */
    lfo?: SpaceLFO;
    /**
     * The adsr envelope that modulates the gain of the synth.
     *
     * @generated from field: audiotool.document.v1.entity.adsr_envelope.v1.AdsrEnvelope amplitude_envelope = 26;
     */
    amplitudeEnvelope?: AdsrEnvelope;
    /**
     * The adsr envelope that can be used to modulate other parameters of the synth.
     *
     * @generated from field: audiotool.document.v1.entity.adsr_envelope.v1.AdsrEnvelope modulation_envelope = 27;
     */
    modulationEnvelope?: AdsrEnvelope;
    /**
     * Whether the modulation envelope's release phase is used or not.
     *
     * @generated from field: bool modulation_envelope_has_release = 28;
     */
    modulationEnvelopeHasRelease: boolean;
    /**
     * The parameters for the wavetable "A".
     *
     * @generated from field: audiotool.document.v1.entity.space.v1.SpaceSound sound_a = 29;
     */
    soundA?: SpaceSound;
    /**
     * The parameters for the wavetable "B".
     *
     * @generated from field: audiotool.document.v1.entity.space.v1.SpaceSound sound_b = 30;
     */
    soundB?: SpaceSound;
    /**
     * Notes Input.
     *
     * @generated from field: audiotool.document.v1.Empty notes_input = 31;
     */
    notesInput?: Empty;
    /**
     * Single Output.
     *
     * @generated from field: audiotool.document.v1.Empty audio_output = 32;
     */
    audioOutput?: Empty;
    /**
     * Whether the device is active or not
     *
     * @generated from field: bool is_active = 33;
     */
    isActive: boolean;
    constructor(data?: PartialMessage<Space>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.space.v1.Space";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Space;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Space;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Space;
    static equals(a: Space | PlainMessage<Space> | undefined, b: Space | PlainMessage<Space> | undefined): boolean;
}
/**
 * The Space's LFO parameters.
 *
 * @generated from message audiotool.document.v1.entity.space.v1.SpaceLFO
 */
export declare class SpaceLFO extends Message<SpaceLFO> {
    /**
     * Selects the waveform of the lfo.
     * - 0: invalid
     * - 1: Sine
     * - 2: Triangle
     * - 3: Sawtooth Up
     * - 4: Square
     * - 5: Random
     *
     * @generated from field: uint32 waveform_index = 1;
     */
    waveformIndex: number;
    /**
     * The rate of the LFO, expressed as a normalized value.
     * The meaning of the value depends on the is_synced flag:
     * - if is_synced is false, the  value maps linearly to Hz (0.01 .. 500.0).
     * - if is_synced is true, then the value is quantized to one of 30 bar time durations.
     *   The bar time durations are:
     *      1/256, 1/192, 1/128, 1/96, 1/64, 1/48, 1/32, 1/24, 1/16,
     *      1/12, 1/8, 1/6, 3/16, 1/4, 5/16, 1/3, 3/8, 7/16, 1/2, 9/16, 7/12, 5/8,
     *      2/3, 3/4, 5/6, 7/8, 1/1, 2/1, 3/1, 4/1.
     *
     * @generated from field: float rate_normalized = 3;
     */
    rateNormalized: number;
    /**
     * The LFO's phase offset.
     *
     * @generated from field: float phase_offset = 4;
     */
    phaseOffset: number;
    /**
     * Whether rate_normalized is synced to the project tempo or not.
     *
     * @generated from field: bool is_synced = 5;
     */
    isSynced: boolean;
    /**
     * If this is true, the LFO retriggers for every incoming note. Otherwise
     * it starts at project time 0.
     *
     * @generated from field: bool does_retrigger = 6;
     */
    doesRetrigger: boolean;
    constructor(data?: PartialMessage<SpaceLFO>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.space.v1.SpaceLFO";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceLFO;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceLFO;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceLFO;
    static equals(a: SpaceLFO | PlainMessage<SpaceLFO> | undefined, b: SpaceLFO | PlainMessage<SpaceLFO> | undefined): boolean;
}
/**
 * Datastructure for the Space's Wavetable (aka "sound"). A few of these parameters
 * have a "qualitative" name, such as "dispersion", "metal", etc.
 *
 * The exact description of these parameters on the synth are complex and likely not useful
 * when creating the sound, so they're left out.
 *
 * The comb filter parameters don't control a comb filter on the sound itself, but on its
 * overtones.
 *
 * @generated from message audiotool.document.v1.entity.space.v1.SpaceSound
 */
export declare class SpaceSound extends Message<SpaceSound> {
    /**
     * Controls the "disperse" quality of the sound.
     *
     * @generated from field: float dispersion = 1;
     */
    dispersion: number;
    /**
     * Controls the "vaporization" quality of the sound.
     *
     * @generated from field: float vaporisation = 2;
     */
    vaporisation: number;
    /**
     * Controls the "brightness" quality of the sound, affecting the gains of higher overtones.
     *
     * @generated from field: float brightness = 3;
     */
    brightness: number;
    /**
     * Controls the "metal" quality of the sound.
     *
     * @generated from field: float metal = 4;
     */
    metal: number;
    /**
     * Controls "separation" quality of the sound.
     *
     * @generated from field: int32 separation = 5;
     */
    separation: number;
    /**
     * Number of harmonics in the sound. More harmonics results in a more "rich"/complex
     * sound.
     *
     * @generated from field: int32 harmonics_count = 6;
     */
    harmonicsCount: number;
    /**
     * Comb filter amount - 0 means no filtering, 1 means maximum filtering. No unit.
     *
     * @generated from field: float comb_filter_amount = 7;
     */
    combFilterAmount: number;
    /**
     * The comb filter's "rate", controlling the interval of the sine wave that filters the
     * wavetable's frequency. Higher values mean more peaks & valleys, lower means fewer.
     *
     * @generated from field: float comb_filter_rate = 8;
     */
    combFilterRate: number;
    /**
     * The width of the comb filter. Low values mean the filter filters in the form of a square
     * wave, high values mean it filters in the form of a sine wave. No unit.
     *
     * @generated from field: float comb_filter_width = 9;
     */
    combFilterWidth: number;
    constructor(data?: PartialMessage<SpaceSound>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "audiotool.document.v1.entity.space.v1.SpaceSound";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSound;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSound;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSound;
    static equals(a: SpaceSound | PlainMessage<SpaceSound> | undefined, b: SpaceSound | PlainMessage<SpaceSound> | undefined): boolean;
}
