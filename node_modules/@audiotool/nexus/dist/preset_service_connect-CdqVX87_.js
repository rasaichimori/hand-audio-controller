var ba = Object.defineProperty;
var Ga = (i, s, t) => s in i ? ba(i, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[s] = t;
var a = (i, s, t) => Ga(i, typeof s != "symbol" ? s + "" : s, t);
import { Message as o, proto3 as r, MethodKind as e, Timestamp as m, FieldMask as Zt, Duration as ja, Any as _t } from "@bufbuild/protobuf";
const c = class c extends o {
  constructor(t) {
    super();
    /**
     * The values will be normalized to the range of a uint32.
     *
     * On the server side, a Root Mean Square (RMS) value of the audio signal is calculated.
     * The RMS value is then normalized to the range of a uint32.
     *
     * (It will not be scaled up to the maximum scale of a uint32.)
     *
     * @generated from field: repeated uint32 values = 1;
     */
    a(this, "values", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new c().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new c().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new c().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(c, t, n);
  }
};
a(c, "runtime", r), a(c, "typeName", "audiotool.audiograph.v1.Graph"), a(c, "fields", r.util.newFieldList(() => [
  { no: 1, name: "values", kind: "scalar", T: 13, repeated: !0 }
]));
let en = c;
const d = class d extends o {
  constructor(t) {
    super();
    /**
     * The name of the resource the graph belongs to (track or sample).
     *
     * @generated from field: string resource_name = 1;
     */
    a(this, "resourceName", "");
    /**
     * Depending on the requested audiograph configuration you will get:
     * one graph if you requested MONO
     * two graphs if you requested STEREO (index 0 is left, index 1 is right)
     *
     * @generated from field: repeated audiotool.audiograph.v1.Graph graphs = 2;
     */
    a(this, "graphs", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new d().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new d().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new d().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(d, t, n);
  }
};
a(d, "runtime", r), a(d, "typeName", "audiotool.audiograph.v1.Audiograph"), a(d, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "resource_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "graphs", kind: "message", T: en, repeated: !0 }
]));
let mn = d;
var Pa = /* @__PURE__ */ ((i) => (i[i.GET_AUDIOGRAPH_RESOLUTION_UNSPECIFIED = 0] = "GET_AUDIOGRAPH_RESOLUTION_UNSPECIFIED", i[i.GET_AUDIOGRAPH_RESOLUTION_120 = 120] = "GET_AUDIOGRAPH_RESOLUTION_120", i[i.GET_AUDIOGRAPH_RESOLUTION_240 = 240] = "GET_AUDIOGRAPH_RESOLUTION_240", i[i.GET_AUDIOGRAPH_RESOLUTION_480 = 480] = "GET_AUDIOGRAPH_RESOLUTION_480", i[i.GET_AUDIOGRAPH_RESOLUTION_960 = 960] = "GET_AUDIOGRAPH_RESOLUTION_960", i[i.GET_AUDIOGRAPH_RESOLUTION_1920 = 1920] = "GET_AUDIOGRAPH_RESOLUTION_1920", i[i.GET_AUDIOGRAPH_RESOLUTION_3840 = 3840] = "GET_AUDIOGRAPH_RESOLUTION_3840", i))(Pa || {});
r.util.setEnumType(Pa, "audiotool.audiograph.v1.GetAudiographResolution", [
  { no: 0, name: "GET_AUDIOGRAPH_RESOLUTION_UNSPECIFIED" },
  { no: 120, name: "GET_AUDIOGRAPH_RESOLUTION_120" },
  { no: 240, name: "GET_AUDIOGRAPH_RESOLUTION_240" },
  { no: 480, name: "GET_AUDIOGRAPH_RESOLUTION_480" },
  { no: 960, name: "GET_AUDIOGRAPH_RESOLUTION_960" },
  { no: 1920, name: "GET_AUDIOGRAPH_RESOLUTION_1920" },
  { no: 3840, name: "GET_AUDIOGRAPH_RESOLUTION_3840" }
]);
var Aa = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.MONO = 1] = "MONO", i[i.STEREO = 2] = "STEREO", i))(Aa || {});
r.util.setEnumType(Aa, "audiotool.audiograph.v1.GetAudiographChannels", [
  { no: 0, name: "GET_AUDIOGRAPH_CHANNELS_UNSPECIFIED" },
  { no: 1, name: "GET_AUDIOGRAPH_CHANNELS_MONO" },
  { no: 2, name: "GET_AUDIOGRAPH_CHANNELS_STEREO" }
]);
const f = class f extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the audiograph to retrieve.
     *
     * This can be a track or a sample entities resource name.
     *
     * @generated from field: repeated string resource_names = 1;
     */
    a(this, "resourceNames", []);
    /**
     * The maximum resolution of the audiograph the client is interested in.
     *
     * The client is  not guaranteed to get the exact resolution requested, but you will get the
     * closest.
     *
     * @generated from field: audiotool.audiograph.v1.GetAudiographResolution resolution = 2;
     */
    a(this, "resolution", 0);
    /**
     * The number of channels the client is interested in.
     *
     * @generated from field: audiotool.audiograph.v1.GetAudiographChannels channels = 3;
     */
    a(this, "channels", 0);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new f().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new f().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new f().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(f, t, n);
  }
};
a(f, "runtime", r), a(f, "typeName", "audiotool.audiograph.v1.GetAudiographsRequest"), a(f, "fields", r.util.newFieldList(() => [
  { no: 1, name: "resource_names", kind: "scalar", T: 9, repeated: !0 },
  { no: 2, name: "resolution", kind: "enum", T: r.getEnumType(Pa) },
  { no: 3, name: "channels", kind: "enum", T: r.getEnumType(Aa) }
]));
let un = f;
const E = class E extends o {
  constructor(t) {
    super();
    /**
     * The audiograph data.
     *
     * @generated from field: repeated audiotool.audiograph.v1.Audiograph audiographs = 1;
     */
    a(this, "audiographs", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new E().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new E().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new E().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(E, t, n);
  }
};
a(E, "runtime", r), a(E, "typeName", "audiotool.audiograph.v1.GetAudiographsResponse"), a(E, "fields", r.util.newFieldList(() => [
  { no: 1, name: "audiographs", kind: "message", T: mn, repeated: !0 }
]));
let ln = E;
const Wa = {
  typeName: "audiotool.audiograph.v1.AudiographService",
  methods: {
    /**
     * Get Audiographs
     *
     * @generated from rpc audiotool.audiograph.v1.AudiographService.GetAudiographs
     */
    getAudiographs: {
      name: "GetAudiographs",
      I: un,
      O: ln,
      kind: e.Unary
    }
  }
};
var La = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.OWNER = 1] = "OWNER", i[i.OWNER_UNPUBLISHED = 2] = "OWNER_UNPUBLISHED", i[i.EDITOR = 3] = "EDITOR", i[i.EDITOR_UNPUBLISHED = 4] = "EDITOR_UNPUBLISHED", i[i.VIEWER = 5] = "VIEWER", i))(La || {});
r.util.setEnumType(La, "audiotool.project.v1.ProjectRoleType", [
  { no: 0, name: "PROJECT_ROLE_TYPE_UNSPECIFIED" },
  { no: 1, name: "PROJECT_ROLE_TYPE_OWNER" },
  { no: 2, name: "PROJECT_ROLE_TYPE_OWNER_UNPUBLISHED" },
  { no: 3, name: "PROJECT_ROLE_TYPE_EDITOR" },
  { no: 4, name: "PROJECT_ROLE_TYPE_EDITOR_UNPUBLISHED" },
  { no: 5, name: "PROJECT_ROLE_TYPE_VIEWER" }
]);
const T = class T extends o {
  constructor(t) {
    super();
    /**
     * The name of roles within a project.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The Name of the user.
     *
     * @generated from field: string user_name = 2;
     */
    a(this, "userName", "");
    /**
     * The type of role the user has in the project.
     *
     * @generated from field: audiotool.project.v1.ProjectRoleType role_type = 3;
     */
    a(this, "roleType", 0);
    /**
     * The time the role was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 4;
     */
    a(this, "createTime");
    /**
     * The time the role was last updated.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 5;
     */
    a(this, "updateTime");
    /**
     * The creator of the ProjectRole.
     *
     * @generated from field: string creator_name = 6;
     */
    a(this, "creatorName", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new T().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new T().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new T().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(T, t, n);
  }
};
a(T, "runtime", r), a(T, "typeName", "audiotool.project.v1.ProjectRole"), a(T, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "user_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "role_type", kind: "enum", T: r.getEnumType(La) },
  { no: 4, name: "create_time", kind: "message", T: m },
  { no: 5, name: "update_time", kind: "message", T: m },
  {
    no: 6,
    name: "creator_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Wt = T;
const S = class S extends o {
  constructor(t) {
    super();
    /**
     * Required. The project that contains the ProjectRoles, in the form of
     * `projects/{project}`.
     *
     * @generated from field: string parent = 1;
     */
    a(this, "parent", "");
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - project_role.name
     * - project_role.project_name
     * - project_role.user_name
     *
     * @generated from field: string filter = 4;
     */
    a(this, "filter", "");
    /**
     * The order to sort the results by.
     *
     * Supported fields:
     * - project_role.name
     * - project_role.project_name
     * - project_role.user_name
     *
     * @generated from field: string order_by = 5;
     */
    a(this, "orderBy", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new S().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new S().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new S().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(S, t, n);
  }
};
a(S, "runtime", r), a(S, "typeName", "audiotool.project.v1.ListProjectRolesRequest"), a(S, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "parent",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let cn = S;
const w = class w extends o {
  constructor(t) {
    super();
    /**
     * The project roles.
     *
     * @generated from field: repeated audiotool.project.v1.ProjectRole project_roles = 1;
     */
    a(this, "projectRoles", []);
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new w().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new w().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new w().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(w, t, n);
  }
};
a(w, "runtime", r), a(w, "typeName", "audiotool.project.v1.ListProjectRolesResponse"), a(w, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project_roles", kind: "message", T: Wt, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let dn = w;
const J = class J extends o {
  constructor(t) {
    super();
    /**
     * Required. The project in which the role should be created, in the form of
     * `projects/{project}`.
     *
     * @generated from field: string parent = 1;
     */
    a(this, "parent", "");
    /**
     * The ProjectRole to create.
     *
     * There is a maximum number of ProjectRoles that can be created for a project.
     *
     * The ProjectRole is opt-out.
     *
     * @generated from field: audiotool.project.v1.ProjectRole project_role = 2;
     */
    a(this, "projectRole");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new J().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new J().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new J().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(J, t, n);
  }
};
a(J, "runtime", r), a(J, "typeName", "audiotool.project.v1.CreateProjectRoleRequest"), a(J, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "parent",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "project_role", kind: "message", T: Wt }
]));
let fn = J;
const g = class g extends o {
  constructor(t) {
    super();
    /**
     * The created project_role.
     *
     * @generated from field: audiotool.project.v1.ProjectRole project_role = 1;
     */
    a(this, "projectRole");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new g().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new g().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new g().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(g, t, n);
  }
};
a(g, "runtime", r), a(g, "typeName", "audiotool.project.v1.CreateProjectRoleResponse"), a(g, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project_role", kind: "message", T: Wt }
]));
let En = g;
const I = class I extends o {
  constructor(t) {
    super();
    /**
     * Required. The ProjectRole to delete, in the form of
     * `projects/{project}/role/user/{user}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new I().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new I().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new I().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(I, t, n);
  }
};
a(I, "runtime", r), a(I, "typeName", "audiotool.project.v1.DeleteProjectRoleRequest"), a(I, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Tn = I;
const O = class O extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new O().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new O().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new O().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(O, s, t);
  }
};
a(O, "runtime", r), a(O, "typeName", "audiotool.project.v1.DeleteProjectRoleResponse"), a(O, "fields", r.util.newFieldList(() => []));
let Sn = O;
const N = class N extends o {
  constructor(t) {
    super();
    /**
     * The ProjectRole update.
     *
     * @generated from field: audiotool.project.v1.ProjectRole project_role = 1;
     */
    a(this, "projectRole");
    /**
     * The update mask to apply.
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    a(this, "updateMask");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new N().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new N().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new N().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(N, t, n);
  }
};
a(N, "runtime", r), a(N, "typeName", "audiotool.project.v1.UpdateProjectRoleRequest"), a(N, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project_role", kind: "message", T: Wt },
  { no: 2, name: "update_mask", kind: "message", T: Zt }
]));
let wn = N;
const k = class k extends o {
  constructor(t) {
    super();
    /**
     * The updated ProjectRole.
     *
     * @generated from field: audiotool.project.v1.ProjectRole project_role = 1;
     */
    a(this, "projectRole");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new k().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new k().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new k().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(k, t, n);
  }
};
a(k, "runtime", r), a(k, "typeName", "audiotool.project.v1.UpdateProjectRoleResponse"), a(k, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project_role", kind: "message", T: Wt }
]));
let Jn = k;
const Qa = {
  typeName: "audiotool.project.v1.ProjectRoleService",
  methods: {
    /**
     * Lists all ProjectRoles for a project.
     *
     * @generated from rpc audiotool.project.v1.ProjectRoleService.ListProjectRoles
     */
    listProjectRoles: {
      name: "ListProjectRoles",
      I: cn,
      O: dn,
      kind: e.Unary
    },
    /**
     * Creates a ProjectRole.
     *
     * @generated from rpc audiotool.project.v1.ProjectRoleService.CreateProjectRole
     */
    createProjectRole: {
      name: "CreateProjectRole",
      I: fn,
      O: En,
      kind: e.Unary
    },
    /**
     * Deletes a ProjectRole.
     *
     * @generated from rpc audiotool.project.v1.ProjectRoleService.DeleteProjectRole
     */
    deleteProjectRole: {
      name: "DeleteProjectRole",
      I: Tn,
      O: Sn,
      kind: e.Unary
    },
    /**
     * Updates a ProjectRole.
     *
     * @generated from rpc audiotool.project.v1.ProjectRoleService.UpdateProjectRole
     */
    updateProjectRole: {
      name: "UpdateProjectRole",
      I: wn,
      O: Jn,
      kind: e.Unary
    }
  }
};
var pa = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.NO_RIGHTS_RESERVED = 1] = "NO_RIGHTS_RESERVED", i[i.CREATIVE_COMMONS = 2] = "CREATIVE_COMMONS", i[i.CREATIVE_COMMONS_NON_COMMERCIAL = 3] = "CREATIVE_COMMONS_NON_COMMERCIAL", i[i.ALL_RIGHTS_RESERVED = 4] = "ALL_RIGHTS_RESERVED", i[i.ROYALTY_FREE = 5] = "ROYALTY_FREE", i))(pa || {});
r.util.setEnumType(pa, "audiotool.project.v1.TrackLicense", [
  { no: 0, name: "TRACK_LICENSE_UNSPECIFIED" },
  { no: 1, name: "TRACK_LICENSE_NO_RIGHTS_RESERVED" },
  { no: 2, name: "TRACK_LICENSE_CREATIVE_COMMONS" },
  { no: 3, name: "TRACK_LICENSE_CREATIVE_COMMONS_NON_COMMERCIAL" },
  { no: 4, name: "TRACK_LICENSE_ALL_RIGHTS_RESERVED" },
  { no: 5, name: "TRACK_LICENSE_ROYALTY_FREE" }
]);
const y = class y extends o {
  constructor(t) {
    super();
    /**
     * The name of the Project.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The list of users having a role in the project.
     *
     * The user_names are the user names of the users having a role in the project.
     *
     * The ProjectRoles can be managed by the ProjectRoleService.
     *
     * @generated from field: repeated string user_names = 2;
     */
    a(this, "userNames", []);
    /**
     * The creator of the project.
     *
     * The owner of the project can be handed over to another user. The creator_name will stay the
     * same.
     *
     * @generated from field: string creator_name = 3;
     */
    a(this, "creatorName", "");
    /**
     * The track_name of the project (this is set when a the project has been published as a track).
     *
     * @generated from field: string track_name = 4;
     */
    a(this, "trackName", "");
    /**
     * If the project was remixed from a track, this will be the name of the track.
     *
     * If this value is specified, the value of `copy_of_project_name` and
     * `copy_of_project_commit_index` is ignored and the project of the `Track` message is used.
     * `remix_allowed` must be set to `true`.
     *
     * The resulting project will have the `copy_of_project_name` set to the name of the
     * remixed track and the `copy_of_project_commit_index` set to the commit index.
     *
     * Historical data of the project will not be copied, only the current state of the project.
     *
     * @generated from field: string remix_of_track_name = 5;
     */
    a(this, "remixOfTrackName", "");
    /**
     * If the project was copied from another project, this will be the name of the project.
     *
     * At create time the caller will enforce a copy of a project by setting this value. The project
     * must have `copy_allowed` set to true or the calling user must have a role in the project.
     *
     * Historical data of the project will not be copied, only the current state of the project.
     *
     * If `remix_of_track_name` is set, this value is ignored.
     *
     * @generated from field: string copy_of_project_name = 6;
     */
    a(this, "copyOfProjectName", "");
    /**
     * If the project was copied/remixed from a track, this will be the commit_index of the track.
     * For legacy projects the commit can be empty, even if the `copy_of_project_name` is set.
     *
     * At create time the caller will enforce a copy of a project at an exact point in time by setting
     * this value. If the value is not set, and `copy_of_project_name` is specified the latest commit
     * of the project will be used and set.
     *
     * @generated from field: uint32 copy_of_project_commit_index = 7;
     */
    a(this, "copyOfProjectCommitIndex", 0);
    /**
     * The Project name.
     *
     * A random name will be generated if not provided.
     *
     * Refers to track.display_name on sync.
     *
     * @generated from field: string display_name = 8;
     */
    a(this, "displayName", "");
    /**
     * The Description of the Project.
     *
     * Refers to track.description on sync.
     *
     * @generated from field: string description = 9;
     */
    a(this, "description", "");
    /**
     * Output only. Timestamp when this Project was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 10;
     */
    a(this, "createTime");
    /**
     * Output only. Timestamp when this Project was last updated.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 11;
     */
    a(this, "updateTime");
    /**
     * The duration of the Project.
     *
     * Refers to track.play_duration on sync.
     *
     * @generated from field: google.protobuf.Duration play_duration = 12;
     */
    a(this, "playDuration");
    /**
     * The tags of the Project.
     *
     * Refers to track.tags on sync.
     *
     * @generated from field: repeated string tags = 13;
     */
    a(this, "tags", []);
    /**
     * The cover art URL of the project.
     *
     * `?width=256&height=256&fit=cover&format=webp` can be appended to the URL for resizing
     * (current restriction - this is only able for for CDNs > 2)
     *
     * The cover_url must be uploaded due ProjectService.UploadCover.
     *
     * Refers to track.cover_url on sync.
     *
     * @generated from field: string cover_url = 14;
     */
    a(this, "coverUrl", "");
    /**
     * The snapshot of the DAW configuration of the project.
     *
     * `?width=256&height=256&fit=cover&format=webp` can be appended to the URL for resizing
     * (current restriction - this is only able for for CDNs > 2)
     *
     * Refers to track.cover_url on sync.
     *
     * @generated from field: string snapshot_url = 15;
     */
    a(this, "snapshotUrl", "");
    /**
     * Beats per minute of the project which will be the track bpm.
     *
     * Refers to track.bpm on sync.
     *
     * @generated from field: double bpm = 16;
     */
    a(this, "bpm", 0);
    /**
     * The genre name of the project, which becomes the track genre on publish.
     *
     * Refers to track.genre_name on sync.
     *
     * @generated from field: string genre_name = 17;
     */
    a(this, "genreName", "");
    /**
     * Whether a simple download is allowed for the user. API implementers must respect this value.
     *
     * Refers to track.download_allowerd on sync.
     *
     * @generated from field: bool download_allowed = 18;
     */
    a(this, "downloadAllowed", !1);
    /**
     * Whether copying is allowed for users not having a role in the project.
     *
     * If this is set to true and the project is published as a track, the tracks `remix_allowed` is
     * set to true. The tracks bool flag `remix_allowed` is used to determine if a track can be copied
     * by users not having a role in the project and takes precedence over this value. To override
     * this value, the metadata of the track must be updated / synced again.
     *
     * @generated from field: bool copy_allowed = 19;
     */
    a(this, "copyAllowed", !1);
    /**
     * The license of the Project.
     *
     * Refers to track.license on sync.
     *
     * @generated from field: audiotool.project.v1.TrackLicense license = 20;
     */
    a(this, "license", 0);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new y().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new y().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new y().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(y, t, n);
  }
};
a(y, "runtime", r), a(y, "typeName", "audiotool.project.v1.Project"), a(y, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "user_names", kind: "scalar", T: 9, repeated: !0 },
  {
    no: 3,
    name: "creator_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "track_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "remix_of_track_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "copy_of_project_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "copy_of_project_commit_index",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  },
  {
    no: 8,
    name: "display_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 9,
    name: "description",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 10, name: "create_time", kind: "message", T: m },
  { no: 11, name: "update_time", kind: "message", T: m },
  { no: 12, name: "play_duration", kind: "message", T: ja },
  { no: 13, name: "tags", kind: "scalar", T: 9, repeated: !0 },
  {
    no: 14,
    name: "cover_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 15,
    name: "snapshot_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 16,
    name: "bpm",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  },
  {
    no: 17,
    name: "genre_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 18,
    name: "download_allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 19,
    name: "copy_allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 20, name: "license", kind: "enum", T: r.getEnumType(pa) }
]));
let u = y;
const B = class B extends o {
  constructor(t) {
    super();
    /**
     * Project
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    /**
     * The DocumentService URL for the session where the studio connects to.
     *
     * @generated from field: string document_service_url = 2;
     */
    a(this, "documentServiceUrl", "");
    /**
     * The prefix URL for studio (location of assets in the CDN).
     *
     * @generated from field: string studio_prefix_url = 3;
     */
    a(this, "studioPrefixUrl", "");
    /**
     * The prefix URL for document_service (location of assets in the CDN).
     *
     * Within this location is the document_validator.wasm
     *
     * @generated from field: string document_service_prefix_url = 4;
     */
    a(this, "documentServicePrefixUrl", "");
    /**
     * The prefix URL for the audio engine (location of assets in the CDN).
     *
     * @generated from field: string audio_engine_prefix_url = 5;
     */
    a(this, "audioEnginePrefixUrl", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new B().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new B().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new B().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(B, t, n);
  }
};
a(B, "runtime", r), a(B, "typeName", "audiotool.project.v1.Session"), a(B, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u },
  {
    no: 2,
    name: "document_service_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "studio_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "document_service_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "audio_engine_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let an = B;
var Fa = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.ALL = 1] = "ALL", i[i.METADATA = 2] = "METADATA", i[i.AUDIO = 3] = "AUDIO", i))(Fa || {});
r.util.setEnumType(Fa, "audiotool.project.v1.SyncTrackMode", [
  { no: 0, name: "SYNC_TRACK_MODE_UNSPECIFIED" },
  { no: 1, name: "SYNC_TRACK_MODE_ALL" },
  { no: 2, name: "SYNC_TRACK_MODE_METADATA" },
  { no: 3, name: "SYNC_TRACK_MODE_AUDIO" }
]);
const P = class P extends o {
  constructor(t) {
    super();
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - project.name
     * - project.user_names
     * - project.creator_name
     * - project.track_name
     * - project.display_name
     * - project.description
     * - project.create_time
     * - project.update_time
     * - project.tags
     * - project.genre_name
     *
     * @generated from field: string filter = 1;
     */
    a(this, "filter", "");
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The order to sort the results by.
     *
     * Supported fields:
     * - project.name
     * - project.user_names
     * - project.creator_name
     * - project.track_name
     * - project.display_name
     * - project.description
     * - project.create_time
     * - project.update_time
     * - project.tags
     * - project.genre_name
     *
     * @generated from field: string order_by = 4;
     */
    a(this, "orderBy", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new P().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new P().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new P().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(P, t, n);
  }
};
a(P, "runtime", r), a(P, "typeName", "audiotool.project.v1.ListProjectsRequest"), a(P, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let gn = P;
const A = class A extends o {
  constructor(t) {
    super();
    /**
     * The list of projects.
     *
     * @generated from field: repeated audiotool.project.v1.Project projects = 1;
     */
    a(this, "projects", []);
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new A().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new A().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new A().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(A, t, n);
  }
};
a(A, "runtime", r), a(A, "typeName", "audiotool.project.v1.ListProjectsResponse"), a(A, "fields", r.util.newFieldList(() => [
  { no: 1, name: "projects", kind: "message", T: u, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let In = A;
const L = class L extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to get, in the form of `projects/{project_id}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new L().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new L().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new L().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(L, t, n);
  }
};
a(L, "runtime", r), a(L, "typeName", "audiotool.project.v1.GetProjectRequest"), a(L, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let On = L;
const p = class p extends o {
  constructor(t) {
    super();
    /**
     * The project.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new p().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new p().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new p().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(p, t, n);
  }
};
a(p, "runtime", r), a(p, "typeName", "audiotool.project.v1.GetProjectResponse"), a(p, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u }
]));
let Nn = p;
const F = class F extends o {
  constructor(t) {
    super();
    /**
     * The project to create.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new F().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new F().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new F().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(F, t, n);
  }
};
a(F, "runtime", r), a(F, "typeName", "audiotool.project.v1.CreateProjectRequest"), a(F, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u }
]));
let kn = F;
const U = class U extends o {
  constructor(t) {
    super();
    /**
     * The created project.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new U().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new U().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new U().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(U, t, n);
  }
};
a(U, "runtime", r), a(U, "typeName", "audiotool.project.v1.CreateProjectResponse"), a(U, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u }
]));
let yn = U;
const C = class C extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to upload the cover, in the form of `projects/{project_id}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The image to upload. The data format will be automatically detected.
     * the following formats are supported:
     * - JPEG
     * - PNG
     * - WEBP
     *
     * @generated from field: bytes data = 2;
     */
    a(this, "data", new Uint8Array(0));
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new C().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new C().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new C().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(C, t, n);
  }
};
a(C, "runtime", r), a(C, "typeName", "audiotool.project.v1.UploadCoverRequest"), a(C, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "data",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]));
let Bn = C;
const x = class x extends o {
  constructor(t) {
    super();
    /**
     * The updated project.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new x().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new x().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new x().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(x, t, n);
  }
};
a(x, "runtime", r), a(x, "typeName", "audiotool.project.v1.UploadCoverResponse"), a(x, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u }
]));
let Pn = x;
const M = class M extends o {
  constructor(t) {
    super();
    /**
     * The project to update.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    /**
     * The update mask to apply to the project.
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    a(this, "updateMask");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new M().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new M().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new M().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(M, t, n);
  }
};
a(M, "runtime", r), a(M, "typeName", "audiotool.project.v1.UpdateProjectRequest"), a(M, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u },
  { no: 2, name: "update_mask", kind: "message", T: Zt }
]));
let An = M;
const h = class h extends o {
  constructor(t) {
    super();
    /**
     * The updated project.
     *
     * @generated from field: audiotool.project.v1.Project project = 1;
     */
    a(this, "project");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new h().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new h().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new h().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(h, t, n);
  }
};
a(h, "runtime", r), a(h, "typeName", "audiotool.project.v1.UpdateProjectResponse"), a(h, "fields", r.util.newFieldList(() => [
  { no: 1, name: "project", kind: "message", T: u }
]));
let Ln = h;
const V = class V extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to be deleted, in the form of `projects/{project_id}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new V().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new V().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new V().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(V, t, n);
  }
};
a(V, "runtime", r), a(V, "typeName", "audiotool.project.v1.DeleteProjectRequest"), a(V, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let pn = V;
const H = class H extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new H().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new H().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new H().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(H, s, t);
  }
};
a(H, "runtime", r), a(H, "typeName", "audiotool.project.v1.DeleteProjectResponse"), a(H, "fields", r.util.newFieldList(() => []));
let Fn = H;
const v = class v extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to publish, in the form of `projects/{project_id}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * Required. The mode to sync the track.
     *
     * @generated from field: audiotool.project.v1.SyncTrackMode mode = 2;
     */
    a(this, "mode", 0);
    /**
     * Commit index used to render the audio & images if mode is audio.
     *
     * @generated from field: uint32 commit_index = 3;
     */
    a(this, "commitIndex", 0);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new v().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new v().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new v().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(v, t, n);
  }
};
a(v, "runtime", r), a(v, "typeName", "audiotool.project.v1.SyncTrackRequest"), a(v, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "mode", kind: "enum", T: r.getEnumType(Fa) },
  {
    no: 3,
    name: "commit_index",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]));
let Un = v;
const Y = class Y extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to open a session for, in the form of `projects/{project_id}`.
     *
     * @generated from field: string project_name = 1;
     */
    a(this, "projectName", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Y().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Y().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Y().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Y, t, n);
  }
};
a(Y, "runtime", r), a(Y, "typeName", "audiotool.project.v1.OpenSessionRequest"), a(Y, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "project_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Cn = Y;
const q = class q extends o {
  constructor(t) {
    super();
    /**
     * The session.
     *
     * @generated from field: audiotool.project.v1.Session session = 1;
     */
    a(this, "session");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new q().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new q().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new q().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(q, t, n);
  }
};
a(q, "runtime", r), a(q, "typeName", "audiotool.project.v1.OpenSessionResponse"), a(q, "fields", r.util.newFieldList(() => [
  { no: 1, name: "session", kind: "message", T: an }
]));
let xn = q;
const X = class X extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the project to close the session for, in the form of `projects/{project_id}`.
     *
     * @generated from field: string project_name = 1;
     */
    a(this, "projectName", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new X().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new X().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new X().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(X, t, n);
  }
};
a(X, "runtime", r), a(X, "typeName", "audiotool.project.v1.CloseSessionRequest"), a(X, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "project_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Ma = X;
const D = class D extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new D().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new D().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new D().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(D, s, t);
  }
};
a(D, "runtime", r), a(D, "typeName", "audiotool.project.v1.CloseSessionResponse"), a(D, "fields", r.util.newFieldList(() => []));
let ha = D;
const R = class R extends o {
  constructor(t) {
    super();
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - session.project_name
     *
     * @generated from field: string filter = 1;
     */
    a(this, "filter", "");
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The order to sort the results by.
     *
     * Supported fields:
     * - session.project_name
     *
     * @generated from field: string order_by = 4;
     */
    a(this, "orderBy", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new R().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new R().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new R().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(R, t, n);
  }
};
a(R, "runtime", r), a(R, "typeName", "audiotool.project.v1.ListSessionsRequest"), a(R, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Mn = R;
const j = class j extends o {
  constructor(t) {
    super();
    /**
     * The list of sessions.
     *
     * @generated from field: repeated audiotool.project.v1.Session sessions = 1;
     */
    a(this, "sessions", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new j().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new j().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new j().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(j, t, n);
  }
};
a(j, "runtime", r), a(j, "typeName", "audiotool.project.v1.ListSessionsResponse"), a(j, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sessions", kind: "message", T: an, repeated: !0 }
]));
let hn = j;
const b = class b extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new b().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new b().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new b().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(b, s, t);
  }
};
a(b, "runtime", r), a(b, "typeName", "audiotool.project.v1.GetLatestVersionBundleRequest"), a(b, "fields", r.util.newFieldList(() => []));
let Vn = b;
const G = class G extends o {
  constructor(t) {
    super();
    /**
     * The prefix URL for studio (location of assets in the CDN).
     *
     * @generated from field: string studio_prefix_url = 1;
     */
    a(this, "studioPrefixUrl", "");
    /**
     * The prefix URL for document_service (location of assets in the CDN).
     *
     * Within this location is the document_validator.wasm
     *
     * @generated from field: string document_service_prefix_url = 2;
     */
    a(this, "documentServicePrefixUrl", "");
    /**
     * The prefix URL for the audio engine (location of assets in the CDN).
     *
     * @generated from field: string audio_engine_prefix_url = 3;
     */
    a(this, "audioEnginePrefixUrl", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new G().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new G().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new G().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(G, t, n);
  }
};
a(G, "runtime", r), a(G, "typeName", "audiotool.project.v1.GetLatestVersionBundleResponse"), a(G, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "studio_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "document_service_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "audio_engine_prefix_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Hn = G;
const K = class K extends o {
  constructor(t) {
    super();
    /**
     * The server-assigned name, which is only unique within the same service that
     * originally returns it. If you use the default HTTP mapping, the
     * `name` should be a resource name ending with `operations/{unique_id}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * Service-specific metadata associated with the operation.  It typically
     * contains progress information and common metadata such as create time.
     * Some services might not provide such metadata.  Any method that returns a
     * long-running operation should document the metadata type, if any.
     *
     * @generated from field: google.protobuf.Any metadata = 2;
     */
    a(this, "metadata");
    /**
     * If the value is `false`, it means the operation is still in progress.
     * If `true`, the operation is completed, and either `error` or `response` is
     * available.
     *
     * @generated from field: bool done = 3;
     */
    a(this, "done", !1);
    /**
     * The operation result, which can be either an `error` or a valid `response`.
     * If `done` == `false`, neither `error` nor `response` is set.
     * If `done` == `true`, exactly one of `error` or `response` is set.
     *
     * @generated from oneof audiotool.longrunning.v1.Operation.result
     */
    a(this, "result", { case: void 0 });
    /**
     * List of owners for this Operation
     *
     * @generated from field: repeated string owners = 6;
     */
    a(this, "owners", []);
    /**
     * The time the operation was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 7;
     */
    a(this, "createTime");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new K().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new K().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new K().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(K, t, n);
  }
};
a(K, "runtime", r), a(K, "typeName", "audiotool.longrunning.v1.Operation"), a(K, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "metadata", kind: "message", T: _t },
  {
    no: 3,
    name: "done",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 4, name: "error", kind: "message", T: vn, oneof: "result" },
  { no: 5, name: "response", kind: "message", T: _t, oneof: "result" },
  { no: 6, name: "owners", kind: "scalar", T: 9, repeated: !0 },
  { no: 7, name: "create_time", kind: "message", T: m }
]));
let tn = K;
const z = class z extends o {
  constructor(t) {
    super();
    /**
     * The name of the operation resource.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new z().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new z().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new z().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(z, t, n);
  }
};
a(z, "runtime", r), a(z, "typeName", "audiotool.longrunning.v1.GetOperationRequest"), a(z, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Va = z;
const W = class W extends o {
  constructor(t) {
    super();
    /**
     * The operation resource.
     *
     * @generated from field: audiotool.longrunning.v1.Operation operation = 1;
     */
    a(this, "operation");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new W().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new W().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new W().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(W, t, n);
  }
};
a(W, "runtime", r), a(W, "typeName", "audiotool.longrunning.v1.GetOperationResponse"), a(W, "fields", r.util.newFieldList(() => [
  { no: 1, name: "operation", kind: "message", T: tn }
]));
let Ha = W;
const Q = class Q extends o {
  constructor(t) {
    super();
    /**
     * The name of the operation's parent resource.
     *
     * @generated from field: string name = 4;
     */
    a(this, "name", "");
    /**
     * The standard list filter.
     *
     * @generated from field: string filter = 1;
     */
    a(this, "filter", "");
    /**
     * The standard list page size.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The standard list page token.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Q().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Q().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Q().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Q, t, n);
  }
};
a(Q, "runtime", r), a(Q, "typeName", "audiotool.longrunning.v1.ListOperationsRequest"), a(Q, "fields", r.util.newFieldList(() => [
  {
    no: 4,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 1,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let va = Q;
const Z = class Z extends o {
  constructor(t) {
    super();
    /**
     * A list of operations that matches the specified filter in the request.
     *
     * @generated from field: repeated audiotool.longrunning.v1.Operation operations = 1;
     */
    a(this, "operations", []);
    /**
     * The standard List next-page token.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Z().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Z().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Z().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Z, t, n);
  }
};
a(Z, "runtime", r), a(Z, "typeName", "audiotool.longrunning.v1.ListOperationsResponse"), a(Z, "fields", r.util.newFieldList(() => [
  { no: 1, name: "operations", kind: "message", T: tn, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Ya = Z;
const $ = class $ extends o {
  constructor(t) {
    super();
    /**
     * The name of the operation resource to be cancelled.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new $().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new $().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new $().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals($, t, n);
  }
};
a($, "runtime", r), a($, "typeName", "audiotool.longrunning.v1.CancelOperationRequest"), a($, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let qa = $;
const _ = class _ extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new _().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new _().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new _().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(_, s, t);
  }
};
a(_, "runtime", r), a(_, "typeName", "audiotool.longrunning.v1.CancelOperationResponse"), a(_, "fields", r.util.newFieldList(() => []));
let Xa = _;
const tt = class tt extends o {
  constructor(t) {
    super();
    /**
     * The name of the operation resource to be deleted.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new tt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new tt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new tt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(tt, t, n);
  }
};
a(tt, "runtime", r), a(tt, "typeName", "audiotool.longrunning.v1.DeleteOperationRequest"), a(tt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Da = tt;
const nt = class nt extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new nt().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new nt().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new nt().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(nt, s, t);
  }
};
a(nt, "runtime", r), a(nt, "typeName", "audiotool.longrunning.v1.DeleteOperationResponse"), a(nt, "fields", r.util.newFieldList(() => []));
let Ra = nt;
const at = class at extends o {
  constructor(t) {
    super();
    /**
     * The status code, which should be an enum value of
     * [google.rpc.Code][google.rpc.Code].
     *
     * @generated from field: int32 code = 1;
     */
    a(this, "code", 0);
    /**
     * A developer-facing error message, which should be in English. Any
     * user-facing error message should be localized and sent in the
     * [google.rpc.Status.details][google.rpc.Status.details] field, or localized
     * by the client.
     *
     * @generated from field: string message = 2;
     */
    a(this, "message", "");
    /**
     * A list of messages that carry the error details.  There is a common set of
     * message types for APIs to use.
     *
     * @generated from field: repeated google.protobuf.Any details = 3;
     */
    a(this, "details", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new at().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new at().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new at().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(at, t, n);
  }
};
a(at, "runtime", r), a(at, "typeName", "audiotool.longrunning.v1.Status"), a(at, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "code",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 2,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "details", kind: "message", T: _t, repeated: !0 }
]));
let vn = at;
const Za = {
  typeName: "audiotool.project.v1.ProjectService",
  methods: {
    /**
     * List the projects.option
     *
     * @generated from rpc audiotool.project.v1.ProjectService.ListProjects
     */
    listProjects: {
      name: "ListProjects",
      I: gn,
      O: In,
      kind: e.Unary
    },
    /**
     * Get a project.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.GetProject
     */
    getProject: {
      name: "GetProject",
      I: On,
      O: Nn,
      kind: e.Unary
    },
    /**
     * Create a project.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.CreateProject
     */
    createProject: {
      name: "CreateProject",
      I: kn,
      O: yn,
      kind: e.Unary
    },
    /**
     * Upload a cover.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.UploadCover
     */
    uploadCover: {
      name: "UploadCover",
      I: Bn,
      O: Pn,
      kind: e.Unary
    },
    /**
     * Update a project.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.UpdateProject
     */
    updateProject: {
      name: "UpdateProject",
      I: An,
      O: Ln,
      kind: e.Unary
    },
    /**
     * Delete a project.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.DeleteProject
     */
    deleteProject: {
      name: "DeleteProject",
      I: pn,
      O: Fn,
      kind: e.Unary
    },
    /**
     * SyncTrack a will create or update a track.
     *
     * The project will be used as leading source for the track.
     * This RPC kicks off a process where user can listen to via the events api.
     *
     * Another optimistic approach is to trigger GetTrack with the returned track_name.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.SyncTrack
     */
    syncTrack: {
      name: "SyncTrack",
      I: Un,
      O: tn,
      kind: e.Unary
    },
    /**
     * Open a session. This will create a new session if one does not exist.
     *
     * This is used to allow multiple users to work on a project at the same time and opens the
     * Document. The returned session contains the URLs to connect to the DocumentService
     * which uses his own proto for communication. (audiotool.document.v1.DocumentService)
     *
     * @generated from rpc audiotool.project.v1.ProjectService.OpenSession
     */
    openSession: {
      name: "OpenSession",
      I: Cn,
      O: xn,
      kind: e.Unary
    },
    /**
     * List sessions.
     *
     * This gives all the sessions where a user can join and are active at the request time.
     *
     * @generated from rpc audiotool.project.v1.ProjectService.ListSessions
     */
    listSessions: {
      name: "ListSessions",
      I: Mn,
      O: hn,
      kind: e.Unary
    },
    /**
     * Get Latest Version Bundle
     *
     * This returns the latest bundle version required for session to allow potential quicker pre-loading
     *
     * @generated from rpc audiotool.project.v1.ProjectService.GetLatestVersionBundle
     */
    getLatestVersionBundle: {
      name: "GetLatestVersionBundle",
      I: Vn,
      O: Hn,
      kind: e.Unary
    }
  }
};
var rn = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.ONE_SHOT = 1] = "ONE_SHOT", i[i.LOOP = 2] = "LOOP", i))(rn || {});
r.util.setEnumType(rn, "audiotool.sample.v1.SampleType", [
  { no: 0, name: "SAMPLE_TYPE_UNSPECIFIED" },
  { no: 1, name: "SAMPLE_TYPE_ONE_SHOT" },
  { no: 2, name: "SAMPLE_TYPE_LOOP" }
]);
var sn = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.SAFE = 1] = "SAFE", i[i.UNSAFE = 2] = "UNSAFE", i))(sn || {});
r.util.setEnumType(sn, "audiotool.sample.v1.SampleClearance", [
  { no: 0, name: "SAMPLE_CLEARANCE_UNSPECIFIED" },
  { no: 1, name: "SAMPLE_CLEARANCE_SAFE" },
  { no: 2, name: "SAMPLE_CLEARANCE_UNSAFE" }
]);
var on = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.PUBLIC = 1] = "PUBLIC", i[i.UNLISTED = 2] = "UNLISTED", i[i.PRIVATE = 3] = "PRIVATE", i))(on || {});
r.util.setEnumType(on, "audiotool.sample.v1.SampleUsage", [
  { no: 0, name: "SAMPLE_USAGE_UNSPECIFIED" },
  { no: 1, name: "SAMPLE_USAGE_PUBLIC" },
  { no: 2, name: "SAMPLE_USAGE_UNLISTED" },
  { no: 3, name: "SAMPLE_USAGE_PRIVATE" }
]);
const rt = class rt extends o {
  constructor(t) {
    super();
    /**
     * The Sample name.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The display name of the Sample.
     *
     * @generated from field: string display_name = 2;
     */
    a(this, "displayName", "");
    /**
     * The description of the Sample.
     *
     * @generated from field: string description = 3;
     */
    a(this, "description", "");
    /**
     * The Owner of the Sample in the form of `users/{user}`.
     *
     * @generated from field: string owner_name = 4;
     */
    a(this, "ownerName", "");
    /**
     * Whether the authed user liked the sample.
     *
     * This is only exposed if the user is authenticated.  The user can like a Preset via
     * Favor API.
     *
     * @generated from field: bool favorited_by_user = 5;
     */
    a(this, "favoritedByUser", !1);
    /**
     * The number of favorites of the Sample.
     *
     * @generated from field: int32 num_favorites = 6;
     */
    a(this, "numFavorites", 0);
    /**
     * The number of usages of the Sample.
     *
     * @generated from field: int32 num_usages = 7;
     */
    a(this, "numUsages", 0);
    /**
     * The beats per minute of the Sample.
     *
     * @generated from field: double bpm = 8;
     */
    a(this, "bpm", 0);
    /**
     * The type of the Sample.
     *
     * @generated from field: audiotool.sample.v1.SampleType sample_type = 9;
     */
    a(this, "sampleType", 0);
    /**
     * The duration of the Sample.
     *
     * @generated from field: google.protobuf.Duration play_duration = 10;
     */
    a(this, "playDuration");
    /**
     * Output only. Timestamp when this Sample was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 11;
     */
    a(this, "createTime");
    /**
     * Output only. Timestamp when this Sample was last updated.
     *
     * The underlying audio can't be changed. Only some metadata (of this message) can be changed.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 12;
     */
    a(this, "updateTime");
    /**
     * The clearance of the Sample.
     *
     * @generated from field: audiotool.sample.v1.SampleClearance clearance = 13;
     */
    a(this, "clearance", 0);
    /**
     * The usage of the Sample.
     *
     * @generated from field: audiotool.sample.v1.SampleUsage usage = 14;
     */
    a(this, "usage", 0);
    /**
     * The tags of the Sample.
     *
     * @generated from field: repeated string tags = 15;
     */
    a(this, "tags", []);
    /**
     * The underlying URL of the track to play (mp3 format).
     *
     * @generated from field: string mp3_url = 16;
     */
    a(this, "mp3Url", "");
    /**
     * The underlying URL of the track to play (wav format).
     *
     * @generated from field: string wav_url = 17;
     */
    a(this, "wavUrl", "");
    /**
     * The underlying URL of the track to play (mp3 format).
     *
     * @generated from field: string preview_mp3_url = 18;
     */
    a(this, "previewMp3Url", "");
    /**
     * The underlying URL of the track to play (flac format).
     *
     * @generated from field: string flac_url = 19;
     */
    a(this, "flacUrl", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new rt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new rt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new rt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(rt, t, n);
  }
};
a(rt, "runtime", r), a(rt, "typeName", "audiotool.sample.v1.Sample"), a(rt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "display_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "description",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "owner_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "favorited_by_user",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 6,
    name: "num_favorites",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 7,
    name: "num_usages",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "bpm",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  },
  { no: 9, name: "sample_type", kind: "enum", T: r.getEnumType(rn) },
  { no: 10, name: "play_duration", kind: "message", T: ja },
  { no: 11, name: "create_time", kind: "message", T: m },
  { no: 12, name: "update_time", kind: "message", T: m },
  { no: 13, name: "clearance", kind: "enum", T: r.getEnumType(sn) },
  { no: 14, name: "usage", kind: "enum", T: r.getEnumType(on) },
  { no: 15, name: "tags", kind: "scalar", T: 9, repeated: !0 },
  {
    no: 16,
    name: "mp3_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 17,
    name: "wav_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 18,
    name: "preview_mp3_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 19,
    name: "flac_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let l = rt;
const $a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Sample: l,
  SampleClearance: sn,
  SampleType: rn,
  SampleUsage: on
}, Symbol.toStringTag, { value: "Module" }));
var Ua = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.NONE = 1] = "NONE", i[i.INVALID_INPUT = 2] = "INVALID_INPUT", i[i.INTERNAL = 3] = "INTERNAL", i))(Ua || {});
r.util.setEnumType(Ua, "audiotool.sample.v1.SampleConvertDoneErrorType", [
  { no: 0, name: "SAMPLE_CONVERT_DONE_ERROR_TYPE_UNSPECIFIED" },
  { no: 1, name: "SAMPLE_CONVERT_DONE_ERROR_TYPE_NONE" },
  { no: 2, name: "SAMPLE_CONVERT_DONE_ERROR_TYPE_INVALID_INPUT" },
  { no: 3, name: "SAMPLE_CONVERT_DONE_ERROR_TYPE_INTERNAL" }
]);
const it = class it extends o {
  constructor(t) {
    super();
    /**
     * The ID of the event.
     *
     * @generated from field: string id = 1;
     */
    a(this, "id", "");
    /**
     * The time the event was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 2;
     */
    a(this, "createTime");
    /**
     * The type of the event.
     *
     * @generated from oneof audiotool.sample.v1.SampleEvent.event
     */
    a(this, "event", { case: void 0 });
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new it().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new it().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new it().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(it, t, n);
  }
};
a(it, "runtime", r), a(it, "typeName", "audiotool.sample.v1.SampleEvent"), a(it, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "create_time", kind: "message", T: m },
  { no: 3, name: "sample_convert_done", kind: "message", T: qn, oneof: "event" }
]));
let Yn = it;
const st = class st extends o {
  constructor(t) {
    super();
    /**
     * The user_name who uploaded the sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    /**
     * The type of error that happened during the conversion if any.
     *
     * @generated from field: audiotool.sample.v1.SampleConvertDoneErrorType error = 2;
     */
    a(this, "error", 0);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new st().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new st().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new st().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(st, t, n);
  }
};
a(st, "runtime", r), a(st, "typeName", "audiotool.sample.v1.SampleConvertDone"), a(st, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l },
  { no: 2, name: "error", kind: "enum", T: r.getEnumType(Ua) }
]));
let qn = st;
const ot = class ot extends o {
  constructor(t) {
    super();
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - sample.name
     * - sample.display_name
     * - sample.description
     * - sample.owner_name
     * - sample.num_favorites
     * - sample.num_usages
     * - sample.bpm
     * - sample.sample_type
     * - sample.play_duration
     * - sample.create_time
     * - sample.update_time
     * - sample.clearance
     * - sample.tags
     * - sample.favorited_by_user
     *
     * @generated from field: string filter = 4;
     */
    a(this, "filter", "");
    /**
     * The order to sort the results by.
     *
     * Supported fields:
     * - sample.name
     * - sample.display_name
     * - sample.description
     * - sample.owner_name
     * - sample.num_favorites
     * - sample.num_usages
     * - sample.bpm
     * - sample.sample_type
     * - sample.play_duration
     * - sample.create_time
     * - sample.update_time
     * - sample.clearance
     * - sample.tags
     *
     * @generated from field: string order_by = 5;
     */
    a(this, "orderBy", "");
    /**
     * An additional filter for matching text metadata
     *
     * Examples:
     * 'kepz & dub' : returns results matching both keywords
     * 'guitar & (jazz | funk)' : returns guitar samples tagged with either jazz or funk
     * '!bass & guitar & (jazz | funk)' : same as above but excludes samples matching "bass"
     *
     * @generated from field: string text_search = 6;
     */
    a(this, "textSearch", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new ot().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new ot().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new ot().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(ot, t, n);
  }
};
a(ot, "runtime", r), a(ot, "typeName", "audiotool.sample.v1.ListSamplesRequest"), a(ot, "fields", r.util.newFieldList(() => [
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "text_search",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Xn = ot;
const et = class et extends o {
  constructor(t) {
    super();
    /**
     * The list of samples.
     *
     * @generated from field: repeated audiotool.sample.v1.Sample samples = 1;
     */
    a(this, "samples", []);
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new et().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new et().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new et().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(et, t, n);
  }
};
a(et, "runtime", r), a(et, "typeName", "audiotool.sample.v1.ListSamplesResponse"), a(et, "fields", r.util.newFieldList(() => [
  { no: 1, name: "samples", kind: "message", T: l, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Dn = et;
const mt = class mt extends o {
  constructor(t) {
    super();
    /**
     * The sample to create.
     *
     * A client can provide a sample ID ahead of time. If provided, the server will use this ID
     * instead of generating a new one.
     *
     * The sample ID must be unique and in the pattern of `samples/{uuid-v4}`.
     *
     * If the sample ID is already in use there are two possible outcomes:
     * - the CreateSample RPC will error out
     * - Later on Processing of the data will fail (UploadSampleFinished and the async processing)
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new mt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new mt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new mt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(mt, t, n);
  }
};
a(mt, "runtime", r), a(mt, "typeName", "audiotool.sample.v1.CreateSampleRequest"), a(mt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l }
]));
let Rn = mt;
const ut = class ut extends o {
  constructor(t) {
    super();
    /**
     * The URL to upload the sample to. This represents the Base URL to make a request to.
     * The request must be sent using a PUT request
     *
     * If the client is finished with the upload it must call the `UploadSampleFinished` RPC.
     *
     * @generated from field: string upload_url = 1;
     */
    a(this, "uploadUrl", "");
    /**
     * Values is a key-value map of values to be sent with the request.
     *
     * @generated from field: map<string, string> headers = 2;
     */
    a(this, "headers", {});
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new ut().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new ut().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new ut().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(ut, t, n);
  }
};
a(ut, "runtime", r), a(ut, "typeName", "audiotool.sample.v1.SampleUploadEndpoint"), a(ut, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "upload_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "headers", kind: "map", K: 9, V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  } }
]));
let jn = ut;
const lt = class lt extends o {
  constructor(t) {
    super();
    /**
     * The created sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    /**
     * The upload endpoint.
     *
     * The sample will not be visible in List requests until the upload is finished and processed.
     * The client must call the `UploadSampleFinished` RPC to signal the server that the upload is
     * finished.
     *
     * If the upload doesn't happen within a certain time frame the server will delete the sample and
     * the endpoint will be invalid.
     *
     * The accepted data formats are:
     * - mp3
     * - wav
     * - flac
     * - ogg
     *
     * @generated from field: audiotool.sample.v1.SampleUploadEndpoint upload_endpoint = 2;
     */
    a(this, "uploadEndpoint");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new lt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new lt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new lt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(lt, t, n);
  }
};
a(lt, "runtime", r), a(lt, "typeName", "audiotool.sample.v1.CreateSampleResponse"), a(lt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l },
  { no: 2, name: "upload_endpoint", kind: "message", T: jn }
]));
let bn = lt;
const ct = class ct extends o {
  constructor(t) {
    super();
    /**
     * The name of the sample to be updated, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new ct().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new ct().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new ct().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(ct, t, n);
  }
};
a(ct, "runtime", r), a(ct, "typeName", "audiotool.sample.v1.UploadSampleFinishedRequest"), a(ct, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Gn = ct;
const dt = class dt extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new dt().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new dt().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new dt().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(dt, s, t);
  }
};
a(dt, "runtime", r), a(dt, "typeName", "audiotool.sample.v1.UploadSampleFinishedResponse"), a(dt, "fields", r.util.newFieldList(() => []));
let Kn = dt;
const ft = class ft extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the sample to be retrieved, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new ft().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new ft().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new ft().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(ft, t, n);
  }
};
a(ft, "runtime", r), a(ft, "typeName", "audiotool.sample.v1.GetSampleRequest"), a(ft, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let zn = ft;
const Et = class Et extends o {
  constructor(t) {
    super();
    /**
     * The sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Et().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Et().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Et().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Et, t, n);
  }
};
a(Et, "runtime", r), a(Et, "typeName", "audiotool.sample.v1.GetSampleResponse"), a(Et, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l }
]));
let Wn = Et;
const Tt = class Tt extends o {
  constructor(t) {
    super();
    /**
     * The sample
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    /**
     * The update mask
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    a(this, "updateMask");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Tt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Tt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Tt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Tt, t, n);
  }
};
a(Tt, "runtime", r), a(Tt, "typeName", "audiotool.sample.v1.UpdateSampleRequest"), a(Tt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l },
  { no: 2, name: "update_mask", kind: "message", T: Zt }
]));
let Qn = Tt;
const St = class St extends o {
  constructor(t) {
    super();
    /**
     * The updated sample.
     *
     * @generated from field: audiotool.sample.v1.Sample sample = 1;
     */
    a(this, "sample");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new St().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new St().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new St().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(St, t, n);
  }
};
a(St, "runtime", r), a(St, "typeName", "audiotool.sample.v1.UpdateSampleResponse"), a(St, "fields", r.util.newFieldList(() => [
  { no: 1, name: "sample", kind: "message", T: l }
]));
let Zn = St;
const wt = class wt extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the sample to be deleted, in the form `samples/{name}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new wt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new wt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new wt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(wt, t, n);
  }
};
a(wt, "runtime", r), a(wt, "typeName", "audiotool.sample.v1.DeleteSampleRequest"), a(wt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let $n = wt;
const Jt = class Jt extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new Jt().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new Jt().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new Jt().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(Jt, s, t);
  }
};
a(Jt, "runtime", r), a(Jt, "typeName", "audiotool.sample.v1.DeleteSampleResponse"), a(Jt, "fields", r.util.newFieldList(() => []));
let _n = Jt;
const gt = class gt extends o {
  constructor(t) {
    super();
    /**
     * The names of the sample to listen to, in the form `samples/{name}`.
     *
     * @generated from field: repeated string names = 1;
     */
    a(this, "names", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new gt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new gt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new gt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(gt, t, n);
  }
};
a(gt, "runtime", r), a(gt, "typeName", "audiotool.sample.v1.ListenRequest"), a(gt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "names", kind: "scalar", T: 9, repeated: !0 }
]));
let ta = gt;
const It = class It extends o {
  constructor(t) {
    super();
    /**
     * The sample.
     *
     * @generated from field: audiotool.sample.v1.SampleEvent event = 1;
     */
    a(this, "event");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new It().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new It().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new It().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(It, t, n);
  }
};
a(It, "runtime", r), a(It, "typeName", "audiotool.sample.v1.ListenResponse"), a(It, "fields", r.util.newFieldList(() => [
  { no: 1, name: "event", kind: "message", T: Yn }
]));
let na = It;
const _a = {
  typeName: "audiotool.sample.v1.SampleService",
  methods: {
    /**
     * Lists the samples.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.ListSamples
     */
    listSamples: {
      name: "ListSamples",
      I: Xn,
      O: Dn,
      kind: e.Unary
    },
    /**
     * Create a sample.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.CreateSample
     */
    createSample: {
      name: "CreateSample",
      I: Rn,
      O: bn,
      kind: e.Unary
    },
    /**
     * UploadSampleFinished is called from the client when the upload of a sample is finished so the
     * server can start processing the Data. An URL for the upload will be returned by CreateSample.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.UploadSampleFinished
     */
    uploadSampleFinished: {
      name: "UploadSampleFinished",
      I: Gn,
      O: Kn,
      kind: e.Unary
    },
    /**
     * Gets a sample.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.GetSample
     */
    getSample: {
      name: "GetSample",
      I: zn,
      O: Wn,
      kind: e.Unary
    },
    /**
     * Updates a sample.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.UpdateSample
     */
    updateSample: {
      name: "UpdateSample",
      I: Qn,
      O: Zn,
      kind: e.Unary
    },
    /**
     * Deletes a sample.
     *
     * A sample can be deleted if it is not used by a project (document-service) and if the user has
     * the correct permissions.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.DeleteSample
     */
    deleteSample: {
      name: "DeleteSample",
      I: $n,
      O: _n,
      kind: e.Unary
    },
    /**
     * Listen for samples.
     *
     * This is a server streaming RPC. The client sends a request and gets a stream of responses.
     * This can be used when a sample is created and announced as being uploaded in a
     * collaborative session, the other clients can listen for the sample and start processing it as
     * soon as it is ready.
     *
     * The server will have a history which lasts for a certain time frame and size and sends out
     * historical events to the client. This makes it easy to retrieve non-racy events.
     *
     * @generated from rpc audiotool.sample.v1.SampleService.Listen
     */
    listen: {
      name: "Listen",
      I: ta,
      O: na,
      kind: e.ServerStreaming
    }
  }
}, Ot = class Ot extends o {
  constructor(t) {
    super();
    /**
     * The unique name of the user.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The name of the user.
     *
     * @generated from field: string display_name = 2;
     */
    a(this, "displayName", "");
    /**
     * Output only. Timestamp when this User was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 3;
     */
    a(this, "createTime");
    /**
     * The description of the user.
     *
     * @generated from field: string description = 4;
     */
    a(this, "description", "");
    /**
     * The number of public tracks the user has.
     *
     * @generated from field: int32 num_tracks = 5;
     */
    a(this, "numTracks", 0);
    /**
     * The number of public albums the user has.
     *
     * @generated from field: int32 num_albums = 6;
     */
    a(this, "numAlbums", 0);
    /**
     * The number of followers the user has.
     *
     * @generated from field: int32 num_followers = 7;
     */
    a(this, "numFollowers", 0);
    /**
     * The number of users the user is following.
     *
     * @generated from field: int32 num_following = 8;
     */
    a(this, "numFollowing", 0);
    /**
     * The tags of the user
     *
     * @generated from field: repeated string tags = 9;
     */
    a(this, "tags", []);
    /**
     * The avatar URL of the user.
     *
     * you can append `?width=256&height=256&fit=cover&format=webp` to the URL for resizing
     * (current restriction - this is only able for for CDNs > 2)
     *
     * @generated from field: string avatar_url = 10;
     */
    a(this, "avatarUrl", "");
    /**
     * The links of the user
     *
     * @generated from field: repeated string links = 11;
     */
    a(this, "links", []);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Ot().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Ot().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Ot().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Ot, t, n);
  }
};
a(Ot, "runtime", r), a(Ot, "typeName", "audiotool.user.v1.User"), a(Ot, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "display_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "create_time", kind: "message", T: m },
  {
    no: 4,
    name: "description",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "num_tracks",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 6,
    name: "num_albums",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 7,
    name: "num_followers",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "num_following",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 9, name: "tags", kind: "scalar", T: 9, repeated: !0 },
  {
    no: 10,
    name: "avatar_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 11, name: "links", kind: "scalar", T: 9, repeated: !0 }
]));
let Qt = Ot;
var $t = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.PUBLIC = 1] = "PUBLIC", i[i.USERS_FOLLOWING = 2] = "USERS_FOLLOWING", i[i.DISABLED = 3] = "DISABLED", i))($t || {});
r.util.setEnumType($t, "audiotool.user.v1.CommentMode", [
  { no: 0, name: "COMMENT_MODE_UNSPECIFIED" },
  { no: 1, name: "COMMENT_MODE_PUBLIC" },
  { no: 2, name: "COMMENT_MODE_USERS_FOLLOWING" },
  { no: 3, name: "COMMENT_MODE_DISABLED" }
]);
const Nt = class Nt extends o {
  constructor(t) {
    super();
    /**
     * The mode of the comments user's page.
     *
     * @generated from field: audiotool.user.v1.CommentMode user_page_comment_mode = 1;
     */
    a(this, "userPageCommentMode", 0);
    /**
     * The mode of the comments on the user's tracks.
     *
     * @generated from field: audiotool.user.v1.CommentMode default_track_comment_mode = 2;
     */
    a(this, "defaultTrackCommentMode", 0);
    /**
     * The mode of the comments on the user's playlists.
     *
     * @generated from field: audiotool.user.v1.CommentMode default_playlist_comment_mode = 3;
     */
    a(this, "defaultPlaylistCommentMode", 0);
    /**
     * Show online status.
     *
     * @generated from field: bool show_online_status = 4;
     */
    a(this, "showOnlineStatus", !1);
    /**
     * Show as listener of tracks.
     *
     * @generated from field: bool show_as_listener = 5;
     */
    a(this, "showAsListener", !1);
    /**
     * User is subscribed to the Audiotool newsletter.
     *
     * @generated from field: bool newsletter_subscriber = 6;
     */
    a(this, "newsletterSubscriber", !1);
    /**
     * Whether to allow links posted in comments on user page.
     *
     * @generated from field: bool allow_links_on_user_page_comments = 7;
     */
    a(this, "allowLinksOnUserPageComments", !1);
    /**
     * Whether to allow links posted in comments on tracks.
     *
     * @generated from field: bool allow_links_on_track_comments = 8;
     */
    a(this, "allowLinksOnTrackComments", !1);
    /**
     * Whether to allow links posted in comments on playlists.
     *
     * @generated from field: bool allow_links_on_playlist_comments = 9;
     */
    a(this, "allowLinksOnPlaylistComments", !1);
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Nt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Nt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Nt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Nt, t, n);
  }
};
a(Nt, "runtime", r), a(Nt, "typeName", "audiotool.user.v1.Settings"), a(Nt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "user_page_comment_mode", kind: "enum", T: r.getEnumType($t) },
  { no: 2, name: "default_track_comment_mode", kind: "enum", T: r.getEnumType($t) },
  { no: 3, name: "default_playlist_comment_mode", kind: "enum", T: r.getEnumType($t) },
  {
    no: 4,
    name: "show_online_status",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 5,
    name: "show_as_listener",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 6,
    name: "newsletter_subscriber",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 7,
    name: "allow_links_on_user_page_comments",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 8,
    name: "allow_links_on_track_comments",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 9,
    name: "allow_links_on_playlist_comments",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]));
let nn = Nt;
const kt = class kt extends o {
  constructor(t) {
    super();
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - user.name
     * - user.display_name
     * - user.create_time
     * - user.description
     * - user.tags
     * - user.links
     * - user.num_tracks
     * - user.num_albums
     * - user.num_followers
     * - user.num_following
     *
     * @generated from field: string filter = 1;
     */
    a(this, "filter", "");
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The order to list results by.
     *
     * Supported fields:
     * - user.name
     * - user.display_name
     * - user.create_time
     * - user.description
     * - user.tags
     * - user.links
     * - user.num_tracks
     * - user.num_albums
     * - user.num_followers
     * - user.num_following
     *
     * @generated from field: string order_by = 4;
     */
    a(this, "orderBy", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new kt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new kt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new kt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(kt, t, n);
  }
};
a(kt, "runtime", r), a(kt, "typeName", "audiotool.user.v1.ListUsersRequest"), a(kt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let aa = kt;
const yt = class yt extends o {
  constructor(t) {
    super();
    /**
     * The list of Albums
     *
     * @generated from field: repeated audiotool.user.v1.User users = 1;
     */
    a(this, "users", []);
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new yt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new yt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new yt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(yt, t, n);
  }
};
a(yt, "runtime", r), a(yt, "typeName", "audiotool.user.v1.ListUsersResponse"), a(yt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "users", kind: "message", T: Qt, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let ra = yt;
const Bt = class Bt extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the user to be retrieved, in the form  of `users/{user}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Bt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Bt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Bt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Bt, t, n);
  }
};
a(Bt, "runtime", r), a(Bt, "typeName", "audiotool.user.v1.GetUserRequest"), a(Bt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let ia = Bt;
const Pt = class Pt extends o {
  constructor(t) {
    super();
    /**
     * The user.
     *
     * @generated from field: audiotool.user.v1.User user = 1;
     */
    a(this, "user");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Pt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Pt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Pt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Pt, t, n);
  }
};
a(Pt, "runtime", r), a(Pt, "typeName", "audiotool.user.v1.GetUserResponse"), a(Pt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "user", kind: "message", T: Qt }
]));
let sa = Pt;
const At = class At extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the user to be deleted, in the form  of `users/{user}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new At().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new At().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new At().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(At, t, n);
  }
};
a(At, "runtime", r), a(At, "typeName", "audiotool.user.v1.DeleteUserRequest"), a(At, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let oa = At;
const Lt = class Lt extends o {
  constructor(t) {
    super();
    /**
     * The user.
     *
     * @generated from field: audiotool.user.v1.User user = 1;
     */
    a(this, "user");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Lt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Lt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Lt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Lt, t, n);
  }
};
a(Lt, "runtime", r), a(Lt, "typeName", "audiotool.user.v1.DeleteUserResponse"), a(Lt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "user", kind: "message", T: Qt }
]));
let ea = Lt;
const pt = class pt extends o {
  constructor(t) {
    super();
    /**
     * The user to update.
     *
     * @generated from field: audiotool.user.v1.User user = 1;
     */
    a(this, "user");
    /**
     * The update mask
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    a(this, "updateMask");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new pt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new pt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new pt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(pt, t, n);
  }
};
a(pt, "runtime", r), a(pt, "typeName", "audiotool.user.v1.UpdateUserRequest"), a(pt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "user", kind: "message", T: Qt },
  { no: 2, name: "update_mask", kind: "message", T: Zt }
]));
let ma = pt;
const Ft = class Ft extends o {
  constructor(t) {
    super();
    /**
     * The user.
     *
     * @generated from field: audiotool.user.v1.User user = 1;
     */
    a(this, "user");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Ft().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Ft().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Ft().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Ft, t, n);
  }
};
a(Ft, "runtime", r), a(Ft, "typeName", "audiotool.user.v1.UpdateUserResponse"), a(Ft, "fields", r.util.newFieldList(() => [
  { no: 1, name: "user", kind: "message", T: Qt }
]));
let ua = Ft;
const Ut = class Ut extends o {
  constructor(t) {
    super();
    /**
     * The name of the settings resource.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Ut().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Ut().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Ut().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Ut, t, n);
  }
};
a(Ut, "runtime", r), a(Ut, "typeName", "audiotool.user.v1.GetSettingsRequest"), a(Ut, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let la = Ut;
const Ct = class Ct extends o {
  constructor(t) {
    super();
    /**
     * The settings of the user.
     *
     * @generated from field: audiotool.user.v1.Settings settings = 1;
     */
    a(this, "settings");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Ct().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Ct().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Ct().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Ct, t, n);
  }
};
a(Ct, "runtime", r), a(Ct, "typeName", "audiotool.user.v1.GetSettingsResponse"), a(Ct, "fields", r.util.newFieldList(() => [
  { no: 1, name: "settings", kind: "message", T: nn }
]));
let ca = Ct;
const xt = class xt extends o {
  constructor(t) {
    super();
    /**
     * The name of the settings resource.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The settings of the user.
     *
     * @generated from field: audiotool.user.v1.Settings settings = 2;
     */
    a(this, "settings");
    /**
     * The update mask to apply to the settings.
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 3;
     */
    a(this, "updateMask");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new xt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new xt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new xt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(xt, t, n);
  }
};
a(xt, "runtime", r), a(xt, "typeName", "audiotool.user.v1.UpdateSettingsRequest"), a(xt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "settings", kind: "message", T: nn },
  { no: 3, name: "update_mask", kind: "message", T: Zt }
]));
let da = xt;
const Mt = class Mt extends o {
  constructor(t) {
    super();
    /**
     * The settings of the user.
     *
     * @generated from field: audiotool.user.v1.Settings settings = 1;
     */
    a(this, "settings");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Mt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Mt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Mt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Mt, t, n);
  }
};
a(Mt, "runtime", r), a(Mt, "typeName", "audiotool.user.v1.UpdateSettingsResponse"), a(Mt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "settings", kind: "message", T: nn }
]));
let fa = Mt;
const ht = class ht extends o {
  constructor(t) {
    super();
    /**
     * The sample to upload. The data format will be automatically detected.
     * the following formats are supported:
     * - JPEG
     * - PNG
     * - WEBP
     *
     * @generated from field: bytes data = 1;
     */
    a(this, "data", new Uint8Array(0));
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new ht().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new ht().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new ht().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(ht, t, n);
  }
};
a(ht, "runtime", r), a(ht, "typeName", "audiotool.user.v1.UploadAvatarRequest"), a(ht, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "data",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]));
let Ea = ht;
const Vt = class Vt extends o {
  constructor(t) {
    super();
    /**
     * Location of avatar that was uploaded
     *
     * @generated from field: string avatar_url = 1;
     */
    a(this, "avatarUrl", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Vt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Vt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Vt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Vt, t, n);
  }
};
a(Vt, "runtime", r), a(Vt, "typeName", "audiotool.user.v1.UploadAvatarResponse"), a(Vt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "avatar_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Ta = Vt;
const tr = {
  typeName: "audiotool.user.v1.UserService",
  methods: {
    /**
     * Lists the users.
     *
     * @generated from rpc audiotool.user.v1.UserService.ListUsers
     */
    listUsers: {
      name: "ListUsers",
      I: aa,
      O: ra,
      kind: e.Unary
    },
    /**
     * Gets a user.
     *
     * @generated from rpc audiotool.user.v1.UserService.GetUser
     */
    getUser: {
      name: "GetUser",
      I: ia,
      O: sa,
      kind: e.Unary
    },
    /**
     * Delete a user.
     *
     * @generated from rpc audiotool.user.v1.UserService.DeleteUser
     */
    deleteUser: {
      name: "DeleteUser",
      I: oa,
      O: ea,
      kind: e.Unary
    },
    /**
     * Update a user.
     *
     * @generated from rpc audiotool.user.v1.UserService.UpdateUser
     */
    updateUser: {
      name: "UpdateUser",
      I: ma,
      O: ua,
      kind: e.Unary
    },
    /**
     * Get the settings of a user.
     *
     * @generated from rpc audiotool.user.v1.UserService.GetSettings
     */
    getSettings: {
      name: "GetSettings",
      I: la,
      O: ca,
      kind: e.Unary
    },
    /**
     * Update the settings of a user.
     *
     * @generated from rpc audiotool.user.v1.UserService.UpdateSettings
     */
    updateSettings: {
      name: "UpdateSettings",
      I: da,
      O: fa,
      kind: e.Unary
    },
    /**
     * Upload an avatar for the logged in user.
     *
     * @generated from rpc audiotool.user.v1.UserService.UploadAvatar
     */
    uploadAvatar: {
      name: "UploadAvatar",
      I: Ea,
      O: Ta,
      kind: e.Unary
    }
  }
};
var Ca = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.AUTO_FILTER = 1] = "AUTO_FILTER", i[i.BAND_SPLITTER = 2] = "BAND_SPLITTER", i[i.BASSLINE = 3] = "BASSLINE", i[i.BEATBOX8 = 4] = "BEATBOX8", i[i.BEATBOX9 = 5] = "BEATBOX9", i[i.CROSSFADER = 6] = "CROSSFADER", i[i.CURVE = 7] = "CURVE", i[i.EXCITER = 8] = "EXCITER", i[i.GRAPHICAL_EQ = 9] = "GRAPHICAL_EQ", i[i.GRAVITY = 10] = "GRAVITY", i[i.HEISENBERG = 11] = "HEISENBERG", i[i.HELMHOLTZ = 12] = "HELMHOLTZ", i[i.MACHINISTE = 13] = "MACHINISTE", i[i.MATRIX = 14] = "MATRIX", i[i.NOTE_SPLITTER = 15] = "NOTE_SPLITTER", i[i.PANORAMA = 16] = "PANORAMA", i[i.PULSAR = 17] = "PULSAR", i[i.PULVERISATEUR = 18] = "PULVERISATEUR", i[i.QUANTUM = 19] = "QUANTUM", i[i.QUASAR = 20] = "QUASAR", i[i.RASSELBOCK = 21] = "RASSELBOCK", i[i.SPACE = 22] = "SPACE", i[i.STEREO_ENHANCER = 23] = "STEREO_ENHANCER", i[i.STOMPBOX_CHORUS = 24] = "STOMPBOX_CHORUS", i[i.STOMPBOX_COMPRESSOR = 25] = "STOMPBOX_COMPRESSOR", i[i.STOMPBOX_CRUSHER = 26] = "STOMPBOX_CRUSHER", i[i.STOMPBOX_DELAY = 27] = "STOMPBOX_DELAY", i[i.STOMPBOX_FLANGER = 28] = "STOMPBOX_FLANGER", i[i.STOMPBOX_GATE = 29] = "STOMPBOX_GATE", i[i.STOMPBOX_PARAMETRIC_EQUALIZER = 30] = "STOMPBOX_PARAMETRIC_EQUALIZER", i[i.STOMPBOX_PHASER = 31] = "STOMPBOX_PHASER", i[i.STOMPBOX_PITCH_DELAY = 32] = "STOMPBOX_PITCH_DELAY", i[i.STOMPBOX_REVERB = 33] = "STOMPBOX_REVERB", i[i.STOMPBOX_SLOPE = 34] = "STOMPBOX_SLOPE", i[i.STOMPBOX_STEREO_DETUNE = 35] = "STOMPBOX_STEREO_DETUNE", i[i.STOMPBOX_TUBE = 36] = "STOMPBOX_TUBE", i[i.TONEMATRIX = 37] = "TONEMATRIX", i[i.WAVESHAPER = 38] = "WAVESHAPER", i[i.GAKKI = 39] = "GAKKI", i))(Ca || {});
r.util.setEnumType(Ca, "audiotool.preset.v1.PresetDeviceType", [
  { no: 0, name: "PRESET_DEVICE_TYPE_UNSPECIFIED" },
  { no: 1, name: "PRESET_DEVICE_TYPE_AUTO_FILTER" },
  { no: 2, name: "PRESET_DEVICE_TYPE_BAND_SPLITTER" },
  { no: 3, name: "PRESET_DEVICE_TYPE_BASSLINE" },
  { no: 4, name: "PRESET_DEVICE_TYPE_BEATBOX8" },
  { no: 5, name: "PRESET_DEVICE_TYPE_BEATBOX9" },
  { no: 6, name: "PRESET_DEVICE_TYPE_CROSSFADER" },
  { no: 7, name: "PRESET_DEVICE_TYPE_CURVE" },
  { no: 8, name: "PRESET_DEVICE_TYPE_EXCITER" },
  { no: 9, name: "PRESET_DEVICE_TYPE_GRAPHICAL_EQ" },
  { no: 10, name: "PRESET_DEVICE_TYPE_GRAVITY" },
  { no: 11, name: "PRESET_DEVICE_TYPE_HEISENBERG" },
  { no: 12, name: "PRESET_DEVICE_TYPE_HELMHOLTZ" },
  { no: 13, name: "PRESET_DEVICE_TYPE_MACHINISTE" },
  { no: 14, name: "PRESET_DEVICE_TYPE_MATRIX" },
  { no: 15, name: "PRESET_DEVICE_TYPE_NOTE_SPLITTER" },
  { no: 16, name: "PRESET_DEVICE_TYPE_PANORAMA" },
  { no: 17, name: "PRESET_DEVICE_TYPE_PULSAR" },
  { no: 18, name: "PRESET_DEVICE_TYPE_PULVERISATEUR" },
  { no: 19, name: "PRESET_DEVICE_TYPE_QUANTUM" },
  { no: 20, name: "PRESET_DEVICE_TYPE_QUASAR" },
  { no: 21, name: "PRESET_DEVICE_TYPE_RASSELBOCK" },
  { no: 22, name: "PRESET_DEVICE_TYPE_SPACE" },
  { no: 23, name: "PRESET_DEVICE_TYPE_STEREO_ENHANCER" },
  { no: 24, name: "PRESET_DEVICE_TYPE_STOMPBOX_CHORUS" },
  { no: 25, name: "PRESET_DEVICE_TYPE_STOMPBOX_COMPRESSOR" },
  { no: 26, name: "PRESET_DEVICE_TYPE_STOMPBOX_CRUSHER" },
  { no: 27, name: "PRESET_DEVICE_TYPE_STOMPBOX_DELAY" },
  { no: 28, name: "PRESET_DEVICE_TYPE_STOMPBOX_FLANGER" },
  { no: 29, name: "PRESET_DEVICE_TYPE_STOMPBOX_GATE" },
  { no: 30, name: "PRESET_DEVICE_TYPE_STOMPBOX_PARAMETRIC_EQUALIZER" },
  { no: 31, name: "PRESET_DEVICE_TYPE_STOMPBOX_PHASER" },
  { no: 32, name: "PRESET_DEVICE_TYPE_STOMPBOX_PITCH_DELAY" },
  { no: 33, name: "PRESET_DEVICE_TYPE_STOMPBOX_REVERB" },
  { no: 34, name: "PRESET_DEVICE_TYPE_STOMPBOX_SLOPE" },
  { no: 35, name: "PRESET_DEVICE_TYPE_STOMPBOX_STEREO_DETUNE" },
  { no: 36, name: "PRESET_DEVICE_TYPE_STOMPBOX_TUBE" },
  { no: 37, name: "PRESET_DEVICE_TYPE_TONEMATRIX" },
  { no: 38, name: "PRESET_DEVICE_TYPE_WAVESHAPER" },
  { no: 39, name: "PRESET_DEVICE_TYPE_GAKKI" }
]);
var xa = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.PUBLIC = 1] = "PUBLIC", i[i.UNLISTED = 2] = "UNLISTED", i[i.PRIVATE = 3] = "PRIVATE", i))(xa || {});
r.util.setEnumType(xa, "audiotool.preset.v1.PresetUsage", [
  { no: 0, name: "PRESET_USAGE_UNSPECIFIED" },
  { no: 1, name: "PRESET_USAGE_PUBLIC" },
  { no: 2, name: "PRESET_USAGE_UNLISTED" },
  { no: 3, name: "PRESET_USAGE_PRIVATE" }
]);
const Ht = class Ht extends o {
  constructor(t) {
    super();
    /**
     * The Preset name.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    /**
     * The display name of the Preset.
     *
     * @generated from field: string display_name = 2;
     */
    a(this, "displayName", "");
    /**
     * The description of the Preset.
     *
     * @generated from field: string description = 3;
     */
    a(this, "description", "");
    /**
     * The owner of the Preset in the format of `users/{user}`.
     *
     * @generated from field: string owner_name = 4;
     */
    a(this, "ownerName", "");
    /**
     * Whether the authed user liked the Preset.
     *
     * This is only exposed if the user is authenticated. The user can like a Preset via
     * Favorite API.
     *
     * @generated from field: bool favorited_by_user = 5;
     */
    a(this, "favoritedByUser", !1);
    /**
     * The number of favorites of the Preset.
     *
     * @generated from field: int32 num_favorites = 6;
     */
    a(this, "numFavorites", 0);
    /**
     * The number of usages of the Preset in a track. If a Preset is used in a track, the usage will
     * be increased. On the other hand the number will not be decreased if the a preset is removed or
     * changed in a track.
     *
     * @generated from field: int32 num_usages = 7;
     */
    a(this, "numUsages", 0);
    /**
     * Output only. Timestamp when this Preset was created.
     *
     * @generated from field: google.protobuf.Timestamp create_time = 8;
     */
    a(this, "createTime");
    /**
     * Output only. Timestamp when this Preset was last updated.
     *
     * The underlying audio can't be changed. Only some metadata (of this message) can be changed.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 9;
     */
    a(this, "updateTime");
    /**
     * The usage of the Preset.
     *
     * @generated from field: audiotool.preset.v1.PresetUsage usage = 10;
     */
    a(this, "usage", 0);
    /**
     * The tags of the Preset.
     *
     * @generated from field: repeated string tags = 11;
     */
    a(this, "tags", []);
    /**
     * The type of devices used.
     *
     * This contains the list of devices used in the data blob.
     *
     * @generated from field: audiotool.preset.v1.PresetDeviceType device_type = 12;
     */
    a(this, "deviceType", 0);
    /**
     * URL pointing to the serialized preset data. This is a serialized proto.Any blob
     * produced by the document-service.
     *
     * @generated from field: string data_url = 13;
     */
    a(this, "dataUrl", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Ht().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Ht().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Ht().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Ht, t, n);
  }
};
a(Ht, "runtime", r), a(Ht, "typeName", "audiotool.preset.v1.Preset"), a(Ht, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "display_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "description",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "owner_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "favorited_by_user",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 6,
    name: "num_favorites",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 7,
    name: "num_usages",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 8, name: "create_time", kind: "message", T: m },
  { no: 9, name: "update_time", kind: "message", T: m },
  { no: 10, name: "usage", kind: "enum", T: r.getEnumType(xa) },
  { no: 11, name: "tags", kind: "scalar", T: 9, repeated: !0 },
  { no: 12, name: "device_type", kind: "enum", T: r.getEnumType(Ca) },
  {
    no: 13,
    name: "data_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let zt = Ht;
const vt = class vt extends o {
  constructor(t) {
    super();
    /**
     * The standard CEL filter.
     *
     * Supported fields:
     * - preset.name
     * - preset.display_name
     * - preset.description
     * - preset.owner_name
     * - preset.num_favorites
     * - preset.num_usages
     * - preset.create_time
     * - preset.update_time
     * - preset.clearance
     * - preset.tags
     * - preset.device_type
     * - preset.favorited_by_user
     *
     * @generated from field: string filter = 1;
     */
    a(this, "filter", "");
    /**
     * The maximum number of items to return.
     *
     * @generated from field: int32 page_size = 2;
     */
    a(this, "pageSize", 0);
    /**
     * The next_page_token value returned from a previous List request, if any.
     *
     * @generated from field: string page_token = 3;
     */
    a(this, "pageToken", "");
    /**
     * The order to list results by.
     *
     * @generated from field: string order_by = 4;
     */
    a(this, "orderBy", "");
    /**
     * An additional full-text search over metadata. Operates on a tokenized index.
     *
     * Examples:
     * - 'kepz & techno' returns results matching both tokens
     * - 'guitar & (jazz | funk)' returns guitar presets tagged with either jazz or funk
     * - '!bass & guitar & (jazz | funk)' excludes presets matching "bass"
     *
     * @generated from field: string text_search = 5;
     */
    a(this, "textSearch", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new vt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new vt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new vt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(vt, t, n);
  }
};
a(vt, "runtime", r), a(vt, "typeName", "audiotool.preset.v1.ListPresetsRequest"), a(vt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "filter",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "page_size",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 3,
    name: "page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 4,
    name: "order_by",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "text_search",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Sa = vt;
const Yt = class Yt extends o {
  constructor(t) {
    super();
    /**
     * The list of presets.
     *
     * @generated from field: repeated audiotool.preset.v1.Preset presets = 1;
     */
    a(this, "presets", []);
    /**
     * Token to retrieve the next page of results, or empty if there are no more results in the
     * list.
     *
     * @generated from field: string next_page_token = 2;
     */
    a(this, "nextPageToken", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Yt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Yt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Yt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Yt, t, n);
  }
};
a(Yt, "runtime", r), a(Yt, "typeName", "audiotool.preset.v1.ListPresetsResponse"), a(Yt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "presets", kind: "message", T: zt, repeated: !0 },
  {
    no: 2,
    name: "next_page_token",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let wa = Yt;
const qt = class qt extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the preset to be retrieved, in the form of `presets/{preset}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new qt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new qt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new qt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(qt, t, n);
  }
};
a(qt, "runtime", r), a(qt, "typeName", "audiotool.preset.v1.GetPresetRequest"), a(qt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let Ja = qt;
const Xt = class Xt extends o {
  constructor(t) {
    super();
    /**
     * The preset.
     *
     * @generated from field: audiotool.preset.v1.Preset preset = 1;
     */
    a(this, "preset");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Xt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Xt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Xt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Xt, t, n);
  }
};
a(Xt, "runtime", r), a(Xt, "typeName", "audiotool.preset.v1.GetPresetResponse"), a(Xt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "preset", kind: "message", T: zt }
]));
let ga = Xt;
const Dt = class Dt extends o {
  constructor(t) {
    super();
    /**
     * The preset to create.
     *
     * @generated from field: audiotool.preset.v1.Preset preset = 1;
     */
    a(this, "preset");
    /**
     * The serialized configuration blob of the Preset (document-service).
     *
     * @generated from field: google.protobuf.Any data = 2;
     */
    a(this, "data");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Dt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Dt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Dt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Dt, t, n);
  }
};
a(Dt, "runtime", r), a(Dt, "typeName", "audiotool.preset.v1.CreatePresetRequest"), a(Dt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "preset", kind: "message", T: zt },
  { no: 2, name: "data", kind: "message", T: _t }
]));
let Ia = Dt;
const Rt = class Rt extends o {
  constructor(t) {
    super();
    /**
     * The created preset.
     *
     * @generated from field: audiotool.preset.v1.Preset preset = 1;
     */
    a(this, "preset");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Rt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Rt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Rt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Rt, t, n);
  }
};
a(Rt, "runtime", r), a(Rt, "typeName", "audiotool.preset.v1.CreatePresetResponse"), a(Rt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "preset", kind: "message", T: zt }
]));
let Oa = Rt;
const jt = class jt extends o {
  constructor(t) {
    super();
    /**
     * The preset
     *
     * @generated from field: audiotool.preset.v1.Preset preset = 1;
     */
    a(this, "preset");
    /**
     * The update mask
     *
     * @generated from field: google.protobuf.FieldMask update_mask = 2;
     */
    a(this, "updateMask");
    /**
     * The serialized configuration blob of the Preset (document-service).
     *
     * If empty, the configuration is not updated.
     *
     * @generated from field: google.protobuf.Any data = 3;
     */
    a(this, "data");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new jt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new jt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new jt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(jt, t, n);
  }
};
a(jt, "runtime", r), a(jt, "typeName", "audiotool.preset.v1.UpdatePresetRequest"), a(jt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "preset", kind: "message", T: zt },
  { no: 2, name: "update_mask", kind: "message", T: Zt },
  { no: 3, name: "data", kind: "message", T: _t }
]));
let Na = jt;
const bt = class bt extends o {
  constructor(t) {
    super();
    /**
     * The updated preset.
     *
     * @generated from field: audiotool.preset.v1.Preset preset = 1;
     */
    a(this, "preset");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new bt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new bt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new bt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(bt, t, n);
  }
};
a(bt, "runtime", r), a(bt, "typeName", "audiotool.preset.v1.UpdatePresetResponse"), a(bt, "fields", r.util.newFieldList(() => [
  { no: 1, name: "preset", kind: "message", T: zt }
]));
let ka = bt;
const Gt = class Gt extends o {
  constructor(t) {
    super();
    /**
     * Required. The name of the preset to be deleted, in the form of `presets/{preset}`.
     *
     * @generated from field: string name = 1;
     */
    a(this, "name", "");
    r.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new Gt().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new Gt().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new Gt().fromJsonString(t, n);
  }
  static equals(t, n) {
    return r.util.equals(Gt, t, n);
  }
};
a(Gt, "runtime", r), a(Gt, "typeName", "audiotool.preset.v1.DeletePresetRequest"), a(Gt, "fields", r.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]));
let ya = Gt;
const Kt = class Kt extends o {
  constructor(s) {
    super(), r.util.initPartial(s, this);
  }
  static fromBinary(s, t) {
    return new Kt().fromBinary(s, t);
  }
  static fromJson(s, t) {
    return new Kt().fromJson(s, t);
  }
  static fromJsonString(s, t) {
    return new Kt().fromJsonString(s, t);
  }
  static equals(s, t) {
    return r.util.equals(Kt, s, t);
  }
};
a(Kt, "runtime", r), a(Kt, "typeName", "audiotool.preset.v1.DeletePresetResponse"), a(Kt, "fields", r.util.newFieldList(() => []));
let Ba = Kt;
const nr = {
  typeName: "audiotool.preset.v1.PresetService",
  methods: {
    /**
     * Lists the presets.
     *
     * @generated from rpc audiotool.preset.v1.PresetService.ListPresets
     */
    listPresets: {
      name: "ListPresets",
      I: Sa,
      O: wa,
      kind: e.Unary
    },
    /**
     * Gets a preset.
     *
     * @generated from rpc audiotool.preset.v1.PresetService.GetPreset
     */
    getPreset: {
      name: "GetPreset",
      I: Ja,
      O: ga,
      kind: e.Unary
    },
    /**
     * Create a preset.
     *
     * @generated from rpc audiotool.preset.v1.PresetService.CreatePreset
     */
    createPreset: {
      name: "CreatePreset",
      I: Ia,
      O: Oa,
      kind: e.Unary
    },
    /**
     * Update a preset.
     *
     * @generated from rpc audiotool.preset.v1.PresetService.UpdatePreset
     */
    updatePreset: {
      name: "UpdatePreset",
      I: Na,
      O: ka,
      kind: e.Unary
    },
    /**
     * Deletes a preset.
     *
     * A preset can always be deleted. If the preset is in use by a project,
     * the project must handle the missing link to the preset.
     *
     * @generated from rpc audiotool.preset.v1.PresetService.DeletePreset
     */
    deletePreset: {
      name: "DeletePreset",
      I: ya,
      O: Ba,
      kind: e.Unary
    }
  }
};
export {
  xn as $,
  ta as A,
  na as B,
  $t as C,
  oa as D,
  Ua as E,
  Yn as F,
  ia as G,
  qn as H,
  an as I,
  gn as J,
  In as K,
  aa as L,
  On as M,
  Nn as N,
  kn as O,
  u as P,
  yn as Q,
  Bn as R,
  Fa as S,
  Pn as T,
  ma as U,
  An as V,
  Ln as W,
  pn as X,
  Fn as Y,
  Un as Z,
  Cn as _,
  ra as a,
  Ma as a0,
  ha as a1,
  Mn as a2,
  hn as a3,
  Vn as a4,
  Hn as a5,
  cn as a6,
  dn as a7,
  fn as a8,
  En as a9,
  tr as aA,
  _a as aB,
  Za as aC,
  Qa as aD,
  nr as aE,
  Wa as aF,
  Tn as aa,
  Sn as ab,
  wn as ac,
  Jn as ad,
  La as ae,
  Wt as af,
  pa as ag,
  Sa as ah,
  wa as ai,
  Ja as aj,
  ga as ak,
  Ia as al,
  Oa as am,
  Na as an,
  ka as ao,
  ya as ap,
  Ba as aq,
  Ca as ar,
  xa as as,
  zt as at,
  Pa as au,
  Aa as av,
  un as aw,
  ln as ax,
  en as ay,
  mn as az,
  sa as b,
  ea as c,
  ua as d,
  la as e,
  ca as f,
  da as g,
  fa as h,
  Ea as i,
  Ta as j,
  Qt as k,
  nn as l,
  Xn as m,
  Dn as n,
  Rn as o,
  jn as p,
  bn as q,
  Gn as r,
  $a as s,
  Kn as t,
  zn as u,
  Wn as v,
  Qn as w,
  Zn as x,
  $n as y,
  _n as z
};
