var U = Object.defineProperty;
var W = (i, a, t) => a in i ? U(i, a, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[a] = t;
var e = (i, a, t) => W(i, typeof a != "symbol" ? a + "" : a, t);
import { proto3 as o, Message as s, FieldOptions as v, MessageOptions as $ } from "@bufbuild/protobuf";
var h = /* @__PURE__ */ ((i) => (i[i.Groove = 0] = "Groove", i[i.Sample = 1] = "Sample", i[i.MicroTuning = 2] = "MicroTuning", i[i.Listenable = 3] = "Listenable", i[i.AutomatableParameter = 4] = "AutomatableParameter", i[i.AudioInput = 6] = "AudioInput", i[i.AudioOutput = 7] = "AudioOutput", i[i.NotesInput = 8] = "NotesInput", i[i.NotesOutput = 9] = "NotesOutput", i[i.AutomationCollection = 10] = "AutomationCollection", i[i.AudioTrack = 11] = "AudioTrack", i[i.AudioTrackPlayer = 12] = "AudioTrackPlayer", i[i.PatternTrack = 13] = "PatternTrack", i[i.PatternTrackPlayer = 14] = "PatternTrackPlayer", i[i.NoteCollection = 16] = "NoteCollection", i[i.NoteTrack = 17] = "NoteTrack", i[i.NoteTrackPlayer = 18] = "NoteTrackPlayer", i[i.AutomationTrack = 19] = "AutomationTrack", i[i.Waveshaper = 20] = "Waveshaper", i[i.Centroid = 21] = "Centroid", i[i.RasselbockPatternSlot = 22] = "RasselbockPatternSlot", i[i.TonematrixPatternSlot = 23] = "TonematrixPatternSlot", i[i.Beatbox8PatternSlot = 24] = "Beatbox8PatternSlot", i[i.Beatbox9PatternSlot = 25] = "Beatbox9PatternSlot", i[i.BasslinePatternSlot = 26] = "BasslinePatternSlot", i[i.MachinistePatternSlot = 27] = "MachinistePatternSlot", i[i.MatrixArpeggiatorPatternSlot = 28] = "MatrixArpeggiatorPatternSlot", i[i.MixerStripGroup = 29] = "MixerStripGroup", i[i.MixerStripGroupChild = 30] = "MixerStripGroupChild", i[i.MixerSideChainInput = 31] = "MixerSideChainInput", i[i.MixerSideChainOutput = 32] = "MixerSideChainOutput", i[i.MixerAuxSend = 33] = "MixerAuxSend", i[i.MixerAuxReceive = 34] = "MixerAuxReceive", i))(h || {});
o.util.setEnumType(h, "audiotool.document.v1.opt.TargetType", [
  { no: 0, name: "Groove" },
  { no: 1, name: "Sample" },
  { no: 2, name: "MicroTuning" },
  { no: 3, name: "Listenable" },
  { no: 4, name: "AutomatableParameter" },
  { no: 6, name: "AudioInput" },
  { no: 7, name: "AudioOutput" },
  { no: 8, name: "NotesInput" },
  { no: 9, name: "NotesOutput" },
  { no: 10, name: "AutomationCollection" },
  { no: 11, name: "AudioTrack" },
  { no: 12, name: "AudioTrackPlayer" },
  { no: 13, name: "PatternTrack" },
  { no: 14, name: "PatternTrackPlayer" },
  { no: 16, name: "NoteCollection" },
  { no: 17, name: "NoteTrack" },
  { no: 18, name: "NoteTrackPlayer" },
  { no: 19, name: "AutomationTrack" },
  { no: 20, name: "Waveshaper" },
  { no: 21, name: "Centroid" },
  { no: 22, name: "RasselbockPatternSlot" },
  { no: 23, name: "TonematrixPatternSlot" },
  { no: 24, name: "Beatbox8PatternSlot" },
  { no: 25, name: "Beatbox9PatternSlot" },
  { no: 26, name: "BasslinePatternSlot" },
  { no: 27, name: "MachinistePatternSlot" },
  { no: 28, name: "MatrixArpeggiatorPatternSlot" },
  { no: 29, name: "MixerStripGroup" },
  { no: 30, name: "MixerStripGroupChild" },
  { no: 31, name: "MixerSideChainInput" },
  { no: 32, name: "MixerSideChainOutput" },
  { no: 33, name: "MixerAuxSend" },
  { no: 34, name: "MixerAuxReceive" }
]);
var D = /* @__PURE__ */ ((i) => (i[i.UNSPECIFIED = 0] = "UNSPECIFIED", i[i.UUID = 1] = "UUID", i))(D || {});
o.util.setEnumType(D, "audiotool.document.v1.opt.StringFormat", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "UUID" }
]);
const r = class r extends s {
  constructor(t) {
    super();
    /**
     * The fixed length of the list.
     *
     * @generated from field: uint32 length = 1;
     */
    e(this, "length", 0);
    /**
     * Mark each element in a list of a list of TargetTypes.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType element_is = 2;
     */
    e(this, "elementIs", []);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new r().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new r().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new r().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(r, t, n);
  }
};
e(r, "runtime", o), e(r, "typeName", "audiotool.document.v1.opt.ListOptions"), e(r, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "length",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  },
  { no: 2, name: "element_is", kind: "enum", T: o.getEnumType(h), repeated: !0 }
]));
let p = r;
const u = class u extends s {
  constructor(t) {
    super();
    /**
     * Marks a field location with a specific name.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType is = 1;
     */
    e(this, "is", []);
    /**
     * Marks a field as immutable. Transactions updating the field are rejected. Has no effect
     * on fields that are messages other than Pointer.
     *
     * @generated from field: bool immutable = 2;
     */
    e(this, "immutable", !1);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new u().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new u().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new u().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(u, t, n);
  }
};
e(u, "runtime", o), e(u, "typeName", "audiotool.document.v1.opt.FieldOptions"), e(u, "fields", o.util.newFieldList(() => [
  { no: 1, name: "is", kind: "enum", T: o.getEnumType(h), repeated: !0 },
  {
    no: 2,
    name: "immutable",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]));
let B = u;
const m = class m extends s {
  constructor(t) {
    super();
    /**
     * Marks a field location with a specific name.
     *
     * @generated from field: repeated audiotool.document.v1.opt.TargetType is = 1;
     */
    e(this, "is", []);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new m().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new m().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new m().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(m, t, n);
  }
};
e(m, "runtime", o), e(m, "typeName", "audiotool.document.v1.opt.EntityOptions"), e(m, "fields", o.util.newFieldList(() => [
  { no: 1, name: "is", kind: "enum", T: o.getEnumType(h), repeated: !0 }
]));
let N = m;
const l = class l extends s {
  constructor(t) {
    super();
    /**
     * Restricts the field to only point to locations with a specific TargetType.
     *
     * @generated from field: audiotool.document.v1.opt.TargetType target = 1;
     */
    e(this, "target", 0);
    /**
     * If this is true, the document is invalid if the value is not set to a valid
     * destination.
     *
     * @generated from field: bool required = 2;
     */
    e(this, "required", !1);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new l().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new l().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new l().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(l, t, n);
  }
};
e(l, "runtime", o), e(l, "typeName", "audiotool.document.v1.opt.PointerOptions"), e(l, "fields", o.util.newFieldList(() => [
  { no: 1, name: "target", kind: "enum", T: o.getEnumType(h) },
  {
    no: 2,
    name: "required",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]));
let A = l;
const c = class c extends s {
  constructor(t) {
    super();
    /**
     * Required format of this string field.
     *
     * @generated from field: audiotool.document.v1.opt.StringFormat format = 1;
     */
    e(this, "format", 0);
    /**
     * Maximum byte length of this string field. Note that unicode character != 1 byte in general.
     * Must be set on any string field that has format "unspecified".
     *
     * @generated from field: uint32 max_byte_length = 2;
     */
    e(this, "maxByteLength", 0);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new c().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new c().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new c().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(c, t, n);
  }
};
e(c, "runtime", o), e(c, "typeName", "audiotool.document.v1.opt.String"), e(c, "fields", o.util.newFieldList(() => [
  { no: 1, name: "format", kind: "enum", T: o.getEnumType(D) },
  {
    no: 2,
    name: "max_byte_length",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]));
let M = c;
const d = class d extends s {
  constructor(t) {
    super();
    /**
     * Suggested default value of this field.
     *
     * @generated from field: bool init = 1;
     */
    e(this, "init", !1);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new d().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new d().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new d().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(d, t, n);
  }
};
e(d, "runtime", o), e(d, "typeName", "audiotool.document.v1.opt.Bool"), e(d, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "init",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]));
let q = d;
const f = class f extends s {
  constructor(t) {
    super();
    /**
     * Suggested default value of this field.
     *
     * @generated from field: int32 init = 1;
     */
    e(this, "init", 0);
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.Int32Range range = 2;
     */
    e(this, "range");
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new f().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new f().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new f().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(f, t, n);
  }
};
e(f, "runtime", o), e(f, "typeName", "audiotool.document.v1.opt.Int32"), e(f, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "init",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 2, name: "range", kind: "message", T: C }
]));
let b = f;
const x = class x extends s {
  constructor(t) {
    super();
    /**
     * lower bound of validity range
     *
     * @generated from field: int32 min = 1;
     */
    e(this, "min", 0);
    /**
     * Upper bound of validity range.
     *
     * @generated from field: int32 max = 2;
     */
    e(this, "max", 0);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new x().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new x().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new x().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(x, t, n);
  }
};
e(x, "runtime", o), e(x, "typeName", "audiotool.document.v1.opt.Int32Range"), e(x, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "min",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 2,
    name: "max",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]));
let C = x;
const k = class k extends s {
  constructor(t) {
    super();
    /**
     * Suggested default value of this field.
     *
     * @generated from field: uint32 init = 1;
     */
    e(this, "init", 0);
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.UInt32Range range = 2;
     */
    e(this, "range");
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new k().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new k().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new k().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(k, t, n);
  }
};
e(k, "runtime", o), e(k, "typeName", "audiotool.document.v1.opt.UInt32"), e(k, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "init",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  },
  { no: 2, name: "range", kind: "message", T: L }
]));
let E = k;
const S = class S extends s {
  constructor(t) {
    super();
    /**
     * Lower bound of validity range.
     *
     * @generated from field: uint32 min = 1;
     */
    e(this, "min", 0);
    /**
     * Upper bound of validity range.
     *
     * @generated from field: uint32 max = 2;
     */
    e(this, "max", 0);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new S().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new S().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new S().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(S, t, n);
  }
};
e(S, "runtime", o), e(S, "typeName", "audiotool.document.v1.opt.UInt32Range"), e(S, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "min",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  },
  {
    no: 2,
    name: "max",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]));
let L = S;
const P = class P extends s {
  constructor(t) {
    super();
    /**
     * Default value of this field.
     *
     * @generated from field: float init = 1;
     */
    e(this, "init", 0);
    /**
     * Optional validity range of this field.
     *
     * @generated from field: audiotool.document.v1.opt.FloatRange range = 2;
     */
    e(this, "range");
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new P().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new P().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new P().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(P, t, n);
  }
};
e(P, "runtime", o), e(P, "typeName", "audiotool.document.v1.opt.Float"), e(P, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "init",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  },
  { no: 2, name: "range", kind: "message", T: F }
]));
let G = P;
const w = class w extends s {
  constructor(t) {
    super();
    /**
     * Lower bound of validity range.
     *
     * @generated from field: float min = 1;
     */
    e(this, "min", 0);
    /**
     * Upper bound of validity range.
     *
     * @generated from field: float max = 2;
     */
    e(this, "max", 0);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new w().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new w().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new w().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(w, t, n);
  }
};
e(w, "runtime", o), e(w, "typeName", "audiotool.document.v1.opt.FloatRange"), e(w, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "min",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  },
  {
    no: 2,
    name: "max",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }
]));
let F = w;
const J = class J extends s {
  constructor(t) {
    super();
    /**
     * Maximum byte length of this bytes field.
     *
     * @generated from field: uint32 max_byte_length = 1;
     */
    e(this, "maxByteLength", 0);
    o.util.initPartial(t, this);
  }
  static fromBinary(t, n) {
    return new J().fromBinary(t, n);
  }
  static fromJson(t, n) {
    return new J().fromJson(t, n);
  }
  static fromJsonString(t, n) {
    return new J().fromJsonString(t, n);
  }
  static equals(t, n) {
    return o.util.equals(J, t, n);
  }
};
e(J, "runtime", o), e(J, "typeName", "audiotool.document.v1.opt.Bytes"), e(J, "fields", o.util.newFieldList(() => [
  {
    no: 1,
    name: "max_byte_length",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]));
let I = J;
const H = o.makeExtension(
  "audiotool.document.v1.opt.bool",
  v,
  () => ({ no: 50002, kind: "message", T: q })
), K = o.makeExtension(
  "audiotool.document.v1.opt.int32",
  v,
  () => ({ no: 50003, kind: "message", T: b })
), O = o.makeExtension(
  "audiotool.document.v1.opt.uint32",
  v,
  () => ({ no: 50004, kind: "message", T: E })
), Q = o.makeExtension(
  "audiotool.document.v1.opt.float",
  v,
  () => ({ no: 50005, kind: "message", T: G })
), V = o.makeExtension(
  "audiotool.document.v1.opt.string",
  v,
  () => ({ no: 50006, kind: "message", T: M })
), X = o.makeExtension(
  "audiotool.document.v1.opt.bytes",
  v,
  () => ({ no: 50009, kind: "message", T: I })
), Y = o.makeExtension(
  "audiotool.document.v1.opt.pointer",
  v,
  () => ({ no: 50007, kind: "message", T: A })
), Z = o.makeExtension(
  "audiotool.document.v1.opt.list",
  v,
  () => ({ no: 50001, kind: "message", T: p })
), R = o.makeExtension(
  "audiotool.document.v1.opt.field",
  v,
  () => ({ no: 50008, kind: "message", T: B })
), g = o.makeExtension(
  "audiotool.document.v1.opt.entity",
  $,
  () => ({ no: 5e3, kind: "message", T: N })
);
export {
  q as B,
  N as E,
  B as F,
  b as I,
  p as L,
  A as P,
  D as S,
  h as T,
  E as U,
  M as a,
  C as b,
  L as c,
  G as d,
  F as e,
  I as f,
  H as g,
  Q as h,
  K as i,
  X as j,
  R as k,
  Z as l,
  g as m,
  Y as p,
  V as s,
  O as u
};
