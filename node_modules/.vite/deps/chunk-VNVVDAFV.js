// node_modules/@audiotool/nexus/dist/observable-notifier-value-BmUQV8XP.js
var v = (r) => {
  throw TypeError(r);
};
var M = (r, e, t2) => e.has(r) || v("Cannot " + t2);
var s = (r, e, t2) => (M(r, e, "read from private field"), t2 ? t2.call(r) : e.get(r));
var h = (r, e, t2) => e.has(r) ? v("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t2);
var u = (r, e, t2, i) => (M(r, e, "write to private field"), i ? i.call(r, t2) : e.set(r, t2), t2);
var E = async (r, e) => {
  try {
    return await fetch(r, e);
  } catch (t2) {
    return new Error("error during fetch", { cause: t2 });
  }
};
var l;
var m;
var f;
var T = class {
  /** if `warnAfterMs` is set, the lock will emit a warning if a call to `lock.aquire()
   * tok more than `warnAfterMs` milliseconds.
   */
  constructor(e) {
    h(this, l, false);
    h(this, m, []);
    h(this, f);
    u(this, f, (e == null ? void 0 : e.warnAfterMs) ?? void 0);
  }
  /**
   * Wait until no other async thread holds a lock, then returns a lock.
   *
   * Once the lock is held, all other threads that call `acquire()` will have to wait until
   * the lock is released.
   *
   *
   * Release the lock with `lock.release()`.
   *
   * Example:
   * ```ts
   * const lock = new AsyncLock()
   * ...
   * const l = await lock.acquire()
   * // do stuff
   * l.release()
   * ```
   *
   */
  async acquire() {
    let e = () => {
    };
    s(this, f) !== void 0 && (e = k(
      s(this, f),
      `Waited for lock.aquire() for more than ${s(this, f)} ms, deadlock?`
    )), s(this, l) && await new Promise((i) => s(this, m).push(i)), e(), u(this, l, true);
    let t2 = false;
    return {
      release: () => {
        var i;
        if (t2)
          throw new Error("Lock already released");
        t2 = true, s(this, m).length > 0 ? (i = s(this, m).shift()) == null || i() : u(this, l, false);
      }
    };
  }
  /**
   * Execute a function after acquiring a lock, and release the lock after the function is done.
   *
   * Example:
   * ```ts
   * const v = await lock.runAcquired(() => {
   *  // do something
   *  return 42
   * })
   * ```
   *
   * This function is **safe against exceptions**. If the function throws an exception, the lock
   * is released before the exception is thrown.
   *
   */
  async runAcquired(e) {
    const t2 = await this.acquire();
    let i;
    try {
      return i = await e(), t2.release(), i;
    } catch (S) {
      throw t2.release(), S;
    }
  }
  /** Weather the lock is currently taken. Because javascript is single-threaded, it is safe
   * to do e.g.:
   * ```ts
   * if (!lock.locked) {
   *   lock.acquire()
   *   // do something
   *   lock.release()
   * }
   *
   * ```
   *
   * without `await`ing the `lock.acquire()`.
   */
  get locked() {
    return s(this, l);
  }
};
l = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
var k = (r, e) => {
  const t2 = setTimeout(() => {
    console.warn(e), console.trace("Waited here:");
  }, r);
  return () => clearTimeout(t2);
};
var d;
var A = class {
  constructor() {
    h(this, d, /* @__PURE__ */ new Set());
  }
  // A set allows us to remove while iterating
  subscribe(e) {
    return s(this, d).add(e), { terminate: () => s(this, d).delete(e) };
  }
  notify(e) {
    s(this, d).forEach((t2) => t2(e));
  }
  terminate() {
    s(this, d).clear();
  }
};
d = /* @__PURE__ */ new WeakMap();
var w = Symbol();
var a;
var N = class {
  constructor() {
    h(this, a, /* @__PURE__ */ new Map());
  }
  clear() {
    s(this, a).clear();
  }
  delete(e) {
    const t2 = e[w];
    return s(this, a).delete(t2);
  }
  forEach(e, t2) {
    s(this, a).forEach(([i, S]) => {
      e(S, i, this);
    }, t2);
  }
  entries() {
    return s(this, a).entries().map(([e, [t2, i]]) => [t2, i]);
  }
  get(e) {
    var t2;
    return (t2 = s(this, a).get(e[w])) == null ? void 0 : t2[1];
  }
  has(e) {
    return s(this, a).has(e[w]);
  }
  keys() {
    return s(this, a).values().map(([e, t2]) => e);
  }
  set(e, t2) {
    const i = e[w];
    return s(this, a).set(i, [e, t2]), this;
  }
  values() {
    return s(this, a).values().map(([e, t2]) => t2);
  }
  get size() {
    return s(this, a).size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "StringHashMap";
  }
};
a = /* @__PURE__ */ new WeakMap();
var b;
var c;
var g;
var _ = class {
  constructor(e) {
    h(this, b, new A());
    h(this, c);
    h(this, g, V(s(this, b)));
    u(this, c, e);
  }
  getValue() {
    return s(this, g).call(this), s(this, c);
  }
  setValue(e) {
    s(this, c) !== e && (u(this, c, e), s(this, b).notify(e));
  }
  subscribe(e, t2 = false) {
    return t2 && e(s(this, c)), s(this, b).subscribe(e);
  }
  terminate() {
    s(this, b).terminate();
  }
};
b = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
var o;
var y;
var n;
var p = class {
  constructor(e) {
    h(this, o, new A());
    h(this, y, V(s(this, o)));
    h(this, n);
    u(this, n, e ?? /* @__PURE__ */ new Map());
  }
  /** Subscribe to updates of the set */
  subscribe(e, t2 = false) {
    return t2 && e(s(this, n)), s(this, o).subscribe(() => e(s(this, n)));
  }
  /** Get the underlying map. Readonly because changing it won't trigger updates. */
  getValue() {
    return s(this, y).call(this), s(this, n);
  }
  set(e, t2) {
    return s(this, n).set(e, t2), s(this, o).notify(), this;
  }
  delete(e) {
    const t2 = s(this, n).delete(e);
    return t2 && s(this, o).notify(), t2;
  }
  clear() {
    const e = s(this, n).size > 0;
    s(this, n).clear(), e && s(this, o).notify();
  }
};
o = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
var V = (r) => () => {
};

// node_modules/@audiotool/nexus/dist/lang-KJQpoj7q.js
var t = (r) => {
  throw r instanceof Error ? r : new Error(r);
};
function n2(r, o2) {
  if (!r)
    throw new Error(o2 ?? "assertion failed");
}
var s2 = (r) => new Promise((o2) => setTimeout(o2, r));

export {
  E,
  T,
  A,
  w,
  N,
  _,
  p,
  t,
  n2 as n,
  s2 as s
};
//# sourceMappingURL=chunk-VNVVDAFV.js.map
